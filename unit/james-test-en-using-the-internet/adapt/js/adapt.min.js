define('core/js/models/lockingModel',[],function() {

	var set = Backbone.Model.prototype.set;

	_.extend(Backbone.Model.prototype, {

		set: function(attrName, attrVal, options) {
			var stopProcessing = !this.lockedAttributes || typeof attrName === "object" || typeof attrVal !== "boolean" || !this.isLocking(attrName);
			if (stopProcessing) return set.apply(this, arguments);
			
			options = options || {};

			var isSettingValueForSpecificPlugin = options && options.pluginName;
			if (!isSettingValueForSpecificPlugin) {
				console.error("Must supply a pluginName to change a locked attribute");
				options.pluginName = "compatibility";
			}

			var pluginName  = options.pluginName;
			if (this.defaults[attrName] !== undefined) {
				this.lockedAttributes[attrName] = !this.defaults[attrName];
			}
			var lockingValue = this.lockedAttributes[attrName];
			var isAttemptingToLock = (lockingValue === attrVal);

			if (isAttemptingToLock) {

				this.setLockState(attrName, true, {pluginName:pluginName, skipcheck: true});

				//console.log(options.pluginName, "locking", attrName, "on", this.get("_id"));
				return set.call(this, attrName, lockingValue);

			}

			this.setLockState(attrName, false, {pluginName:pluginName, skipcheck: true});

			var totalLockValue = this.getLockCount(attrName, {skipcheck: true});
			//console.log(options.pluginName, "attempting to unlock", attrName, "on", this.get("_id"), "lockValue", totalLockValue, this._lockedAttributesValues[attrName]);
			if (totalLockValue === 0) {
				//console.log(options.pluginName, "unlocking", attrName, "on", this.get("_id"));
				return set.call(this, attrName, !lockingValue);
			}

			return this;

		},

		setLocking: function(attrName, defaultLockValue) {
			if (this.isLocking(attrName)) return;
			if (!this.lockedAttributes) this.lockedAttributes = {};
			this.lockedAttributes[attrName] = defaultLockValue;
		},

		unsetLocking: function(attrName) {
			if (!this.isLocking(attrName)) return;
			if (!this.lockedAttributes) return;
			delete this.lockedAttributes[attrName];
			delete this._lockedAttributesValues[attrName];
			if (_.keys(this.lockedAttributes).length === 0) {
				delete this.lockedAttributes;
				delete this._lockedAttributesValues;
			}
		},

		isLocking: function(attrName) {
			var isCheckingGeneralLockingState = (attrName === undefined);
			var isUsingLockedAttributes = (this.lockedAttributes !== undefined);

			if (isCheckingGeneralLockingState) {
				return isUsingLockedAttributes;
			}

			if (!isUsingLockedAttributes) return false;

			var isAttributeALockingAttribute = this.lockedAttributes[attrName] !== undefined;
			if (!isAttributeALockingAttribute) return false;

			if (this._lockedAttributesValues === undefined) {
				this._lockedAttributesValues = {};
			}

			if (this._lockedAttributesValues[attrName] === undefined) {
				this._lockedAttributesValues[attrName] = {};	
			}

			return true;
		},

		isLocked: function(attrName, options) {
			var shouldSkipCheck = (options && options.skipcheck);
			if (!shouldSkipCheck) { 
				var stopProcessing =  !this.isLocking(attrName);
				if (stopProcessing) return;
			}

			return this.getLockCount(attrName) > 0;
		},

		getLockCount: function(attrName, options) {
			var shouldSkipCheck = (options && options.skipcheck);
			if (!shouldSkipCheck) { 
				var stopProcessing =  !this.isLocking(attrName);
				if (stopProcessing) return;
			}

			var isGettingValueForSpecificPlugin = options && options.pluginName;
			if (isGettingValueForSpecificPlugin) {

				return this._lockedAttributesValues[attrName][options.pluginName] ? 1 : 0;
			}

			var lockingAttributeValues = _.values(this._lockedAttributesValues[attrName]);
			var lockingAttributeValuesSum = _.reduce(lockingAttributeValues, function(sum, value){ return sum + (value ? 1 : 0); }, 0);
			
			return lockingAttributeValuesSum;
		},

		setLockState: function(attrName, value, options) {
			var shouldSkipCheck = (options && options.skipcheck);
			if (!shouldSkipCheck) { 
				var stopProcessing =  !this.isLocking(attrName);
				if (stopProcessing) return this;
			}

			var isSettingValueForSpecificPlugin = options && options.pluginName;
			if (!isSettingValueForSpecificPlugin) {
				console.error("Must supply a pluginName to set a locked attribute lock value");
				options.pluginName = "compatibility";
			}

			if (value) {
				this._lockedAttributesValues[attrName][options.pluginName] = value;
			} else {
				delete this._lockedAttributesValues[attrName][options.pluginName];
			}

			return this;

		}

	});

});

define('core/js/wait',[],function() {

     var Wait = Backbone.Controller.extend({

        initialize: function() {
            _.bindAll(this, "begin", "end");
        },

        _waitCount: 0,
        _callbackHandle: null,

        /**
         * Returns true if there are items in the waiting count.
         * 
         * @return {Boolean}
         */
        isWaiting: function() {
            return (this._waitCount !== 0);
        },

        /**
         * Add one item to the waiting count.
         * 
         * @return {Object}
         */
        begin: function() {

            if (!this.isWaiting()) {
                this.trigger("wait");
            }

            this._waitCount++;

            if (this._callbackHandle) {
                clearTimeout(this._callbackHandle);
                this._callbackHandle = null;
            }

            return this;

        },

        /**
         * Remove an item from the waiting count and trigger ready asynchronously if no more items are waiting.
         * 
         * @return {Object}
         */
        end: function() {

            if (!this.isWaiting()) {
                return this;
            }

            this._waitCount--;

            if (this.isWaiting()) {
                return this;
            }
            
            if (this._callbackHandle) {
                return this;
            }

            this._callbackHandle = setTimeout(function() {

                this._callbackHandle = null;
                this.trigger("ready");

            }.bind(this), 0);

            return this;

        },

        /**
         * Queue this function until all open waits have been ended.
         * 
         * @param  {Function} callback
         * @return {Object}
         */
        queue: function(callback) {

            this.begin();
            this.once("ready", callback);
            this.end();

            return this;

        },

        /**
         * Wait for this asynchonous function to execute before triggering ready event.
         * 
         * @param  {Function} callback   [ Function to execute whilst holding queued callback. Once complete run first argiument, done(). ]
         * @return {Object}
         */
        for: function(callback) {

            this.begin();
            _.defer(function() {
                callback(this.end);
            }.bind(this));

            return this;

        }

    });

    return Wait;

});
define('core/js/adapt',[
    'core/js/models/lockingModel',
    'core/js/wait'
], function(lockingModel, Wait) {

    var AdaptModel = Backbone.Model.extend({

        defaults: {
            _canScroll: true, //to stop scrollTo behaviour,
            _outstandingCompletionChecks: 0,
            _pluginWaitCount:0,
            _isStarted: false
        },

        lockedAttributes: {
            _canScroll: false
        },

        initialize: function () {
            this.setupWait();
        },

        //call when entering an asynchronous completion check
        checkingCompletion: function() {
            var outstandingChecks = this.get("_outstandingCompletionChecks");
            this.set("_outstandingCompletionChecks", ++outstandingChecks);
        },

        //call when exiting an asynchronous completion check
        checkedCompletion: function() {
            var outstandingChecks = this.get("_outstandingCompletionChecks");
            this.set("_outstandingCompletionChecks", --outstandingChecks);
        },

        //wait until there are no outstanding completion checks
        deferUntilCompletionChecked: function(callback) {

            if (this.get("_outstandingCompletionChecks") === 0) return callback();

            var checkIfAnyChecksOutstanding = function(model, outstandingChecks) {
                if (outstandingChecks !== 0) return;

                Adapt.off("change:_outstandingCompletionChecks", checkIfAnyChecksOutstanding);

                callback();
            };

            Adapt.on("change:_outstandingCompletionChecks", checkIfAnyChecksOutstanding);

        },

        setupWait: function() {

            this.wait = new Wait();

            // Setup legcay events and handlers
            var beginWait = function () {
                Adapt.log.warn("DEPRECATED - Use Adapt.wait.begin() as Adapt.trigger('plugin:beginWait') may be removed in the future");
                this.wait.begin();
            }.bind(this);

            var endWait = function() {
                Adapt.log.warn("DEPRECATED - Use Adapt.wait.end() as Adapt.trigger('plugin:endWait') may be removed in the future");
                this.wait.end();
            }.bind(this);

            var ready = function() {

                if (this.wait.isWaiting()) {
                    return;
                }

                var isEventListening = (this._events['plugins:ready']);
                if (!isEventListening) {
                    return;
                }

                Adapt.log.warn("DEPRECATED - Use Adapt.wait.queue(callback) as Adapt.on('plugins:ready', callback) may be removed in the future");
                this.trigger('plugins:ready');

            }.bind(this);

            this.listenTo(this.wait, "ready", ready);
            this.listenTo(this, {
                'plugin:beginWait': beginWait,
                'plugin:endWait': endWait
            });

        },

        isWaitingForPlugins:function() {
            Adapt.log.warn("DEPRECATED - Use Adapt.wait.isWaiting() as Adapt.isWaitingForPlugins() may be removed in the future");
            return this.wait.isWaiting();
        },

        checkPluginsReady:function() {
            Adapt.log.warn("DEPRECATED - Use Adapt.wait.isWaiting() as Adapt.checkPluginsReady() may be removed in the future");
            if (this.isWaitingForPlugins()) {
                return;
            }
            this.trigger('plugins:ready');
        }

    });

    var Adapt = new AdaptModel();

    Adapt.location = {};
    Adapt.componentStore = {};
    Adapt.mappedIds = {};

    Adapt.loadScript = window.__loadScript;

    Adapt.initialize = function() {

        //wait until no more completion checking
        Adapt.deferUntilCompletionChecked(function() {

            //start adapt in a full restored state
            Adapt.trigger('adapt:start');

            if (!Backbone.History.started) {
                Backbone.history.start();
            }

            Adapt.set("_isStarted", true);

            Adapt.trigger('adapt:initialize');

        });

    };

    Adapt.navigateToElement = function(selector, settings) {
        // Allows a selector to be passed in and Adapt will navigate to this element

        // Setup settings object
        var settings = (settings || {});

        // Removes . symbol from the selector to find the model
        var currentModelId = selector.replace(/\./g, '');
        var currentModel = Adapt.findById(currentModelId);
        // Get current page to check whether this is the current page
        var currentPage = (currentModel._siblings === 'contentObjects') ? currentModel : currentModel.findAncestor('contentObjects');

        // If current page - scrollTo element
        if (currentPage.get('_id') === Adapt.location._currentId) {
           return Adapt.scrollTo(selector, settings);
        }

        // If the element is on another page navigate and wait until pageView:ready is fired
        // Then scrollTo element
        Adapt.once('pageView:ready', function() {
            _.defer(function() {
                Adapt.router.set("_shouldNavigateFocus", true);
                Adapt.scrollTo(selector, settings);
            });
        });

        var shouldReplaceRoute = settings.replace || false;
        
        Adapt.router.set("_shouldNavigateFocus", false);
        Backbone.history.navigate('#/id/' + currentPage.get('_id'), {trigger: true, replace: shouldReplaceRoute});
    };

    Adapt.register = function(name, object) {
        // Used to register components
        // Store the component view
        if (Adapt.componentStore[name]) {
            throw Error('The component "' + name + '" already exists in your project');
        }
        
        if (object.view) {
            //use view+model object
            if(!object.view.template) object.view.template = name;
        } else {
            //use view object
            if(!object.template) object.template = name;
        }

        Adapt.componentStore[name] = object;

        return object;
    };

    Adapt.getViewClass = function(name) {
        var object = Adapt.componentStore[name];
        if (!object) {
            throw Error('The component "' + name + '" doesn\'t exist in your project');
        }
        return object.view || object;
    };

    // Used to map ids to collections
    Adapt.setupMapping = function() {
        // Clear any existing mappings.
        Adapt.mappedIds = {};

        // Setup course Id
        Adapt.mappedIds[Adapt.course.get('_id')] = "course";

        // Setup each collection
        var collections = ["contentObjects", "articles", "blocks", "components"];

        for (var i = 0, len = collections.length; i < len; i++) {
            var collection = collections[i];
            var models = Adapt[collection].models;
            for (var j = 0, lenj = models.length; j < lenj; j++) {
                var model = models[j];
                Adapt.mappedIds[model.get('_id')] = collection;

            }
        }

    };

    Adapt.mapById = function(id) {
        // Returns collection name that contains this models Id
        return Adapt.mappedIds[id];
    };

    Adapt.findById = function(id) {

        // Return a model
        // Checks if the Id passed in is the course Id
        if (id === Adapt.course.get('_id')) {
            return Adapt.course;
        }

        var collectionType = Adapt.mapById(id);

        if (!collectionType) {
            console.warn('Adapt.findById() unable to find collection type for id: ' + id);
            return;
        }

        return Adapt[collectionType]._byAdaptID[id][0];

    };

    // Relative strings describe the number and type of hops in the model hierarchy
    //
    // "@component +1" means to move one component forward from the current model
    // This function would return the following:
    // {
    //       type: "component",
    //       offset: 1
    // }
    // Trickle uses this function to determine where it should scrollTo after it unlocks
    Adapt.parseRelativeString = function(relativeString) {

        if (relativeString[0] === "@") {
            relativeString = relativeString.substr(1);
        }

        var type = relativeString.match(/(component|block|article|page|menu)/);
        if (!type) {
            Adapt.log.error("Adapt.parseRelativeString() could not match relative type", relativeString);
            return;
        }
        type = type[0];

        var offset = parseInt(relativeString.substr(type.length).trim()||0);
        if (isNaN(offset)) {
            Adapt.log.error("Adapt.parseRelativeString() could not parse relative offset", relativeString);
            return;
        }

        return {
            type: type,
            offset: offset
        };

    };

    Adapt.remove = function() {
        Adapt.trigger('preRemove');
        Adapt.trigger('remove');
        _.defer(function() {
            Adapt.trigger('postRemove');
        });
    };

    return Adapt;

});

define('core/js/adaptCollection',[
    'core/js/adapt'
], function(Adapt) {

    var AdaptCollection = Backbone.Collection.extend({
        initialize : function(models, options){
            this.url = options.url;

            this.once('reset', this.loadedData, this);
            if (this.url) {
                this.fetch({
                    reset:true,
                    error: _.bind(function(model, xhr, options) {
                        console.error("ERROR: unable to load file " + this.url);
                    }, this)
                });
            }
        },

        loadedData: function() {
            Adapt.trigger('adaptCollection:dataLoaded');
        }

    });

    return AdaptCollection;

});

define('core/js/startController',[
    'core/js/adapt'
], function(Adapt) {
    
    var StartController = Backbone.Controller.extend({

        model: null,

        initialize: function() {
            this.model = new Backbone.Model(Adapt.course.get("_start"));
        },

        setStartLocation: function() {
            if (!this.isEnabled()) return;
            window.history.replaceState('', '', this.getStartHash());
        },

        getStartHash: function(alwaysForce) {
            var startId = this.getStartId();

            var hasStartId = (startId)
                ? true
                : false;

            var isRouteSpecified = (_.indexOf(window.location.href,"#") > -1);
            var shouldForceStartId = alwaysForce || this.model.get("_force");
            var shouldNavigateToStartId = hasStartId && (!isRouteSpecified || shouldForceStartId);

            var startHash = "#/";
            if (shouldNavigateToStartId) {
                if (startId !== Adapt.course.get("_id")) {
                    startHash = "#/id/"+startId;
                }
            } else {
                //go to specified route or course main menu
                var hasLocationHash = (window.location.hash)
                    ? true
                    : false;

                startHash = hasLocationHash ? window.location.hash : startHash;
            }

            return startHash;
        },

        isEnabled: function() {
            if (!this.model || !this.model.get("_isEnabled")) return false;
            return true;
        },

        getStartId: function() {
            var startId = this.model.get("_id");
            var startIds = this.model.get("_startIds");
            var $html = $("html");
            
            var hasStartIdsConfiguration = (startIds && startIds.length > 0);
            if (hasStartIdsConfiguration) {
                for (var i = 0, l =  startIds.length; i < l; i++) {
                    var item = startIds[i];
                    var className =  item._className;
                    var skipIfComplete = item._skipIfComplete;
                    
                    var model = Adapt.findById(item._id);
                    
                    if (!model) {
                        console.log("startController: cannot find id", item._id);
                        continue;
                    }
                    
                    if (skipIfComplete) {
                        if (model.get("_isComplete")) continue;
                    }

                    if (!className || $html.is(className) || $html.hasClass(className)) {
                        startId = item._id;
                        break;
                    }
                }
            }

            return startId;
        }

    });

    Adapt.once("adapt:start", function() {
        var startController = new StartController();
        startController.setStartLocation();
    });

    return StartController;

});

define('core/js/enums/logLevelEnum',[],function() {

    // Used to determine if log call should be printed based on log level
    var LOG_LEVEL = ENUM([
        "DEBUG",
        "INFO",
        "WARN",
        "ERROR",
        "FATAL"
    ]);

    return LOG_LEVEL;

});
define('core/js/logging',[
    'core/js/adapt',
    'core/js/enums/logLevelEnum'
], function(Adapt, LOG_LEVEL) {

    var Logging = Backbone.Controller.extend({

        _config: {
            _isEnabled: true,
            _level: LOG_LEVEL.INFO.asLowerCase, // Default log level
            _console: true // Log to console
        },      
        
        initialize: function() {

            Adapt.once('configModel:loadCourseData', this.onLoadCourseData.bind(this));

        },
        
        onLoadCourseData: function() {

            this.loadConfig();

            this.debug('Logging config loaded');

            this.trigger('log:ready');

        },

        loadConfig: function() {

            if (Adapt.config.has('_logging')) {
                this._config = Adapt.config.get('_logging');
            }

            this.checkQueryStringOverride();

        },

        checkQueryStringOverride: function() {

            // Override default log level with level present in query string
            var matches = window.location.search.match(/[?&]loglevel=([a-z]*)/i);
            if (!matches || matches.length < 2) return;

            var override = LOG_LEVEL(matches[1].toUpperCase());
            if (!override) return;

            this._config._level = override.asLowerCase;
            this.debug('Loglevel override in query string:', this._config._level);
            
        },
        
        debug: function() {            
            this._log(LOG_LEVEL.DEBUG, Array.prototype.slice.call(arguments));
        },
        
        info: function() {
            this._log(LOG_LEVEL.INFO, Array.prototype.slice.call(arguments));
        },
        
        warn: function() {
            this._log(LOG_LEVEL.WARN, Array.prototype.slice.call(arguments));
        },
        
        error: function() {
            this._log(LOG_LEVEL.ERROR, Array.prototype.slice.call(arguments));
        },
        
        fatal: function() {
            this._log(LOG_LEVEL.FATAL, Array.prototype.slice.call(arguments));
        },
        
        _log: function(level, data) {

            var isEnabled = (this._config._isEnabled);
            if (!isEnabled) return;

            var configLevel = LOG_LEVEL(this._config._level.toUpperCase());

            var isLogLevelAllowed = (level >= configLevel);
            if (!isLogLevelAllowed) return;

            this._logToConsole(level, data);

            // Allow error reporting plugins to hook and report to logging systems
            this.trigger('log', level, data);
            this.trigger('log:' + level.asLowerCase, level, data);

        },

        _logToConsole: function(level, data) {

            var shouldLogToConsole = (this._config._console);
            if (!shouldLogToConsole) return;

            var log = [level.asUpperCase + ':'];
            data && log.push.apply(log, data);

            // is there a matching console method we can use e.g. console.error()?
            if(console[level.asLowerCase]) {
                console[level.asLowerCase].apply(console, log);
            } else {
                console.log.apply(console, log);
            }
        }

    });

    Adapt.log = new Logging();
});

define('core/js/models/buildModel',[
    'core/js/adapt',
    'core/js/logging'
], function (Adapt) {

    var BuildModel = Backbone.Model.extend({

        defaults: {
            jsonext: 'json'
        },

        initialize: function(attrs, options) {
            this.url = options.url;
            // Fetch data & if successful trigger event to enable plugins to stop course files loading
            // Then check if course files can load
            // 'configModel:loadCourseData' event starts the core content collections and models being fetched
            this.fetch({
                success: _.bind(function() {
                    this.isLoaded = true;
                    Adapt.trigger('buildModel:dataLoaded');
                }, this),
                error: function() {
                    console.log('Unable to load adapt/js/build.js');
                    Adapt.trigger('buildModel:dataLoaded');
                }
            });
        }

    });

    return BuildModel;

});
define('core/js/models/adaptModel',[
    'core/js/adapt',
    'core/js/logging'
], function (Adapt) {

    var AdaptModel = Backbone.Model.extend({

        defaults: {
            _canShowFeedback: true,
            _classes: "",
            _canReset: false,
            _isComplete: false,
            _isInteractionComplete: false,
            _isA11yRegionEnabled: false,
            _isA11yCompletionDescriptionEnabled: true,
            _requireCompletionOf: -1,
            _isEnabled: true,
            _isResetOnRevisit: false,
            _isAvailable: true,
            _isOptional: false,
            _isReady: false,
            _isVisible: true,
            _isLocked: false,
            _isHidden: false
        },

        trackable: [
            '_id',
            '_isComplete',
            '_isInteractionComplete'
        ],

        initialize: function () {
            // Wait until data is loaded before setting up model
            this.listenToOnce(Adapt, 'app:dataLoaded', this.setupModel);

        },

        setupModel: function() {
            if (this.get('_type') === 'page') {
                this._children = 'articles';
            }
            if (this._siblings === 'contentObjects' && this.get('_parentId') !== Adapt.course.get('_id')) {
                this._parent = 'contentObjects';
            }
            if (this._children) {
                this.setupChildListeners();
            }

            this.init();

            _.defer(function() {
                if (this._children) {
                    this.checkCompletionStatus();

                    this.checkInteractionCompletionStatus();

                    this.checkLocking();
                }

                this.setupTrackables();

            }.bind(this));

        },

        setupTrackables: function() {

            // Limit state trigger calls and make state change callbacks batched-asynchronous
            var originalTrackableStateFunction = this.triggerTrackableState;
            this.triggerTrackableState = _.compose(
                function() {

                    // Flag that the function is awaiting trigger
                    this.triggerTrackableState.isQueued = true;

                }.bind(this),
                _.debounce(function() {

                    // Trigger original function
                    originalTrackableStateFunction.apply(this);

                    // Unset waiting flag
                    this.triggerTrackableState.isQueued = false;

                }.bind(this), 17)
            );

            // Listen to model changes, trigger trackable state change when appropriate
            this.listenTo(this, "change", function(model, value) {

                // Skip if trigger queued or adapt hasn't started yet
                if (this.triggerTrackableState.isQueued || !Adapt.attributes._isStarted) {
                    return;
                }

                // Check that property is trackable
                var trackablePropertyNames = _.result(this, 'trackable', []);
                var changedPropertyNames = _.keys(model.changed);
                var isTrackable = _.find(changedPropertyNames, function(item, index) {
                    return _.contains(trackablePropertyNames, item);
                }.bind(this));

                if (isTrackable) {
                    // Trigger trackable state change
                    this.triggerTrackableState();
                }
            });
        },

        setupChildListeners: function() {
            var children = this.getChildren();
            if (!children.length) {
                return;
            }

            this.listenTo(children, {
                "change:_isReady": this.checkReadyStatus,
                "change:_isComplete": this.onIsComplete,
                "change:_isInteractionComplete": this.checkInteractionCompletionStatus
            });
        },

        init: function() {},

        getTrackableState: function() {

            var trackable = this.resultExtend("trackable", []);
            var json = this.toJSON();

            var args = trackable;
            args.unshift(json);

            return _.pick.apply(_, args);

        },

        setTrackableState: function(state) {

            var trackable = this.resultExtend("trackable", []);

            var args = trackable;
            args.unshift(state);

            state = _.pick.apply(_, args);

            this.set(state);

            return this;

        },

        triggerTrackableState: function() {

            Adapt.trigger("state:change", this, this.getTrackableState());

        },

        reset: function(type, force) {
            if (!this.get("_canReset") && !force) return;

            type = type || true;

            switch (type) {
            case "hard": case true:
                this.set({
                    _isEnabled: true,
                    _isComplete: false,
                    _isInteractionComplete: false
                });
                break;
            case "soft":
                this.set({
                    _isEnabled: true,
                    _isInteractionComplete: false
                });
                break;
            }
        },

        checkReadyStatus: function () {
            // Filter children based upon whether they are available
            // Check if any return _isReady:false
            // If not - set this model to _isReady: true
            var children = this.getAvailableChildModels();
            if (_.find(children, function(child) { return child.get('_isReady') === false; })) {
                return;
            }

            this.set('_isReady', true);
        },

        setCompletionStatus: function() {
            if (!this.get('_isVisible')) return;

            this.set({
                _isComplete: true,
                _isInteractionComplete: true
            });
        },

        checkCompletionStatus: function () {
            //defer to allow other change:_isComplete handlers to fire before cascading to parent
            Adapt.checkingCompletion();
            _.defer(this.checkCompletionStatusFor.bind(this), '_isComplete');
        },

        checkInteractionCompletionStatus: function () {
            //defer to allow other change:_isInteractionComplete handlers to fire before cascading to parent
            Adapt.checkingCompletion();
            _.defer(this.checkCompletionStatusFor.bind(this), '_isInteractionComplete');
        },

        /**
         * Function for checking whether the supplied completion attribute should be set to true or false.
         * It iterates over our immediate children, checking the same completion attribute on any mandatory child
         * to see if enough/all of them them have been completed. If enough/all have, we set our attribute to true;
         * if not, we set it to false.
         * @param {string} [completionAttribute] Either "_isComplete" or "_isInteractionComplete". Defaults to "_isComplete" if not supplied.
         */
        checkCompletionStatusFor: function(completionAttribute) {
            if (!completionAttribute) completionAttribute = "_isComplete";

            var completed = false;
            var children = this.getAvailableChildModels();
            var requireCompletionOf = this.get("_requireCompletionOf");

            if (requireCompletionOf === -1) { // a value of -1 indicates that ALL mandatory children must be completed
                completed = (_.find(children, function(child) {
                    return !child.get(completionAttribute) && !child.get('_isOptional');
                }) === undefined);
            } else {
                completed = (_.filter(children, function(child) {
                    return child.get(completionAttribute) && !child.get('_isOptional');
                }).length >= requireCompletionOf);
            }

            this.set(completionAttribute, completed);

            Adapt.checkedCompletion();
        },

        /**
         * Searches the model's ancestors to find the first instance of the specified ancestor type
         * @param {string} [ancestorType] Valid values are 'course', 'pages', 'contentObjects', 'articles' or 'blocks'.
         * If left blank, the immediate ancestor (if there is one) is returned
         * @return {object} Reference to the model of the first ancestor of the specified type that's found - or `undefined` if none found
         */
        findAncestor: function (ancestorType) {
            var parent = this.getParent();
            if (!parent) return;

            if (ancestorType === 'pages') {
                ancestorType = 'contentObjects';
            }

            if (!ancestorType || this._parent === ancestorType) {
                return parent;
            }

            return parent.findAncestor(ancestorType);
        },

        /**
         * Returns all the descendant models of a specific type
         * @param {string} descendants Valid values are 'contentObjects', 'pages', 'menus', 'articles', 'blocks' or 'components'
         * @param {object} options an object that defines the search type and the properties/values to search on. Currently only the `where` search type (equivalent to `Backbone.Collection.where()`) is supported.
         * @param {object} options.where
         * @return {array}
         * @example
         * //find all available, non-optional components
         * this.findDescendantModels('components', { where: { _isAvailable: true, _isOptional: false }});
         */
        findDescendantModels: function(descendants, options) {

            var types = [
                descendants.slice(0, -1)
            ];
            if (descendants === 'contentObjects') {
                types.push.apply(types, ['page', 'menu']);
            }

            var allDescendantsModels = this.getAllDescendantModels();
            var returnedDescendants = allDescendantsModels.filter(function(model) {
                return _.contains(types, model.get("_type"));
            });

            if (!options) {
                return returnedDescendants;
            }

            if (options.where) {
                return returnedDescendants.filter(function(descendant) {
                    for (var property in options.where) {
                        var value = options.where[property];
                        if (descendant.get(property) !== value) {
                            return false;
                        }
                    }
                    return true;
                });
            }
        },

        /**
         * Fetches the sub structure of a model as a flattened array
         *
         * Such that the tree:
         *  { a1: { b1: [ c1, c2 ], b2: [ c3, c4 ] }, a2: { b3: [ c5, c6 ] } }
         *
         * will become the array (parent first = false):
         *  [ c1, c2, b1, c3, c4, b2, a1, c5, c6, b3, a2 ]
         *
         * or (parent first = true):
         *  [ a1, b1, c1, c2, b2, c3, c4, a2, b3, c5, c6 ]
         *
         * This is useful when sequential operations are performed on the menu/page/article/block/component hierarchy.
         * @param {boolean} [isParentFirst]
         * @return {array}
         */
        getAllDescendantModels: function(isParentFirst) {

            var descendants = [];

            if (this.get("_type") === "component") {
                descendants.push(this);
                return descendants;
            }

            var children = this.getChildren();

            for (var i = 0, l = children.models.length; i < l; i++) {

                var child = children.models[i];
                if (child.get("_type") === "component") {

                    descendants.push(child);
                    continue;

                }

                var subDescendants = child.getAllDescendantModels(isParentFirst);
                if (isParentFirst === true) {
                    descendants.push(child);
                }

                descendants = descendants.concat(subDescendants);

                if (isParentFirst !== true) {
                    descendants.push(child);
                }

            }

            return descendants;

        },

        /**
         * @deprecated Since v2.2.0 - please use findDescendantModels instead
         */
        findDescendants: function (descendants) {
            Adapt.log.warn("DEPRECATED - Use findDescendantModels() as findDescendants() may be removed in the future");

            // first check if descendant is child and return child
            if (this._children === descendants) {
                return this.getChildren();
            }

            var allDescendants = [];
            var flattenedDescendants;
            var children = this.getChildren();
            var returnedDescendants;

            function searchChildren(children) {
                var models = children.models;
                for (var i = 0, len = models.length; i < len; i++) {
                    var model = models[i];
                    var childrensModels = model.getChildren().models;
                    allDescendants.push(childrensModels);
                    flattenedDescendants = _.flatten(allDescendants);
                }

                returnedDescendants = new Backbone.Collection(flattenedDescendants);

                if (children.models.length === 0 || children.models[0]._children === descendants) {
                    return;
                } else {
                    allDescendants = [];
                    searchChildren(returnedDescendants);
                }
            }

            searchChildren(children);

            // returns a collection of children
            return returnedDescendants;
        },

        /**
         * Returns a relative model from the Adapt hierarchy
         *
         * Such that in the tree:
         *  { a1: { b1: [ c1, c2 ], b2: [ c3, c4 ] }, a2: { b3: [ c5, c6 ] } }
         *
         *  c1.findRelativeModel("@block +1") = b2;
         *  c1.findRelativeModel("@component +4") = c5;
         *
         * @see Adapt.parseRelativeString for a description of relativeStrings
         * @param {string} relativeString
         * @param {object} options Search configuration settings
         * @param {boolean} options.limitParentId
         * @param {function} options.filter
         * @param {boolean} options.loop
         * @return {array}
         */
        findRelativeModel: function(relativeString, options) {

            var types = [ "menu", "page", "article", "block", "component" ];

            options = options || {};

            var modelId = this.get("_id");
            var modelType = this.get("_type");

            // return a model relative to the specified one if opinionated
            var rootModel = Adapt.course;
            if (options.limitParentId) {
                rootModel = Adapt.findById(options.limitParentId);
            }

            var relativeDescriptor = Adapt.parseRelativeString(relativeString);

            var findAncestorType = (_.indexOf(types, modelType) > _.indexOf(types, relativeDescriptor.type));
            var findSiblingType = (modelType === relativeDescriptor.type);

            var searchBackwards = (relativeDescriptor.offset < 0);
            var moveBy = Math.abs(relativeDescriptor.offset);
            var movementCount = 0;

            var findDescendantType = (!findSiblingType && !findAncestorType);

            var pageDescendants;
            if (searchBackwards) {
                // parents first [p1,a1,b1,c1,c2,a2,b2,c3,c4,p2,a3,b3,c6,c7,a4,b4,c8,c9]
                pageDescendants = rootModel.getAllDescendantModels(true);

                // reverse so that we don't need a forward and a backward iterating loop
                // reversed [c9,c8,b4,a4,c7,c6,b3,a3,p2,c4,c3,b2,a2,c2,c1,b1,a1,p1]
                pageDescendants.reverse();

                if (findDescendantType) {
                    // move by one less as ordering allows
                    moveBy-=1;
                }

            } else if (findDescendantType) {
                // parents first [p1,a1,b1,c1,c2,a2,b2,c3,c4,p2,a3,b3,c6,c7,a4,b4,c8,c9]
                pageDescendants = rootModel.getAllDescendantModels(true);
            } else if (findSiblingType || findAncestorType) {
                // children first [c1,c2,b1,a1,c3,c4,b2,a2,p1,c6,c7,b3,a3,c8,c9,b4,a4,p2]
                pageDescendants = rootModel.getAllDescendantModels(false);
            }

            // filter if opinionated
            if (typeof options.filter === "function") {
                pageDescendants = _.filter(pageDescendants, options.filter);
            }

            // find current index in array
            var modelIndex = _.findIndex(pageDescendants, function(pageDescendant) {
                if (pageDescendant.get("_id") === modelId) {
                    return true;
                }
                return false;
            });

            if (options.loop) {

                // normalize offset position to allow for overflow looping
                var typeCounts = {};
                pageDescendants.forEach(function(model) {
                    var type = model.get("_type");
                    typeCounts[type] = typeCounts[type] || 0;
                    typeCounts[type]++;
                });
                moveBy = moveBy % typeCounts[relativeDescriptor.type];

                // double up entries to allow for overflow looping
                pageDescendants = pageDescendants.concat(pageDescendants.slice(0));

            }

            for (var i = modelIndex, l = pageDescendants.length; i < l; i++) {
                var descendant = pageDescendants[i];
                if (descendant.get("_type") === relativeDescriptor.type) {
                    if (movementCount === moveBy) {
                        return Adapt.findById(descendant.get("_id"));
                    }
                    movementCount++;
                }
            }

            return undefined;
        },

        getChildren: function () {
            if (this.get("_children")) return this.get("_children");

            var childrenCollection;

            if (!this._children) {
                childrenCollection = new Backbone.Collection();
            } else {
                var children = Adapt[this._children].where({_parentId: this.get("_id")});
                childrenCollection = new Backbone.Collection(children);
            }

            if (this.get('_type') == 'block' &&
                childrenCollection.length == 2 &&
                childrenCollection.models[0].get('_layout') !== 'left' &&
                this.get('_sortComponents') !== false) {
                // Components may have a 'left' or 'right' _layout,
                // so ensure they appear in the correct order
                // Re-order component models to correct it
                childrenCollection.comparator = '_layout';
                childrenCollection.sort();
            }

            this.set("_children", childrenCollection);

            return childrenCollection;
        },

        getAvailableChildModels: function() {
            return this.getChildren().where({
                _isAvailable: true
            });
        },

        /**
         * @deprecated since v2.2.0 please use getAvailableChildModels instead
         */
        getAvailableChildren: function() {
            Adapt.log.warn("DEPRECATED - Use getAvailableChildModels() as getAvailableChildren() may be removed in the future");

            return new Backbone.Collection(this.getChildren().where({
                _isAvailable: true
            }));
        },

        getParent: function () {
            if (this.get("_parent")) return this.get("_parent");
            if (this._parent === "course") {
                return Adapt.course;
            }
            var parent = Adapt.findById(this.get("_parentId"));
            this.set("_parent", parent);

            // returns a parent model
            return parent;
        },

        getAncestorModels: function(shouldIncludeChild) {
            var parents = [];
            var context = this;

            if (shouldIncludeChild) parents.push(context);

            while (context.has("_parentId")) {
                context = context.getParent();
                parents.push(context);
            }

            return parents.length ? parents : null;
        },

        /**
         * @deprecated since v2.2.0 please use getAncestorModels instead
         */
        getParents: function(shouldIncludeChild) {
            Adapt.log.warn("DEPRECATED - Use getAncestorModels() as getParents() may be removed in the future");

            var parents = [];
            var context = this;

            if (shouldIncludeChild) parents.push(context);

            while (context.has("_parentId")) {
                context = context.getParent();
                parents.push(context);
            }

            return parents.length ? new Backbone.Collection(parents) : null;
        },

        getSiblings: function (passSiblingsAndIncludeSelf) {
            var siblings;
            if (!passSiblingsAndIncludeSelf) {
                // returns a collection of siblings excluding self
                if (this._hasSiblingsAndSelf === false) {
                    return this.get("_siblings");
                }
                siblings = _.reject(Adapt[this._siblings].where({
                    _parentId: this.get('_parentId')
                }), function (model) {
                    return model.get('_id') == this.get('_id');
                }.bind(this));

                this._hasSiblingsAndSelf = false;

            } else {
                // returns a collection of siblings including self
                if (this._hasSiblingsAndSelf) {
                    return this.get("_siblings");
                }

                siblings = Adapt[this._siblings].where({
                    _parentId: this.get("_parentId")
                });
                this._hasSiblingsAndSelf = true;
            }

            var siblingsCollection = new Backbone.Collection(siblings);
            this.set("_siblings", siblingsCollection);
            return siblingsCollection;
        },

        setOnChildren: function (key, value, options) {

            var args = arguments;

            this.set.apply(this, args);

            if (!this._children) return;

            var children = this.getChildren();
            var models = children.models;
            for (var i = 0, len = models.length; i < len; i++) {
                var child = models[i];
                child.setOnChildren.apply(child, args);
            }

        },

        /**
         * @deprecated since v3.2.3 - please use `model.set('_isOptional', value)` instead
         */
        setOptional: function(value) {
            this.set({_isOptional: value});
        },

        checkLocking: function() {
            var lockType = this.get("_lockType");

            if (!lockType) return;

            switch (lockType) {
                case "sequential":
                    this.setSequentialLocking();
                    break;
                case "unlockFirst":
                    this.setUnlockFirstLocking();
                    break;
                case "lockLast":
                    this.setLockLastLocking();
                    break;
                case "custom":
                    this.setCustomLocking();
                    break;
                default:
                    console.warn("AdaptModel.checkLocking: unknown _lockType \"" +
                        lockType + "\" found on " + this.get("_id"));
            }
        },

        setSequentialLocking: function() {
            var children = this.getAvailableChildModels();

            for (var i = 1, j = children.length; i < j; i++) {
                children[i].set("_isLocked", !children[i - 1].get("_isComplete"));
            }
        },

        setUnlockFirstLocking: function() {
            var children = this.getAvailableChildModels();
            var isFirstChildComplete = children[0].get("_isComplete");

            for (var i = 1, j = children.length; i < j; i++) {
                children[i].set("_isLocked", !isFirstChildComplete);
            }
        },

        setLockLastLocking: function() {
            var children = this.getAvailableChildModels();
            var lastIndex = children.length - 1;

            for (var i = lastIndex - 1; i >= 0; i--) {
                if (!children[i].get("_isComplete")) {
                    return children[lastIndex].set("_isLocked", true);
                }
            }

            children[lastIndex].set("_isLocked", false);
        },

        setCustomLocking: function() {
            var children = this.getAvailableChildModels();

            for (var i = 0, j = children.length; i < j; i++) {
                var child = children[i];

                child.set("_isLocked", this.shouldLock(child));
            }
        },

        shouldLock: function(child) {
            var lockedBy = child.get("_lockedBy");

            if (!lockedBy) return false;

            for (var i = lockedBy.length - 1; i >= 0; i--) {
                var id = lockedBy[i];

                try {
                    var model = Adapt.findById(id);

                    if (!model.get("_isAvailable")) continue;
                    if (!model.get("_isComplete")) return true;
                }
                catch (e) {
                    console.warn("AdaptModel.shouldLock: unknown _lockedBy ID \"" + id +
                        "\" found on " + child.get("_id"));
                }
            }

            return false;
        },

        onIsComplete: function() {
            this.checkCompletionStatus();

            this.checkLocking();
        }

    });

    return AdaptModel;

});

define('core/js/models/articleModel',[
    'core/js/models/adaptModel'
], function (AdaptModel) {

    var ArticleModel = AdaptModel.extend({
        _parent:'contentObjects',
    	_siblings:'articles',
        _children: 'blocks'
    });

    return ArticleModel;

});

define('core/js/models/blockModel',[
    'core/js/models/adaptModel'
], function (AdaptModel) {

    var BlockModel = AdaptModel.extend({
        _parent:'articles',
    	_siblings:'blocks',
        _children: 'components',

        defaults: function() {
            return _.extend({
                _sortComponents: true
            }, AdaptModel.prototype.defaults);
        }
    });

    return BlockModel;

});

define('core/js/models/configModel',[
    'core/js/adapt'
], function (Adapt) {

    var ConfigModel = Backbone.Model.extend({

        defaults: {
            screenSize: {
                small: 520,
                medium: 760,
                large: 1024
            },
            _forceRouteLocking: false,
            _canLoadData: true,
            _disableAnimation: false
        },

        initialize: function(attrs, options) {
            this.url = options.url;
            // Fetch data & if successful trigger event to enable plugins to stop course files loading
            // Then check if course files can load
            // 'configModel:loadCourseData' event starts the core content collections and models being fetched
            this.fetch({
                success: function() {
                    Adapt.trigger('offlineStorage:prepare');

                    Adapt.wait.queue(function() {

                        Adapt.trigger('configModel:dataLoaded');

                        if (this.get('_canLoadData')) {
                            Adapt.trigger('configModel:loadCourseData');
                        }

                        if (this.get('_defaultDirection') === 'rtl'){
                            // We're going to use rtl style
                            $('html').addClass('dir-rtl');
                        }

                        // Check if animations should be disabled
                        var disableAnimationArray = this.get('_disableAnimationFor');
                        if (disableAnimationArray && disableAnimationArray.length > 0) {
                            for (var i = 0; i < disableAnimationArray.length; i++) {
                                if ($("html").is(disableAnimationArray[i])) {
                                    this.set('_disableAnimation', true);
                                    console.log('Animation disabled.');
                                }
                            }
                        }
                    }.bind(this));
                }.bind(this),
                error: function() {
                    console.log('Unable to load course/config.json');
                }
            });
        },

        loadData: function() {

        }

    });

   return ConfigModel;

});

define('core/js/models/contentObjectModel',[
    'core/js/models/adaptModel'
], function (AdaptModel) {

    var ContentObjectModel = AdaptModel.extend({
    	_parent:'course',
    	_siblings:'contentObjects',
        _children: 'contentObjects'
    });

    return ContentObjectModel;
});

define('core/js/models/componentModel',[
    'core/js/models/adaptModel'
], function (AdaptModel) {

    var ComponentModel = AdaptModel.extend({
        _parent:'blocks',
        _siblings:'components',

        defaults: AdaptModel.resultExtend('defaults', {
            _isA11yComponentDescriptionEnabled: true
        }),

        trackable: AdaptModel.resultExtend("trackable", [
            '_userAnswer'
        ])

    });

    return ComponentModel;

});

define('core/js/models/courseModel',[
    'core/js/adapt',
    'core/js/models/adaptModel'
], function (Adapt, AdaptModel) {

    var CourseModel = AdaptModel.extend({

        initialize: function(attrs, options) {
            AdaptModel.prototype.initialize.apply(this, arguments);
            Adapt.trigger('courseModel:dataLoading');

            this.url = options.url;

            this.on('sync', this.loadedData, this);
            if (this.url) {
                this.fetch({
                    error: _.bind(function(model, xhr, options) {
                        console.error("ERROR: unable to load file " + this.url);
                    }, this)
                });
            }
        },

        loadedData: function() {
            Adapt.trigger('courseModel:dataLoaded');
        },

        _children: "contentObjects"

    });

    return CourseModel;

});

define('core/js/enums/buttonStateEnum',[],function() {

    var BUTTON_STATE = ENUM([
        'SUBMIT',
        'CORRECT',
        'INCORRECT',
        'SHOW_CORRECT_ANSWER',
        'HIDE_CORRECT_ANSWER',
        'SHOW_FEEDBACK',
        'RESET'
    ]);

    return BUTTON_STATE;

});
define('core/js/models/questionModel',[
    'core/js/adapt',
    'core/js/models/componentModel',
    'core/js/enums/buttonStateEnum'
], function(Adapt, ComponentModel, BUTTON_STATE) {

    var QuestionModel = ComponentModel.extend({

        //////
        // Setup question types
        ////

        // Used to set model defaults
        defaults: function() {
            // Extend from the ComponentModel defaults
            return ComponentModel.resultExtend("defaults", {
                _isQuestionType: true,
                _shouldDisplayAttempts: false,
                _canShowModelAnswer: true,
                _canShowFeedback: true,
                _canShowMarking: true,
                _isSubmitted: false,
                _questionWeight: Adapt.config.get("_questionWeight"),
            });
        },

        // Extend from the ComponentModel trackable
        trackable: ComponentModel.resultExtend("trackable", [
            '_isSubmitted',
            '_score',
            '_isCorrect',
            '_attemptsLeft'
        ]),

        init: function() {
            this.setupDefaultSettings();
            this.listenToOnce(Adapt, "adapt:initialize", this.onAdaptInitialize);
        },

        // Calls default methods to setup on questions
        setupDefaultSettings: function() {
            // Not sure this is needed anymore, keeping to maintain API
            this.setupWeightSettings();
            this.setupButtonSettings();
        },

        // Used to setup either global or local button text
        setupButtonSettings: function() {
            var globalButtons = Adapt.course.get("_buttons");

            // Check if  '_buttons' attribute exists and if not use the globally defined buttons.
            if (!this.has("_buttons")) {
                this.set("_buttons", globalButtons);
            } else {
                // Check all the components buttons.
                // If they are empty use the global defaults.
                var componentButtons = this.get("_buttons");

                for (var key in componentButtons) {
                    if (typeof componentButtons[key] === 'object') {
                        // Button text.
                        if (!componentButtons[key].buttonText && globalButtons[key].buttonText) {
                            componentButtons[key].buttonText = globalButtons[key].buttonText;
                        }

                        // ARIA labels.
                        if (!componentButtons[key].ariaLabel && globalButtons[key].ariaLabel) {
                            componentButtons[key].ariaLabel = globalButtons[key].ariaLabel;
                        }
                    }

                    if (!componentButtons[key] && globalButtons[key]) {
                        componentButtons[key] = globalButtons[key];
                    }
                }
            }
        },

        // Used to setup either global or local question weight/score
        setupWeightSettings: function() {
            // Not needed as handled by model defaults, keeping to maintain API
        },

        //////
        // Selection restoration process
        ////


        // Used to add post-load changes to the model
        onAdaptInitialize: function() {
            this.restoreUserAnswers();
        },

        // Used to restore the user answers
        restoreUserAnswers: function() {},


        //////
        // Submit process
        ////

        // Use to check if the user is allowed to submit the question
        // Maybe the user has to select an item?
        canSubmit: function() {},

        // Used to update the amount of attempts the user has left
        updateAttempts: function() {
            if (!this.get('_attemptsLeft')) {
                this.set("_attemptsLeft", this.get('_attempts'));
            }
            this.set("_attemptsLeft", this.get('_attemptsLeft') - 1);
        },

        // Used to set _isEnabled and _isSubmitted on the model
        setQuestionAsSubmitted: function() {
            this.set({
                _isEnabled: false,
                _isSubmitted: true
            });
        },

        // This is important for returning or showing the users answer
        // This should preserve the state of the users answers
        storeUserAnswer: function() {},

        // Sets _isCorrect:true/false based upon isCorrect method below
        markQuestion: function() {

            if (this.isCorrect()) {
                this.set('_isCorrect', true);
            } else {
                this.set('_isCorrect', false);
            }

        },

         // Should return a boolean based upon whether to question is correct or not
        isCorrect: function() {},

        // Used to set the score based upon the _questionWeight
        setScore: function() {},

        // Checks if the question should be set to complete
        // Calls setCompletionStatus and adds complete classes
        checkQuestionCompletion: function() {

            var isComplete = (this.get('_isCorrect') || this.get('_attemptsLeft') === 0);

            if (isComplete) {
                this.setCompletionStatus();
            }

            return isComplete;

        },

        // Updates buttons based upon question state by setting
        // _buttonState on the model which buttonsView listens to
        updateButtons: function() {

            var isInteractionComplete = this.get('_isInteractionComplete');
            var isCorrect = this.get('_isCorrect');
            var isEnabled = this.get('_isEnabled');
            var buttonState = this.get('_buttonState');
            var canShowModelAnswer = this.get('_canShowModelAnswer');

            if (isInteractionComplete) {

                if (isCorrect || !canShowModelAnswer) {
                    // Use correct instead of complete to signify button state
                    this.set('_buttonState', BUTTON_STATE.CORRECT);

                } else {

                    switch (buttonState) {
                        case BUTTON_STATE.SUBMIT:
                        case BUTTON_STATE.HIDE_CORRECT_ANSWER:
                            this.set('_buttonState', BUTTON_STATE.SHOW_CORRECT_ANSWER);
                            break;
                        default:
                            this.set('_buttonState', BUTTON_STATE.HIDE_CORRECT_ANSWER);
                    }

                }

            } else {

                if (isEnabled) {
                    this.set('_buttonState', BUTTON_STATE.SUBMIT);
                } else {
                    this.set('_buttonState', BUTTON_STATE.RESET);
                }
            }

        },

        // Used to setup the correct, incorrect and partly correct feedback
        setupFeedback: function() {
            if (!this.has('_feedback')) return;

            if (this.get('_isCorrect')) {
                this.setupCorrectFeedback();
            } else if (this.isPartlyCorrect()) {
                this.setupPartlyCorrectFeedback();
            } else {
                this.setupIncorrectFeedback();
            }
        },

        // Used by the question to determine if the question is incorrect or partly correct
        // Should return a boolean
        isPartlyCorrect: function() {},

        setupCorrectFeedback: function() {
            this.set({
                feedbackTitle: this.getFeedbackTitle(),
                feedbackMessage: this.get('_feedback').correct
            });
        },

        setupPartlyCorrectFeedback: function() {
            var feedback = this.get('_feedback')._partlyCorrect;

            if (feedback && feedback.final) {
                this.setAttemptSpecificFeedback(feedback);
            } else {
                this.setupIncorrectFeedback();
            }
        },

        setupIncorrectFeedback: function() {
            this.setAttemptSpecificFeedback(this.get('_feedback')._incorrect);
        },

        setAttemptSpecificFeedback: function(feedback) {
            var body = this.get('_attemptsLeft') && feedback.notFinal || feedback.final;

            this.set({
                feedbackTitle: this.getFeedbackTitle(),
                feedbackMessage: body
            });
        },

        getFeedbackTitle: function() {
            return this.get('_feedback').title || this.get('displayTitle') ||  this.get('title') || "";
        },

        /**
         * Used to determine whether the learner is allowed to interact with the question component or not.
         * @return {Boolean}
         */
        isInteractive: function() {
            return !this.get('_isComplete') || (this.get('_isEnabled') && !this.get('_isSubmitted'));
        },

        // Reset the model to let the user have another go (not the same as attempts)
        reset: function(type, force) {
            if (!this.get("_canReset") && !force) return;

            type = type || true; //hard reset by default, can be "soft", "hard"/true

            ComponentModel.prototype.reset.call(this, type, force);

            var attempts = this.get('_attempts');
            this.set({
                _attemptsLeft: attempts,
                _isCorrect: undefined,
                _isSubmitted: false,
                _buttonState: BUTTON_STATE.SUBMIT
            });
        },

        // Reset question for subsequent attempts
        setQuestionAsReset: function() {
            this.set({
                _isEnabled: true,
                _isSubmitted: false
            });
        },

        // Used by the question view to reset the stored user answer
        resetUserAnswer: function() {},

        refresh: function() {
            this.trigger('question:refresh');
        },

        getButtonState: function() {
            if (this.get('_isCorrect')) {
                return BUTTON_STATE.CORRECT;
            }

            if (this.get('_attemptsLeft') === 0) {
                 return this.get('_canShowModelAnswer') ? BUTTON_STATE.SHOW_CORRECT_ANSWER : BUTTON_STATE.INCORRECT;
            }

            return this.get('_isSubmitted') ? BUTTON_STATE.RESET : BUTTON_STATE.SUBMIT;
        },

        // Returns an object specific to the question type, e.g. if the question
        // is a 'choice' this should contain an object with:
        // - correctResponsesPattern[]
        // - choices[]
        getInteractionObject: function() {
            return {};
        },

        // Returns a string detailing how the user answered the question.
        getResponse: function() {},

        // Returns a string describing the type of interaction: "choice" and "matching" supported (see scorm wrapper)
        getResponseType: function() {}

    });

    return QuestionModel;

});

define('core/js/views/navigationView',[
    'core/js/adapt'
], function(Adapt) {

    var NavigationView = Backbone.View.extend({

        className: "navigation",

        initialize: function() {
            this.listenToOnce(Adapt, {
                'courseModel:dataLoading': this.remove
            });
            this.listenTo(Adapt, 'router:menu router:page', this.hideNavigationButton);
            this.template = "navigation";
            this.preRender();
        },

        events: {
            'click [data-event]':'triggerEvent'
        },

        attributes: {
            'role': 'navigation'
        },

        preRender: function() {
            Adapt.trigger('navigationView:preRender', this);
            this.render();
        },

        render: function() {
            var template = Handlebars.templates[this.template];
            this.$el.html(template(
                {
                    _globals: Adapt.course.get("_globals"),
                    _accessibility: Adapt.config.get("_accessibility")
                }
            )).insertBefore('#app');

            _.defer(_.bind(function() {
                Adapt.trigger('navigationView:postRender', this);
            }, this));

            return this;
        },

        triggerEvent: function(event) {
            event.preventDefault();
            var currentEvent = $(event.currentTarget).attr('data-event');
            Adapt.trigger('navigation:' + currentEvent);
        },

        hideNavigationButton: function(model) {
            if (model.get('_type') === "course") {
                $('.navigation-back-button, .navigation-home-button').addClass('display-none');
            } else {
                this.showNavigationButton();
            }
        },

        showNavigationButton: function() {
            $('.navigation-back-button, .navigation-home-button').removeClass('display-none');
        }

    });

    return NavigationView;

});

define('core/js/accessibility',[
    'core/js/adapt',
    'a11y'
], function(Adapt) {

    var defaultAriaLevels = {
        "_menu": 1,
        "_menuItem": 2,
        "_page": 1,
        "_article": 2,
        "_block": 3,
        "_component": 4,
        "_componentItem": 5
    };

    var Accessibility = Backbone.Controller.extend({

        $html: $('html'),

        initialize: function() {

            this.removeLegacyElements();

            this.listenToOnce(Adapt, {
                //TRIGGER SETUP ON DATA LOADED
                'app:dataLoaded': this.initialSetup,
                //Configure the accessibility library
                'app:dataReady': this.configureA11yLibrary,
                'navigationView:postRender': this.removeLegacyElements
            }, this);

            //SETUP NO SELECT PARAMETERS ON DEVICE CHANGE
            Adapt.on("device:changed", this.setupNoSelect);

            //CAPTURE ROUTING/NEW DOCUMENT LOADING START AND END
            this.listenTo(Adapt, {
                'router:location': this.onNavigationStart,
                'pageView:ready menuView:ready router:plugin': this.onNavigationEnd
            });
        },

        initialSetup: function() {

            Adapt.config.get("_accessibility")._isActive = false;
            this.setupAccessibility();

            //SETUP RENDERING HELPERS
            this.setupHelpers();

        },

        removeLegacyElements: function() {
            var $legacyElements = $("body").children("#accessibility-toggle, #accessibility-instructions");
            var $navigationElements = $(".navigation").find("#accessibility-toggle, #accessibility-instructions");

            if (!$legacyElements.length && !$navigationElements.length) return

            Adapt.log.warn("REMOVED - #accessibility-toggle and #accessibility-instructions have been removed. Please remove them from all of your .html files.");
            $legacyElements.remove();
            $navigationElements.remove();
        },

        setupAccessibility: function() {
            //CALLED ON DATA LOAD
            if (!this.isEnabled()) return;

            //save accessibility state
            Adapt.offlineStorage.set("a11y", false);

            this.configureA11yLibrary();
            this.setupDocument();
            this.setupPopupListeners();
            this.setupLogging();

        },

        setupHelpers: function() {

            //MAKE $.a11y_text and $.a11y_normalize IN GLOBAL HANDLEBARS HELPERS a11y_text and a11y_normalize
            var config = Adapt.config.has('_accessibility')
                ? Adapt.config.get("_accessibility")
                : false;

            var helpers = {

                a11y_text: function(text) {
                    Adapt.log.warn("DEPRECATED: a11y_text is no longer required. https://tink.uk/understanding-screen-reader-interaction-modes/");
                    return text;
                },

                a11y_normalize: function(texts) {
                    var values = Array.prototype.slice.call(arguments, 0,-1);
                    values = values.filter(Boolean);
                    return $.a11y_normalize(values.join(" "));
                },

                a11y_remove_breaks: function(texts) {
                    var values = Array.prototype.slice.call(arguments, 0,-1);
                    values = values.filter(Boolean);
                    return $.a11y_remove_breaks(values.join(" "));
                },

                a11y_aria_label: function(texts) {
                    var values = Array.prototype.slice.call(arguments, 0,-1);
                    values = values.filter(Boolean);
                    return new Handlebars.SafeString('<div class="aria-label">'+values.join(" ")+'</div>');
                },

                a11y_aria_label_relative: function(texts) {
                    var values = Array.prototype.slice.call(arguments, 0,-1);
                    values = values.filter(Boolean);
                    return new Handlebars.SafeString('<div class="aria-label relative">'+values.join(" ")+'</div>');
                },

                a11y_aria_image: function(texts) {
                    var values = Array.prototype.slice.call(arguments, 0,-1);
                    values = values.filter(Boolean);
                    return new Handlebars.SafeString('<div class="aria-label" role="img" aria-label="'+values.join(" ")+'"></div>');
                },

                a11y_wrap_focus: function(text) {
                    return new Handlebars.SafeString('<a class="a11y-focusguard a11y-ignore a11y-ignore-focus" role="presentation">&nbsp;</a>');
                },

                a11y_attrs_heading: function(levelOrType) {
                    // get the global configuration from config.json
                    var cfg = Adapt.config.get('_accessibility');
                    // default level to use if nothing overrides it
                    var level = 1;

                    // first check to see if the Handlebars context has an override
                    if (this._ariaLevel) {
                        levelOrType = this._ariaLevel;
                    }

                    if (isNaN(levelOrType) === false) {
                        // if a number is passed just use this
                        level = levelOrType;
                    }
                    else if (_.isString(levelOrType)) {
                        // if a string is passed check if it is defined in global configuration
                        cfg._ariaLevels = cfg._ariaLevels || defaultAriaLevels;
                        if (cfg._ariaLevels && cfg._ariaLevels["_"+levelOrType] !== undefined) {
                            level = cfg._ariaLevels["_"+levelOrType];
                        }
                    }

                    return new Handlebars.SafeString(' role="heading" aria-level="'+level+'" ');
                },

                a11y_attrs_tabbable: function() {
                    return new Handlebars.SafeString(' role="region" tabindex="0" ');
                }

            };

            for (var name in helpers) {
                if (helpers.hasOwnProperty(name)) {
                     Handlebars.registerHelper(name, helpers[name]);
                }
            }

        },

        setupNoSelect: function() {
            if (!Adapt.config.get('_accessibility') || !Adapt.config.get('_accessibility')._disableTextSelectOnClasses) return;

            var classes = Adapt.config.get('_accessibility')._disableTextSelectOnClasses.split(" ");

            var isMatch = false;
            for (var i = 0, item; item = classes[i++];) {
                if ($('html').is(item)) {
                    isMatch = true;
                    break;
                }
            }

            if (isMatch) {
                $('html').addClass("no-select");
            } else  {
                $('html').removeClass("no-select");
            }

        },

        configureA11yLibrary: function() {

            $.a11y.options.OS = Adapt.device.OS.toLowerCase();
            $.a11y.options.isTouchDevice = Adapt.device.touch;

            _.extend($.a11y.options, {
                isUserInputControlEnabled: true,
                isFocusControlEnabled: true,
                isRemoveNotAccessiblesEnabled: true,
                isScrollDisableEnabled: true,
                isScrollDisabledOnPopupEnabled: false
            });

            this.setupNoSelect();

            $.a11y.ready();
        },

        onNavigationStart: function() {
            //STOP DOCUMENT READING, MOVE FOCUS TO APPROPRIATE LOCATION
            _.defer(function() {
                $.a11y_on(false, '.page');
                $.a11y_on(false, '.menu');
            });
        },

        onNavigationEnd: function(view) {
            //prevent sub-menu items provoking behaviour
            if (view && view.model) {
                if (view.model.get("_id") != Adapt.location._currentId) return;
            }

            $.a11y_on(true, '.page');
            $.a11y_on(true, '.menu');

            this.configureA11yLibrary();
            $.a11y_update();

        },

        isActive: function() {
            Adapt.log.warn("REMOVED - accessibility is now always active when enabled. Please unify your user experiences.")
            return false;
        },

        isEnabled: function() {
            return Adapt.config.has('_accessibility')
                && Adapt.config.get('_accessibility')._isEnabled;
        },

        setupDocument: function() {
            this.$html.addClass('accessibility');
            $.a11y(true)
        },

        setupPopupListeners: function() {
            this.listenTo(Adapt, 'popup:opened popup:closed', this.onPop);
        },

        setupLogging: function() {
            if (!Adapt.config.get("_accessibility") || !Adapt.config.get("_accessibility")._logReading) return;
            $(document).on("reading", this.onRead);
        },

        onRead: function(event, text) {
            //OUTPUT READ TEXT TO CONSOLE
            console.log("READING: " + text);
        },

        onPop: function() {
            //MAKE SURE POPUP IS CONFIGURED CORRECTLY WITH ARIA LABELS, TABINDEXES ETC
            $.a11y_update();
        }

    });

    Adapt.accessibility = new Accessibility();

    return Adapt.accessibility;

});

define('core/js/offlineStorage',[
    'core/js/adapt'
], function(Adapt) {

    //Basic API for setting and getting name+value pairs
    //Allows registration of a single handler.

    var OfflineStorage = Backbone.Controller.extend({

        /**
         * set to true initially so that if there are no offlineStorage handlers (i.e. if contrib-spoor is not installed)
         * this can still be accessed OK
         */
        ready: true,
        _handler: undefined,

        /**
         * set .ready to false if an offlineStorage handler is being attached - we'll need to wait until the handler lets us know
         * it's ready before we can safely use offlineStorage
         */
        initialize: function(handler) {
            if (!handler) {
                return;
            }

            this.ready = false;
            this._handler = handler;
        },

        /**
         * Flag to indicate if an offlineStorage handler has been defined.
         * @returns {boolean} true if an offlineStorage handler has been defined, false otherwise
         */
        hasHandler: function() {
            return this._handler !== undefined;
        },

        set: function(name, value) {
            if (this._handler && this._handler.set) {
                return this._handler.set.apply(this._handler, arguments);
            }
            // if no handler has been defined, just store the data locally
            this[name] = value;
        },

        get: function(name) {
            if (this._handler && this._handler.get) {
                return this._handler.get.apply(this._handler, arguments);
            }
            // if no handler has been defined, check local data store
            return this[name];
        },

        /**
         * Some forms of offlineStorage could take time to initialise, this allows us to let plugins know when it's ready to be used
         */
        setReadyStatus: function() {
            this.ready = true;
            Adapt.trigger("offlineStorage:ready");
        }

    });

    Adapt.offlineStorage = new OfflineStorage();

    return Adapt.offlineStorage;

});

define('core/js/enums/completionStateEnum',[],function() {
  
      var COMPLETION_STATE = ENUM([
          'INCOMPLETE',
          'COMPLETED',
          'PASSED',
          'FAILED'
      ]);
  
      return COMPLETION_STATE;
  
  });
define('core/js/tracking',[
    'core/js/adapt',
    'core/js/enums/completionStateEnum'
], function(Adapt, COMPLETION_STATE) {

    var Tracking = Backbone.Controller.extend({

        _config: {
            _requireContentCompleted: true,
            _requireAssessmentCompleted: false
        },

        _assessmentState: null,

        initialize: function() {
            Adapt.once('configModel:loadCourseData', this.loadConfig.bind(this));
            Adapt.on('app:dataReady', this.setupEventListeners.bind(this));
        },

        setupEventListeners: function() {
            // Check if completion requires passing an assessment. 
            if (this._config._requireAssessmentCompleted) {
                this.listenTo(Adapt, 'assessment:complete', this.onAssessmentComplete);
            }

            // Check if completion requires completing all content.
            if (this._config._requireContentCompleted) {
                this.listenTo(Adapt.course, 'change:_isComplete', this.checkCompletion);
            }
        },

        /**
         * Store the assessment state.
         * @param {object} assessmentState - The object returned by Adapt.assessment.getState()
         */
        onAssessmentComplete: function(assessmentState) {
            this._assessmentState = assessmentState;

            this.checkCompletion();
        },

        /**
         * Evaluate the course and assessment completion.
         */
        checkCompletion: function() {
            var completionData = this.getCompletionData();

            if (completionData.status === COMPLETION_STATE.INCOMPLETE) {
                return;
            }

            Adapt.trigger('tracking:complete', completionData);
            Adapt.log.debug('tracking:complete', completionData);
        },

        /**
         * The return value of this function should be passed to the trigger of 'tracking:complete'.
         * @returns An object representing the user's course completion.
         */
        getCompletionData: function() {
            var completionData = {
                status: COMPLETION_STATE.INCOMPLETE,
                assessment: null
            };

            // Course complete is required.
            if (this._config._requireContentCompleted && !Adapt.course.get('_isComplete')) {
                // INCOMPLETE: course not complete.
                return completionData;
            }

            // Assessment completed required.
            if (this._config._requireAssessmentCompleted) {
                if (!this._assessmentState) {
                    // INCOMPLETE: assessment is not complete.
                    return completionData;
                }

                // PASSED/FAILED: assessment completed.
                completionData.status = this._assessmentState.isPass ? COMPLETION_STATE.PASSED : COMPLETION_STATE.FAILED;
                completionData.assessment = this._assessmentState;

                return completionData;
            }

            // COMPLETED: criteria met, no assessment requirements.
            completionData.status = COMPLETION_STATE.COMPLETED;

            return completionData;
        },

        /**
         * Set the _config object to the values retrieved from config.json.
         */
        loadConfig: function() {
            if (Adapt.config.has('_completionCriteria')) {
                this._config = Adapt.config.get('_completionCriteria');
            }
        }

    });

    Adapt.tracking = new Tracking();

    return Adapt.tracking;
});

define('core/js/device',[
    'core/js/adapt',
    'bowser'
], function(Adapt, Bowser) {

    var $html = $('html');
    var $window = $(window);

    Adapt.device = {
        touch: Modernizr.touchevents,
        screenWidth: getScreenWidth(),
        screenHeight: getScreenHeight(),
        browser: (Bowser.name || '').toLowerCase(),
        version: (Bowser.version || '').toLowerCase(),
        OS: getOperatingSystem().toLowerCase(),
        osVersion: Bowser.osversion || '',
        renderingEngine: getRenderingEngine()
    };

    // Define 'orientation' and 'aspectRatio' here once 'screenWidth' and 'screenHeight' have been set,
    // as both these functions are getters, essentially.
    Object.defineProperties(Adapt.device, {
        "orientation": {
            get: function () {
                return (this.screenWidth >= this.screenHeight) ? 'landscape' : 'portrait';
            }
        },
        "aspectRatio": {
            get: function () {
                return this.screenWidth / this.screenHeight;
            }
        }
    });

    Adapt.once('app:dataReady', function() {
        Adapt.device.screenSize = checkScreenSize();

        $html.addClass('size-' + Adapt.device.screenSize);
        
        if (Adapt.device.orientation) {
            $html.addClass('orientation-' + Adapt.device.orientation);
        }

        // As Adapt.config is available it's ok to bind the 'resize'.
        $window.on('resize orientationchange', onWindowResize);
    });

    /**
     * Compares the calculated screen width to the breakpoints defined in config.json.
     * 
     * @returns {string} 'large', 'medium' or 'small'
     */
    function checkScreenSize() {
        var screenSizeConfig = Adapt.config.get('screenSize');
        var screenSize;

        if (Adapt.device.screenWidth > screenSizeConfig.medium) {
            screenSize = 'large';
        } else if (Adapt.device.screenWidth > screenSizeConfig.small) {
            screenSize = 'medium';
        } else {
            screenSize = 'small';
        }

        return screenSize;
    }

    function getScreenWidth() {
        return isAppleDevice()
            ? getAppleScreenWidth()
            : window.innerWidth || $window.width();
    }

    function getScreenHeight() {
        return isAppleDevice()
            ? getAppleScreenHeight()
            : window.innerHeight || $window.height();
    }

    function getOperatingSystem() {
        var os = '';
        var flags = ['windows', 'mac', 'linux', 'windowsphone', 'chromeos', 'android',
            'ios', 'blackberry', 'firefoxos', 'webos', 'bada', 'tizen', 'sailfish'];

        for (var i = 0; i < flags.length; i++) {
            if (Bowser[flags[i]]) {
                os = flags[i];
                break;
            }
        }

        if (os === '') {
            // Fall back to using navigator.platform in case Bowser can't detect the OS.
            var platform = navigator.platform;
            var platforms = ['Win', 'Mac', 'Linux'];
            os = 'PlatformUnknown';

            for (var i = 0; i < platforms.length; i++) {
                if (platform.indexOf(platforms[i]) != -1) {
                    os = platforms[i].toLowerCase();
                    break;
                }
            }

            // Set consistency with the Bowser flags.
            if (os == 'win') {
                os = 'windows';
            }
        }

        return os;
    }

    function getRenderingEngine() {
        var engine = '';
        var flags = ['webkit', 'blink', 'gecko', 'msie', 'msedge'];

        for (var i = 0; i < flags.length; i++) {
            if (Bowser[flags[i]]) {
                engine = flags[i];
                break;
            }
        }

        return engine;
    }

    var onWindowResize = _.debounce(function onScreenSizeChanged() {
        // Calculate the screen properties.
        var previousWidth = Adapt.device.screenWidth;
        var previousHeight = Adapt.device.screenHeight;

        Adapt.device.screenWidth = getScreenWidth();
        Adapt.device.screenHeight = getScreenHeight();

        if (previousWidth === Adapt.device.screenWidth && previousHeight === Adapt.device.screenHeight) {
            // Do not trigger a change if the viewport hasn't actually changed.  Scrolling on iOS will trigger a resize.
            return;
        }

        var newScreenSize = checkScreenSize();

        if (newScreenSize !== Adapt.device.screenSize) {
            Adapt.device.screenSize = newScreenSize;

            $html.removeClass('size-small size-medium size-large').addClass('size-' + Adapt.device.screenSize);

            if (Adapt.device.orientation) {
                $html.removeClass('orientation-landscape orientation-portrait').addClass('orientation-' + Adapt.device.orientation);
            }

            Adapt.trigger('device:changed', Adapt.device.screenSize);
        }

        Adapt.trigger('device:preResize device:resize device:postResize', Adapt.device.screenWidth);

    }, 100);

    function isAppleDevice() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    }

    function getAppleScreenWidth() {
        return (Math.abs(window.orientation) === 90) ? screen.height : screen.width;
    }

    function getAppleScreenHeight() {
        return (Math.abs(window.orientation) === 90) ? screen.width : screen.height;
    }

    function getAppleDeviceType() {
        var type = '';

        var flags = ['iphone', 'ipad', 'ipod'];

        for (var i = 0; i < flags.length; i++) {
            if (Bowser[flags[i]]) {
                type = flags[i];
                break;
            }
        }

        return type;
    }

    function pixelDensity() {
        var pixelDensity = (window.devicePixelRatio || 1);

        if (pixelDensity >= 3) {
            return 'ultra-high';
        } else if (pixelDensity >= 2) {
            return 'high';
        } else if (pixelDensity >= 1.5) {
            return 'medium';
        } else {
            return 'low';
        }
    }

    var browser = Adapt.device.browser.toLowerCase();
    // Convert 'msie' and 'internet explorer' to 'ie'.
    var browserString = browser.replace(/msie|internet explorer/, 'ie');
    browserString = browserString + ' version-' + Adapt.device.version + ' OS-' + Adapt.device.OS + ' ' + getAppleDeviceType();
    browserString += browserString.replace('.', '-').toLowerCase();

    $html.addClass(browserString + ' pixel-density-' + pixelDensity());
});

define('core/js/views/drawerView',[
    'core/js/adapt'
], function(Adapt) {

    var DrawerView = Backbone.View.extend({

        className: 'drawer display-none',
        disableAnimation: false,

        attributes: {
            'role': 'dialog',
            'aria-modal': 'true',
            'aria-labelledby': 'drawer-heading',
            'aria-hidden': 'true'
        },

        initialize: function() {
            this.disableAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;
            this._isVisible = false;
            this.drawerDir = 'right';
            if(Adapt.config.get('_defaultDirection')=='rtl'){//on RTL drawer on the left
                this.drawerDir = 'left';
            }
            this.setupEventListeners();
            this.render();
            this.drawerDuration = Adapt.config.get('_drawer')._duration;
            this.drawerDuration = (this.drawerDuration) ? this.drawerDuration : 400;
            // Setup cached selectors
            this.$wrapper = $('#wrapper');
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                'navigation:toggleDrawer': this.toggleDrawer,
                'drawer:triggerCustomView': this.openCustomView,
                'drawer:closeDrawer': this.onCloseDrawer,
                'remove': this.onCloseDrawer,
                'drawer:remove': this.remove
            });

            this._onKeyUp = _.bind(this.onKeyUp, this);
            this.setupEscapeKey();
        },

        setupEscapeKey: function() {
            $(window).on("keyup", this._onKeyUp);
        },

        onKeyUp: function(event) {
            if (event.which != 27) return;
            event.preventDefault();

            this.onCloseDrawer();
        },

        events: {
            'click .drawer-back': 'onBackButtonClicked',
            'click .drawer-close':'onCloseClicked'
        },

        render: function() {
            var template = Handlebars.templates['drawer']
            $(this.el).html(template({_globals: Adapt.course.get("_globals")})).prependTo('body');
            var shadowTemplate = Handlebars.templates['shadow'];
            $(shadowTemplate()).prependTo('body');
            // Set defer on post render
            _.defer(_.bind(function() {
                this.postRender();
            }, this));
            return this;
        },

        // Set tabindex for select elements
        postRender: function() {
            this.$('a, button, input, select, textarea').attr('tabindex', -1);

            this.checkIfDrawerIsAvailable();
        },

        openCustomView: function(view, hasBackButton) {
            // Set whether back button should display
            this._hasBackButton = hasBackButton;
            this._isCustomViewVisible = true;
            Adapt.trigger('drawer:empty');
            this.showDrawer();
            this.$('.drawer-holder').html(view);
        },

        checkIfDrawerIsAvailable: function() {
            if (this.collection.length == 0) {
                $('.navigation-drawer-toggle-button').addClass('display-none');
                Adapt.trigger('drawer:noItems');
            } else {
                $('.navigation-drawer-toggle-button').removeClass('display-none');
            }
        },

        onBackButtonClicked: function(event) {
            event.preventDefault();
            this.showDrawer(true);
        },

        onCloseClicked: function(event) {
            event.preventDefault();
            this.hideDrawer();
        },

        onCloseDrawer: function($toElement) {
            this.hideDrawer($toElement);
        },

        toggleDrawer: function() {
            if (this._isVisible && this._isCustomViewVisible === false) {
                this.hideDrawer();
            } else {
                this.showDrawer(true);
            }
        },

        showDrawer: function(emptyDrawer) {
            this.$el.removeClass('display-none').removeAttr('aria-hidden');
            //only trigger popup:opened if drawer is visible, pass popup manager drawer element
            if (!this._isVisible) {
                Adapt.trigger('popup:opened', this.$el);
                $('body').scrollDisable();
                this._isVisible = true;
            }

            var drawerWidth = this.$el.width();
            // Sets tab index to 0 for all tabbable elements in Drawer
            this.$('a, button, input, select, textarea').attr('tabindex', 0);

            if (emptyDrawer) {
                this.$('.drawer-back').addClass('display-none');
                this._isCustomViewVisible = false;
                this.emptyDrawer();
                if (this.collection.models.length === 1) {
                    // This callback triggers openCustomView() and sets
                    // _isCustomViewVisible to true, causing toggleDrawer()
                    // to re-render the drawer on every toggle button press
                    Adapt.trigger(this.collection.models[0].get('eventCallback'));
                    // Set _isCustomViewVisible to false to prevent re-rendering
                    // the drawer and fix the toggle functionality on toggle button press
                    this._isCustomViewVisible = false;
                } else {
                    this.renderItems();
                    Adapt.trigger('drawer:openedItemView');
                }
            } else {
                if (this._hasBackButton && this.collection.models.length > 1) {
                    this.$('.drawer-back').removeClass('display-none');
                } else {
                    this.$('.drawer-back').addClass('display-none');
                }
                Adapt.trigger('drawer:openedCustomView');
            }

            //delay drawer animation until after background fadeout animation is complete
            if (this.disableAnimation) {
                $('#shadow').removeClass("display-none");

                var direction={};
                direction[this.drawerDir]=0;
                this.$el.css(direction);
                complete.call(this);

            } else {

                $('#shadow').velocity({opacity:1},{duration:this.drawerDuration, begin: _.bind(function() {
                    $("#shadow").removeClass("display-none");
                    complete.call(this);
                }, this)});

                var showEasingAnimation = Adapt.config.get('_drawer')._showEasing;
                var easing = (showEasingAnimation) ? showEasingAnimation : 'easeOutQuart';
                var direction={};
                direction[this.drawerDir]=0;
                this.$el.velocity(direction, this.drawerDuration, easing);

            }

            function complete() {
                this.addShadowEvent();
                Adapt.trigger('drawer:opened');

                //focus on first tabbable element in drawer
                this.$el.a11y_focus();
        }

        },

        emptyDrawer: function() {
            this.$('.drawer-holder').empty();
        },

        renderItems: function() {
            Adapt.trigger('drawer:empty');
            this.emptyDrawer();
            var models = this.collection.models;
            for (var i = 0, len = models.length; i < len; i++) {
                var item = models[i];
                new DrawerItemView({model: item});
            }
        },

        hideDrawer: function($toElement) {
            //only trigger popup:closed if drawer is visible
            if (this._isVisible) {
                Adapt.trigger('popup:closed', $toElement);
                this._isVisible = false;
                $('body').scrollEnable();
            } else {
                return;
            }

            if (this.disableAnimation) {

                var direction={};
                direction[this.drawerDir]=-this.$el.width();
                this.$el
                    .css(direction)
                    .addClass('display-none')
                    .attr('aria-hidden', 'true');

                $('#shadow').addClass("display-none");

                Adapt.trigger('drawer:closed');

            } else {

                var showEasingAnimation = Adapt.config.get('_drawer')._hideEasing;
                var easing = (showEasingAnimation) ? showEasingAnimation : 'easeOutQuart';

                var direction={};
                direction[this.drawerDir]=-this.$el.width();
                this.$el.velocity(direction, this.drawerDuration, easing, _.bind(function() {
                    this.$el
                        .addClass('display-none')
                        .attr('aria-hidden', 'true');

                    Adapt.trigger('drawer:closed');
                }, this));

                $('#shadow').velocity({opacity:0}, {duration:this.drawerDuration, complete:function() {
                    $('#shadow').addClass("display-none");
                }});

            }

            this._isCustomViewVisible = false;
            this.removeShadowEvent();


        },

        addShadowEvent: function() {
            $('#shadow').one('click touchstart', _.bind(function() {
                this.onCloseDrawer();
            }, this));
        },

        removeShadowEvent: function() {
            $('#shadow').off('click touchstart');
        },

        remove: function() {
            Backbone.View.prototype.remove.apply(this, arguments);
            $(window).off("keyup", this._onKeyUp);

            Adapt.trigger('drawer:empty');
            this.collection.reset();
            $('#shadow').remove();
        }

    });

    var DrawerItemView = Backbone.View.extend({

        className: 'drawer-item',

        attributes: {
            role: 'listitem'
        },

        initialize: function() {
            this.listenTo(Adapt, 'drawer:empty', this.remove);
            this.render();
        },

        events: {
            'click .drawer-item-open': 'onDrawerItemClicked'
        },

        render: function() {
            var data = this.model.toJSON();
            var template = Handlebars.templates['drawerItem']
            $(this.el).html(template(data)).appendTo('.drawer-holder');
            return this;
        },

        onDrawerItemClicked: function(event) {
            event.preventDefault();
            var eventCallback = this.model.get('eventCallback');
            Adapt.trigger(eventCallback);
        }
    });

    return DrawerView;
});

define('core/js/drawer',[
    'core/js/adapt',
    'core/js/views/drawerView'
], function(Adapt, DrawerView) {

    var DrawerCollection = new Backbone.Collection(null, { comparator: 'drawerOrder' });
    var Drawer = {};

    Drawer.addItem = function(drawerObject, eventCallback) {
        drawerObject.eventCallback = eventCallback;
        DrawerCollection.add(drawerObject);
    };

    Drawer.triggerCustomView = function(view, hasBackButton) {
        if (hasBackButton !== false) {
            hasBackButton = true;
        }
        Adapt.trigger('drawer:triggerCustomView', view, hasBackButton);
    };

    Adapt.on({
        'adapt:start': function() {
            new DrawerView({ collection: DrawerCollection });
        },
        'app:languageChanged': function() {
            Adapt.trigger('drawer:remove');
        }
    });

    Adapt.drawer = Drawer;

});

define('core/js/views/notifyView',[
    'core/js/adapt'
], function(Adapt) {

    var NotifyView = Backbone.View.extend({

        className: function() {
            var classes = 'notify ';
            classes += (this.model.get('_classes') || '');
            return classes;
        },

        attributes: {
            'role': 'dialog',
            'aria-labelledby': 'notify-heading',
            'aria-modal': 'true'
        },

        disableAnimation: false,
        isOpen: false,
        hasOpened: false,

        initialize: function() {
            this.disableAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;

            this.setupEventListeners();

            this.render();
        },

        setupEventListeners: function() {
            this.listenTo(Adapt, {
                'remove page:scrollTo': this.closeNotify,
                'notify:resize': this.resetNotifySize,
                'notify:cancel': this.cancelNotify,
                'notify:close': this.closeNotify,
                'device:resize': this.resetNotifySize
            });

            this._onKeyUp = this.onKeyUp.bind(this);
            this.setupEscapeKey();
        },

        setupEscapeKey: function() {
            $(window).on('keyup', this._onKeyUp);
        },

        onKeyUp: function(event) {
            if (event.which != 27) return;
            event.preventDefault();

            this.cancelNotify();
        },

        events: {
            'click .notify-popup-alert-button':'onAlertButtonClicked',
            'click .notify-popup-prompt-button': 'onPromptButtonClicked',
            'click .notify-popup-done': 'onCloseButtonClicked',
            'click .notify-shadow': 'onShadowClicked'
        },

        render: function() {
            var data = this.model.toJSON();
            var template = Handlebars.templates['notify'];

            //hide notify container
            this.$el.css('visibility', 'hidden');
            //attach popup + shadow
            this.$el.html(template(data)).prependTo('body');
            //hide popup
            this.$('.notify-popup').css('visibility', 'hidden');
            //show notify container
            this.$el.css('visibility', 'visible');

            this.showNotify();
            return this;
        },

        onAlertButtonClicked: function(event) {
            event.preventDefault();
            //tab index preservation, notify must close before subsequent callback is triggered
            this.closeNotify();
            Adapt.trigger(this.model.get('_callbackEvent'), this);
        },

        onPromptButtonClicked: function(event) {
            event.preventDefault();
            //tab index preservation, notify must close before subsequent callback is triggered
            this.closeNotify();
            Adapt.trigger($(event.currentTarget).attr('data-event'), this);
        },

        onCloseButtonClicked: function(event) {
            event.preventDefault();
            //tab index preservation, notify must close before subsequent callback is triggered
            this.cancelNotify();
        },

        onShadowClicked: function(event) {
            event.preventDefault();
            if (this.model.get("_closeOnShadowClick") === false) return;
            this.cancelNotify();
        },

        cancelNotify: function() {
            if (this.model.get("_isCancellable") === false) return;
            //tab index preservation, notify must close before subsequent callback is triggered
            this.closeNotify();
            Adapt.trigger('notify:cancelled', this);
        },

        resetNotifySize: function() {
            $('.notify-popup').removeAttr('style');

            this.resizeNotify();
        },

        resizeNotify: function() {
            var windowHeight = $(window).height();
            var notifyHeight = this.$('.notify-popup').outerHeight();

            if (notifyHeight > windowHeight) {
                this.$('.notify-popup').css({
                    'height':'100%',
                    'top':0,
                    'overflow-y': 'scroll',
                    '-webkit-overflow-scrolling': 'touch'
                });
            } else {
                this.$('.notify-popup').css({
                    'margin-top': -(notifyHeight/2)
                });
            }
        },

        showNotify: function() {
            this.isOpen = true;
            this.addSubView();

            // Keep focus from previous action
            this.$previousActiveElement = $(document.activeElement);

            Adapt.trigger('notify:opened', this);

            this.$el.imageready(this.onLoaded.bind(this));
        },

        onLoaded: function() {
            if (this.disableAnimation) {
                this.$('.notify-shadow').css('display', 'block');
            } else {

                this.$('.notify-shadow').velocity({ opacity: 0 }, { duration: 0 }).velocity({ opacity: 1 }, {duration: 400, begin: function() {
                    this.$('.notify-shadow').css('display', 'block');
                }.bind(this)});

            }

            this.resizeNotify();

            if (this.disableAnimation) {

                this.$('.notify-popup').css('visibility', 'visible');
                this.onOpened();

            } else {

                this.$('.notify-popup').velocity({ opacity: 0 }, { duration: 0 }).velocity({ opacity: 1 }, { duration: 400, begin: function() {
                    // Make sure to make the notify visible and then set
                    // focus, disabled scroll and manage tabs
                    this.$('.notify-popup').css('visibility', 'visible');
                    this.onOpened();
                }.bind(this)});

            }
        },

        onOpened: function() {
            this.hasOpened = true;
            // Allows popup manager to control focus
            Adapt.trigger('popup:opened', this.$('.notify-popup'));
            $('body').scrollDisable();
            $('html').addClass('notify');

            // Set focus to first accessible element
            this.$('.notify-popup').a11y_focus(true);
        },

        addSubView: function() {

            this.subView = this.model.get("_view");
            if (!this.subView) return;

            this.$(".notify-popup-content-inner").append(this.subView.$el);

        },

        closeNotify: function (event) {
            // Prevent from being invoked multiple times - see https://github.com/adaptlearning/adapt_framework/issues/1659
            if (!this.isOpen) return;
            this.isOpen = false;

            // If closeNotify is called before showNotify has finished then wait
            // until it's open.
            if (!this.hasOpened) {
                this.listenToOnce(Adapt, 'popup:opened', function() {
                    // Wait for popup:opened to finish processing
                    _.defer(this.onCloseReady.bind(this));
                });
            } else {
                this.onCloseReady();
            }
        },

        onCloseReady: function() {
            if (this.disableAnimation) {

                this.$('.notify-popup').css('visibility', 'hidden');
                this.$el.css('visibility', 'hidden');

                this.remove();

            } else {

                this.$('.notify-popup').velocity({ opacity: 0 }, {duration: 400, complete: function() {
                    this.$('.notify-popup').css('visibility', 'hidden');
                }.bind(this)});

                this.$('.notify-shadow').velocity({ opacity: 0 }, {duration: 400, complete:function() {
                    this.$el.css('visibility', 'hidden');
                    this.remove();
                }.bind(this)});
            }

            $('body').scrollEnable();
            $('html').removeClass('notify');

            // Return focus to previous active element
            Adapt.trigger('popup:closed', this.$previousActiveElement);
            // Return reference to the notify view
            Adapt.trigger('notify:closed', this);
        },

        remove: function() {
            this.removeSubView();
            $(window).off('keyup', this._onKeyUp);
            Backbone.View.prototype.remove.apply(this, arguments);
        },

        removeSubView: function() {
            if (!this.subView) return;
            this.subView.remove();
            this.subView = null;

        }

    });

    return NotifyView;

});

define('core/js/views/notifyPushView',[
    'core/js/adapt'
], function (Adapt) {

    var NotifyPushView = Backbone.View.extend({

        className: function () {
            return 'notify-push ' + this.model.get('_classes');
        },

        attributes: {
            'role': 'dialog',
            'aria-labelledby': 'notify-push-heading',
            'aria-modal': 'false'
        },

        initialize: function () {
            this.listenTo(Adapt, {
                'notify:pushShown notify:pushRemoved': this.updateIndexPosition,
                'remove': this.remove
            });

            this.listenTo(this.model.collection, {
                'remove': this.updateIndexPosition,
                'change:_index': this.updatePushPosition
            });

            this.preRender();
            this.render();
        },

        events: {
            'click .notify-push-close': 'closePush',
            'click .notify-push-inner': 'triggerEvent'
        },

        preRender: function () {
            this.hasBeenRemoved = false;
        },

        render: function () {
            var data = this.model.toJSON();
            var template = Handlebars.templates['notifyPush'];
            this.$el.html(template(data)).appendTo('#wrapper');

            _.defer(this.postRender.bind(this));

            return this;
        },

        postRender: function () {
            this.$el.addClass('show');

            _.delay(this.closePush.bind(this), this.model.get('_timeout'));

            Adapt.trigger('notify:pushShown');
        },

        closePush: function (event) {
            if (event) {
                event.preventDefault();
            }

            // Check whether this view has been removed as the delay can cause it to be fired twice
            if (this.hasBeenRemoved === false) {

                this.hasBeenRemoved = true;

                this.$el.removeClass('show');

                _.delay(function () {
                    this.model.collection.remove(this.model);
                    Adapt.trigger('notify:pushRemoved', this);
                    this.remove();
                }.bind(this), 600);
            }
        },

        triggerEvent: function (event) {
            Adapt.trigger(this.model.get('_callbackEvent'));
            this.closePush();
        },

        updateIndexPosition: function () {
            if (!this.hasBeenRemoved) {
                var models = this.model.collection.models;
                for (var i = 0, len = models.length; i < len; i++) {
                    var index = i;
                    var model = models[i];
                    if (model.get('_isActive') === true) {
                        model.set('_index', index);
                        this.updatePushPosition();
                    }
                }
            }
        },

        updatePushPosition: function () {
            if (this.hasBeenRemoved) {
                return;
            }

            if (this.model.get('_index') != undefined) {
                var elementHeight = this.$el.height();
                var offset = 20;
                var navigationHeight = $('.navigation').height();
                var currentIndex = this.model.get('_index');
                var flippedIndex = (currentIndex == 0) ? 1 : 0;

                if (this.model.collection.where({ _isActive: true }).length === 1) {
                    flippedIndex = 0;
                }

                var positionLowerPush = (elementHeight + offset) * flippedIndex + navigationHeight + offset;
                this.$el.css('top', positionLowerPush);
            }
        }
    });

    return NotifyPushView;

});

define('core/js/models/notifyModel',[],function() {

    var NotifyModel = Backbone.Model.extend({
        defaults: {
        	_isActive:false,
        	_showIcon:false,
        	_timeout:3000
        }
    });

    return NotifyModel;

});

define('core/js/notify',[
	'core/js/adapt',
	'core/js/views/notifyView',
	'core/js/views/notifyPushView',
	'core/js/models/notifyModel'
], function(Adapt, NotifyView, NotifyPushView, NotifyModel) {

	// Build a collection to store push notifications
	var NotifyPushCollection = Backbone.Collection.extend({

		model: NotifyModel,

		initialize: function() {
			this.listenTo(this, 'add', this.onPushAdded);
			this.listenTo(Adapt, 'notify:pushRemoved', this.onRemovePush);
		},

		onPushAdded: function(model) {
			this.checkPushCanShow(model);
		},

		checkPushCanShow: function(model) {
			if (this.canShowPush()) {
				model.set('_isActive', true);
				this.showPush(model);
			}
		},

		canShowPush: function() {
			var availablePushNotifications = this.where({_isActive:true});
			if (availablePushNotifications.length >= 2) {
				return false;
			}
			return true;
		},

		showPush: function(model) {
			new NotifyPushView({
				model: model
			});
		},

		onRemovePush: function(view) {
			var inactivePushNotifications = this.where({_isActive:false});
			if (inactivePushNotifications.length > 0) {
				this.checkPushCanShow(inactivePushNotifications[0]);
			}
		}

	});

	var NotifyPushes = new NotifyPushCollection();

	Adapt.on('notify:alert', function(notifyObject) {
		addNotifyView('alert', notifyObject);
	});

	Adapt.on('notify:prompt', function(notifyObject) {
		addNotifyView('prompt', notifyObject);
	});

	Adapt.on('notify:popup', function(notifyObject) {
		addNotifyView('popup', notifyObject);
	});

	Adapt.on('notify:push', function(notifyObject) {
		addNotifyView('push', notifyObject);
	});

	function addNotifyView(type, notifyObject) {
		// set default values 
		notifyObject._isCancellable = (notifyObject._isCancellable === undefined) 
			? true : notifyObject._isCancellable;
		
		notifyObject._showCloseButton = (notifyObject._showCloseButton === undefined) 
			? true : notifyObject._showCloseButton;

		notifyObject._closeOnShadowClick = (notifyObject._closeOnShadowClick === undefined) 
			? true : notifyObject._closeOnShadowClick;

		notifyObject._type = type;

		if (type === 'push') {

			NotifyPushes.push(notifyObject);

			return;

		}

		var notify = new NotifyView({
			model: new NotifyModel(notifyObject)
		});

	}

});

define('core/js/popupManager',[
    'core/js/adapt'
], function(Adapt) {

    Adapt.on('popup:opened', function($element) {

        //capture currently active element or element specified
        var $activeElement = $element || $(document.activeElement);

        //save tab indexes
        $activeElement.a11y_popup();
    });

    Adapt.on('popup:closed', function($target) {

        //restore tab indexes
        var $launchedElement = $.a11y_popdown();
        var $activeElement = $target || $launchedElement;

        if ($activeElement) {
            return $activeElement.focusOrNext();
        }

        // focus on the first readable element
        $.a11y_focus();

    });

});

define('core/js/models/routerModel',[
    'core/js/adapt'
], function (Adapt) {

 	var RouterModel = Backbone.Model.extend({

 		defaults: {
 			_canNavigate: true,
			_shouldNavigateFocus: true
 		},

 		lockedAttributes: {
 			_canNavigate: false,
			_shouldNavigateFocus: false
 		}
 		
 	});

 	return RouterModel;

 });

define('core/js/views/adaptView',[
    'core/js/adapt'
], function(Adapt) {

    var AdaptView = Backbone.View.extend({

        attributes: function() {
            return {
                "data-adapt-id": this.model.get('_id')
            };
        },

        initialize: function() {
            this.listenTo(Adapt, 'remove', this.remove);
            this.listenTo(this.model, {
                'change:_isVisible': this.toggleVisibility,
                'change:_isHidden': this.toggleHidden,
                'change:_isComplete': this.onIsCompleteChange
            });
            this.model.set( {
                '_globals': Adapt.course.get('_globals'),
                '_isReady': false
            });
            this._isRemoved = false;
            this.preRender();
            this.render();
            this.setupOnScreenHandler();
        },

        preRender: function() {},

        postRender: function() {
            this.addChildren();
        },

        render: function() {
            Adapt.trigger(this.constructor.type + 'View:preRender', this);

            var data = this.model.toJSON();
            data.view = this;
            var template = Handlebars.templates[this.constructor.template];
            this.$el.html(template(data));

            Adapt.trigger(this.constructor.type + 'View:render', this);

            _.defer(function() {
                // don't call postRender after remove
                if(this._isRemoved) return;

                this.postRender();
                Adapt.trigger(this.constructor.type + 'View:postRender', this);
            }.bind(this));

            return this;
        },

        setupOnScreenHandler: function() {
            var onscreen = this.model.get('_onScreen');

            if (!onscreen || !onscreen._isEnabled) return;

            this.$el.on('onscreen.adaptView', function (e, m) {

                if (!m.onscreen) return;

                var minVerticalInview = onscreen._percentInviewVertical || 33;

                if (m.percentInviewVertical < minVerticalInview) return;

                this.$el.addClass( onscreen._classes || 'onscreen' ).off('onscreen.adaptView');

            }.bind(this));
        },

        addChildren: function() {
            var nthChild = 0;
            var children = this.model.getChildren();
            var models = children.models;
            for (var i = 0, len = models.length; i < len; i++) {
                var model = models[i];
                if (model.get('_isAvailable')) {
                    nthChild ++;

                    var ChildView;
                    var ViewModelObject = this.constructor.childView || Adapt.componentStore[model.get("_component")];

                    //use view+model object
                    if (ViewModelObject.view) ChildView = ViewModelObject.view;
                    //use view only object
                    else ChildView = ViewModelObject;

                    if (ChildView) {
                        var $parentContainer = this.$(this.constructor.childContainer);
                        model.set("_nthChild", nthChild);
                        if (Adapt.config.get("_defaultDirection") == 'rtl' && model.get("_type") == 'component') {
                            $parentContainer.prepend(new ChildView({model:model}).$el);
                        } else {
                            $parentContainer.append(new ChildView({model:model}).$el);
                        }
                    } else {
                        throw 'The component \'' + models[i].attributes._id + '\'' +
                              ' (\'' + models[i].attributes._component + '\')' +
                              ' has not been installed, and so is not available in your project.';
                    }
                }
            }
        },

        setReadyStatus: function() {
            this.model.set('_isReady', true);
        },

        setCompletionStatus: function() {
            if (this.model.get('_isVisible')) {
                this.model.set({
                    '_isComplete': true,
                    '_isInteractionComplete': true
                });
            }
        },

        resetCompletionStatus: function(type) {
            if (!this.model.get("_canReset")) return;

            var descendantComponents = this.model.findDescendantModels('components');
            if (descendantComponents.length === 0) {
                this.model.reset(type);
            } else {
                _.each(descendantComponents, function(model) {
                    model.reset(type);
                });
            }
        },

        preRemove: function() {},

        remove: function() {

            this.preRemove();
            this._isRemoved = true;

            Adapt.wait.for(function(end) {

                this.$el.off('onscreen.adaptView');
                this.model.setOnChildren('_isReady', false);
                this.model.set('_isReady', false);
                Backbone.View.prototype.remove.call(this);

                end();
            }.bind(this));

            return this;
        },

        setVisibility: function() {
            var visible = "visibility-hidden";
            if (this.model.get('_isVisible')) {
                visible = "";
            }
            return visible;
        },

        toggleVisibility: function() {
            if (this.model.get('_isVisible')) {
                return this.$el.removeClass('visibility-hidden');
            }
            this.$el.addClass('visibility-hidden');
        },

        setHidden: function() {
            var hidden = "";
            if (this.model.get('_isHidden')) {
                hidden = "display-none";
            }
            return hidden;
        },

        toggleHidden: function() {
            if (!this.model.get('_isHidden')) {
                return this.$el.removeClass('display-none');
            }
            this.$el.addClass('display-none');
        },

        onIsCompleteChange:function(model, isComplete){
            this.$el.toggleClass('completed', isComplete);
        }
    });

    return AdaptView;

});

define('core/js/views/blockView',[
    'core/js/views/adaptView'
], function(AdaptView) {

    var BlockView = AdaptView.extend({

        className: function() {
            return "block " + 
            this.model.get('_id') +
            " " + this.model.get('_classes') + 
            " " + this.setVisibility() +
            " " + this.setHidden() +
            " nth-child-" +
            this.model.get("_nthChild") +
            " " + (this.model.get('_isComplete') ? 'completed' : '');
        }

    }, {
        childContainer: '.component-container',
        type: 'block',
        template: 'block'
    });

    return BlockView;

});

define('core/js/views/articleView',[
    'core/js/views/adaptView',
    'core/js/views/blockView'
], function(AdaptView, BlockView) {

    var ArticleView = AdaptView.extend({
        
        className: function() {
            return "article " +
            this.model.get('_id') +
            " " + this.model.get('_classes') +
            " " + this.setVisibility() +
            " " + this.setHidden() +
            " nth-child-" +
            this.model.get("_nthChild") +
            " " + (this.model.get('_isComplete') ? 'completed' : '');
        }

    }, {
        childContainer: '.block-container',
        childView: BlockView,
        type: 'article',
        template: 'article'
    });

    return ArticleView;

});

define('core/js/views/pageView',[
    'core/js/adapt',
    'core/js/views/adaptView',
    'core/js/views/articleView'
], function(Adapt, AdaptView, ArticleView) {

    var PageView = AdaptView.extend({

        attributes: function() {
            return AdaptView.resultExtend('attributes', {
                "aria-labelledby": this.model.get('_id')+"-heading",
                "role": "main"
            }, this);
        },
       
        className: function() {
            return "page " +
            this.model.get('_id') +
            " " + this.model.get('_classes') +
            " " + this.setVisibility() +
            " " + (this.model.get('_isComplete') ? 'completed' : '');
        },

        preRender: function() {
            this.disableAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;
            this.$el.css('opacity', 0);
            this.listenTo(this.model, 'change:_isReady', this.isReady);
        },

        isReady: function() {
            if (this.model.get('_isReady')) {
                _.defer(_.bind(function() {
                    $('.loading').hide();
                    $(window).scrollTop(0);
                    Adapt.trigger('pageView:ready', this);
                    var styleOptions = { opacity: 1 };
                    if (this.disableAnimation) {
                        this.$el.css(styleOptions);
                        $.inview();
                    } else {
                        this.$el.velocity(styleOptions, {
                            duration: 'fast',
                            complete: function() {
                                $.inview();
                            }
                        });
                    }
                    $(window).scroll();
                }, this));
            }
        },

        remove: function() {
            if (this.$pageLabel) {
                this.$pageLabel.remove();
            }
            AdaptView.prototype.remove.call(this);
        }

    }, {
        childContainer: '.article-container',
        childView: ArticleView,
        type: 'page',
        template: 'page'
    });

    return PageView;

});

define('core/js/router',[
    'core/js/adapt',
    'core/js/models/routerModel',
    'core/js/views/pageView',
    'core/js/startController'
], function(Adapt, RouterModel, PageView) {

    Adapt.router = new RouterModel(null, { reset: true });

    var Router = Backbone.Router.extend({

        // Flag to indicate if the router has tried to redirect to the current location.
        _isCircularNavigationInProgress: false,

        initialize: function() {
            this.showLoading();

            // Store #wrapper element and html to cache for later use.
            this.$wrapper = $('#wrapper');
            this.$html = $('html');

            Adapt.once('app:dataReady', function() {
                document.title = Adapt.course.get('title');
            });

            this.listenTo(Adapt, {
                'navigation:backButton': this.navigateToPreviousRoute,
                'navigation:homeButton': this.navigateToHomeRoute,
                'navigation:skipNavigation': this.skipNavigation,
                'navigation:parentButton': this.navigateToParent,
                'router:navigateTo': this.navigateToArguments
            });
        },

        routes: {
            '': 'handleRoute',
            'id/:id': 'handleRoute',
            ':pluginName(/*location)(/*action)': 'handleRoute'
        },

        pruneArguments: function(args) {
            var prunedArgs = _.toArray(args);

            if (prunedArgs.length !== 0) {
                // Remove any null arguments.
                prunedArgs = _.without(args, null);
            }

            return prunedArgs;
        },

        handleRoute: function() {
            var args = this.pruneArguments(arguments);
            
            if (Adapt.router.get('_canNavigate')) {
                // Reset _isCircularNavigationInProgress protection as code is allowed to navigate away.
                this._isCircularNavigationInProgress = false;
            }

            // Check if the current page is in the process of navigating to itself.
            // It will redirect to itself if the URL was changed and _canNavigate is false.
            if (this._isCircularNavigationInProgress === false) {
                // Trigger an event pre 'router:location' to allow extensions to stop routing.
                Adapt.trigger('router:navigate', args);
            }

            // Re-check as _canNavigate can be set to false on 'router:navigate' event.
            if (Adapt.router.get('_canNavigate')) {
                // Disable navigation whilst rendering.
                Adapt.router.set('_canNavigate', false, { pluginName: 'adapt' });

                switch (args.length) {
                    case 1:
                        // If only one parameter assume it's the ID.
                        return this.handleId.apply(this, args);
                    case 2:
                        // If there are two parameters assume it's a plugin.
                        return this.handlePluginRouter.apply(this, args);
                    default:
                        // Route to course home page.
                        return this.handleCourse();
                }
            }

            if (this._isCircularNavigationInProgress) {
                // Navigation correction finished.
                // Router has successfully re-navigated to the current _id as the URL was changed 
                // while _canNavigate: false
                this._isCircularNavigationInProgress = false;
                return;
            }

            // Cancel navigation to stay at the current location.
            this._isCircularNavigationInProgress = true;
            Adapt.trigger('router:navigationCancelled', args);

            // Reset URL to the current one.
            this.navigateToCurrentRoute(true);
        },

        handlePluginRouter: function(pluginName, location, action) {
            var pluginLocation = pluginName;

            if (location) {
                pluginLocation = pluginLocation + '-' +location;

                if (action) {
                    pluginLocation = pluginLocation + '-' + action;
                }
            }

            this.updateLocation(pluginLocation, null, null, function() {
                Adapt.trigger('router:plugin:' + pluginName, pluginName, location, action);
                Adapt.trigger('router:plugin', pluginName, location, action);

                Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
            });
        },

        handleCourse: function() {
            if (Adapt.course.has('_start')) {
                // Do not allow access to the menu when the start controller is enabled.
                var startController = Adapt.course.get('_start');

                if (startController._isEnabled == true && startController._isMenuDisabled == true) {
                    return;
                }
            }

            this.showLoading();

            this.removeViews(_.bind(function() {
                Adapt.course.set('_isReady', false);

                this.setContentObjectToVisited(Adapt.course);
                
                this.updateLocation('course', null, null, _.bind(function() {
                    Adapt.once('menuView:ready', function() {
                        // Allow navigation.
                        Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
                        this.handleNavigationFocus();
                    }.bind(this));

                    Adapt.trigger('router:menu', Adapt.course);
                }, this));
            }, this));
        },

        handleId: function(id) {
            var currentModel = Adapt.findById(id);
            var type = '';

            if (!currentModel) {
                Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
                return;
            }

            type = currentModel.get('_type');

            switch (type) {
                case 'page':
                case 'menu':
                    if (currentModel.get('_isLocked') && Adapt.config.get('_forceRouteLocking')) {
                        Adapt.log.warn('Unable to navigate to locked id: ' + id);
                        Adapt.router.set('_canNavigate', true, {pluginName: 'adapt'});
                        if (Adapt.location._previousId === undefined) {
                            return this.navigate('#/', { trigger: true, replace: true });
                        } else {
                            return Backbone.history.history.back();
                        }
                    } else {
                        this.showLoading();
                        this.removeViews(_.bind(function() {

                            this.setContentObjectToVisited(currentModel);

                            if (type == 'page') {
                                var location = 'page-' + id;
                                this.updateLocation(location, 'page', id, _.bind(function() {
                                    Adapt.once('pageView:ready', function() {
                                        // Allow navigation.
                                        Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
                                        this.handleNavigationFocus();
                                    }.bind(this));
                                    Adapt.trigger('router:page', currentModel);
                                    this.$wrapper.append(new PageView({ model: currentModel }).$el);
                                }, this));
                            } else {
                                var location = 'menu-' + id;
                                this.updateLocation(location, 'menu', id, _.bind(function() {
                                    Adapt.once('menuView:ready', function() {
                                        // Allow navigation.
                                        Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
                                        this.handleNavigationFocus();
                                    }.bind(this));
                                    Adapt.trigger('router:menu', currentModel);
                                }, this));
                            }
                        }, this));
                    }
                    break;
                default:
                    // Allow navigation.
                    Adapt.router.set('_canNavigate', true, { pluginName: 'adapt' });
                    Adapt.navigateToElement('.' + id, { replace: true });
            }
        },

        removeViews: function(onComplete) {
            Adapt.remove();

            Adapt.wait.queue(onComplete);
        },

        showLoading: function() {
            $('.loading').show();
        },

        navigateToArguments: function(args) {
            args = this.pruneArguments(args);

            var options = { trigger: false, replace: false };

            switch (args.length) {
                case 0:
                    this.navigate('#/', options);
                    break;
                case 1:
                    if (Adapt.findById(args[0])) {
                        this.navigate('#/id/' + args[0], options);
                    } else {
                        this.navigate('#/' + args[0], options);
                    }
                    break;
                case 2:
                case 3:
                    this.navigate('#/' + args.join('/'), options);
                    break;
                default:
                    Adapt.log.warn('DEPRECATED - use Backbone.history.navigate or ' +
                        'window.location.href instead of Adapt.trigger("router:navigateTo")');
                    this.handleRoute.apply(this, args);
            }
        },

        skipNavigation: function() {
             $('.' + Adapt.location._contentType).a11y_focus();
        },

        navigateToPreviousRoute: function(force) {
            // Sometimes a plugin might want to stop the default navigation.
            // Check whether default navigation has changed.
            if (Adapt.router.get('_canNavigate') || force) {
                if (!Adapt.location._currentId) {
                    return Backbone.history.history.back();
                }
                if (Adapt.location._previousContentType === 'page' && Adapt.location._contentType === 'menu') {
                    return this.navigateToParent();
                }
                if (Adapt.location._previousContentType === 'page') {
                    return Backbone.history.history.back();
                }
                if (Adapt.location._currentLocation === 'course') {
                    return;
                }
                this.navigateToParent();
            }
        },

        navigateToHomeRoute: function(force) {
            if (Adapt.router.get('_canNavigate') || force ) {
                this.navigate('#/', { trigger: true });
            }
        },

        navigateToCurrentRoute: function(force) {
            if (Adapt.router.get('_canNavigate') || force) {
                if (!Adapt.location._currentId) {
                    return;
                }
                var currentId = Adapt.location._currentId;
                var route = (currentId === Adapt.course.get('_id')) ? '#/' : '#/id/' + currentId;
                this.navigate(route, { trigger: true, replace: true });
            }
        },

        navigateToParent: function(force) {
            if (Adapt.router.get('_canNavigate') || force) {
                var parentId = Adapt.contentObjects.findWhere({ _id: Adapt.location._currentId }).get('_parentId');
                var route = (parentId === Adapt.course.get('_id')) ? '#/' : '#/id/' + parentId;
                this.navigate(route, { trigger: true });
            }
        },

        setContentObjectToVisited: function(model) {
            model.set('_isVisited', true);
        },

        updateLocation: function(currentLocation, type, id, onComplete) {
            // Handles updating the location.
            Adapt.location._previousId = Adapt.location._currentId;
            Adapt.location._previousContentType = Adapt.location._contentType;

            if (currentLocation === 'course') {
                Adapt.location._currentId = Adapt.course.get('_id');
                Adapt.location._contentType = 'menu';
                Adapt.location._lastVisitedMenu = currentLocation;
            } else if (!type) {
                Adapt.location._currentId = null;
                Adapt.location._contentType = null;
            } else if (_.isString(id)) {
                Adapt.location._currentId = id;
                Adapt.location._contentType = type;

                if (type === 'menu') {
                    Adapt.location._lastVisitedType = 'menu';
                    Adapt.location._lastVisitedMenu = id;
                } else if (type === 'page') {
                    Adapt.location._lastVisitedType = 'page';
                    Adapt.location._lastVisitedPage = id;
                }
            }

            Adapt.location._currentLocation = currentLocation;

            var classes = (Adapt.location._currentId) ? 'location-'
                    + Adapt.location._contentType
                    + ' location-id-'
                    + Adapt.location._currentId :
                    'location-' + Adapt.location._currentLocation;

            var previousClasses = Adapt.location._previousClasses;
            if (previousClasses) {
                this.$html.removeClass(previousClasses);
            }
            Adapt.location._previousClasses = classes;

            this.$html
                .addClass(classes)
                .attr('data-location', Adapt.location._currentLocation);
                
            this.$wrapper
                .removeClass()
                .addClass(classes)
                .attr('data-location', Adapt.location._currentLocation);

            this.setDocumentTitle();

            // Trigger event when location changes.
            Adapt.trigger('router:location', Adapt.location);

            Adapt.wait.queue(onComplete);
        },

        setDocumentTitle: function() {
            if (!Adapt.location._currentId) return;

            var currentModel = Adapt.findById(Adapt.location._currentId);
            var pageTitle = '';

            if (currentModel && currentModel.get('_type') !== 'course') {
                var currentTitle = currentModel.get('title');
                
                if (currentTitle) {
                    pageTitle = ' | ' + currentTitle;
                }
            }

            var courseTitle = Adapt.course.get('title');
            var documentTitle = $('<div>' + courseTitle + pageTitle + '</div>').text();

            Adapt.once('pageView:ready menuView:ready', function() {
                document.title = documentTitle;
            });
        },

        handleNavigationFocus: function() {
            if (!Adapt.router.get("_shouldNavigateFocus")) return;
            // Body will be forced to accept focus to start the
            // screen reader reading the page.
            $("body").focusNoScroll();
        }
    });

    return new Router({ model: new Backbone.Model() });

});

define('core/js/helpers',[
    'handlebars',
    'core/js/adapt'
], function(Handlebars, Adapt){

    var helpers = {

        lowercase: function(text) {
            return text.toLowerCase();
        },

        capitalise:  function(text) {
            return text.charAt(0).toUpperCase() + text.slice(1);
        },

        inc: function(index) {
            return index+1;
        },

        dec: function(index) {
            return index-1;
        },

        odd: function (index) {
            return (index +1) % 2 === 0  ? 'even' : 'odd';
        },

        equals: function(value, text, block) {
            return helpers.compare.call(this, value, "==", text, block);
        },

        compare: function(value, operator, text, block) {
            // Comparison operators
            switch (operator) {
            case "===":
                if (value === text) return block.fn(this);
                break;
            case "=": case "==":
                if (value == text) return block.fn(this);
                break;
            case ">=":
                if (value >= text) return block.fn(this);
                break;
            case "<=":
                if (value <= text) return block.fn(this);
                break;
            case ">":
                if (value > text) return block.fn(this);
                break;
            case "<":
                if (value < text) return block.fn(this);
                break;
            }
            return block.inverse(this);
        },

        math: function(lvalue, operator, rvalue, options) {
            // Mathematical operators
            lvalue = parseFloat(lvalue);
            rvalue = parseFloat(rvalue);
            switch (operator) {
            case "+": return lvalue + rvalue;
            case "-": return lvalue - rvalue;
            case "*": return lvalue * rvalue;
            case "/": return lvalue / rvalue;
            case "%": return lvalue % rvalue;
            }
        },

        /**
         * Equivalent to:
         *  if (conditionA || conditionB)
         * @example
         * {{#any displayTitle body instruction}}
         * <div class="component__header {{_component}}__header"></div>
         * {{/any}}
         */
        any: function() {
            var args = Array.prototype.slice.call(arguments, 0, -1);
            var block = Array.prototype.slice.call(arguments, -1)[0];

            return _.any(args) ? block.fn(this) : block.inverse(this);
        },

        /**
         * Equivalent to:
         *  if (conditionA && conditionB)
         * @example
         * {{#all displayTitle body instruction}}
         * <div class="component__header {{_component}}__header"></div>
         * {{/all}}
         */
        all: function() {
            var args = Array.prototype.slice.call(arguments, 0, -1);
            var block = Array.prototype.slice.call(arguments, -1)[0];

            return _.all(args) ? block.fn(this) : block.inverse(this);
        },

        /**
         * Allow JSON to be a template i.e. you can use handlebars {{expressions}} within your JSON
         */
        compile: function(template, context) {
            if (!template) return "";
            if (template instanceof Object) template = template.toString();
            var data = this;
            if (context) {
                // choose between a passed argument context or the default handlebars helper context
                data = (!context.data || !context.data.root ? context : context.data.root);
            }
            return Handlebars.compile(template)(data);
        },

        /**
         * Allow JSON to be a template and accessible text
         */
        compile_a11y_text: function(template, context) {
            Adapt.log.warn("DEPRECATED: a11y_text is no longer required. https://tink.uk/understanding-screen-reader-interaction-modes/");
            return helpers.compile.call(this, template, context);
        },

        /**
         * Allow JSON to be a template and normalized text
         */
        compile_a11y_normalize: function(template, context) {
            if (!template) return "";
            if (template instanceof Object) template = template.toString();
            return Handlebars.helpers.a11y_normalize.call(this, helpers.compile.call(this, template, context));
        },

        /**
         * Remove all html tags except styling tags
         */
        compile_a11y_remove_breaks: function(template, context) {
            if (!template) return "";
            return Handlebars.helpers.a11y_remove_breaks.call(this, helpers.compile.call(this, template, context));
        },

        /**
         * makes the _globals object in course.json available to a template
         */
        import_globals: function(context) {
            if (context.data.root._globals) return "";
            context.data.root._globals = Adapt.course.get('_globals');
            return "";
        },

        /**
         * makes the Adapt module data available to a template
         */
        import_adapt: function(context) {

            if (context.data.root.Adapt) return;
            var adapt = context.data.root.Adapt = {};

            var i, l, name;

            var directImport = ['config','course'];
            for (i = 0, l = directImport.length; i < l; i++) {
                name = directImport[i];
                // convert the model to a json object and add to the current context
                adapt[name] = Adapt[name].toJSON();
            }

            var indexedImport = ['contentObjects','articles','blocks','components'];
            for (i = 0, l = indexedImport.length; i < l; i++) {
                name = indexedImport[i];
                // convert the collection of models to an array of json objects
                var importArray = Adapt[name].toJSON();
                // convert the array of json models to an object indexed by id
                var importIndex = {};
                for (var i1 = 0, l1 = importArray.length; i1 < l1; i1++) {
                    var item = importArray[i1];
                    importIndex[item._id] = item;
                }
                // add the indexed object to the current context
                adapt[name] = importIndex;
            }

            return "";

        },

        /**
         * Allow components to fetch their component description.
         */
        component_description: function(override, context) {
            if (!this._isA11yComponentDescriptionEnabled) return;
            if (!this._globals._components || !this._globals._components['_'+this._component]) return;
            var hasOverride = (arguments.length > 1);
            var description;
            if (hasOverride) {
                description = override;
                description = helpers.compile(description, context);
            } else {
                description = this._globals._components['_'+this._component].ariaRegion;
                description = helpers.compile(description, override);
            }
            if (!description) return;
            return new Handlebars.SafeString('<div class="aria-label">'+description+'</div>');
        }

    };

    // Compatibility references
    helpers['if_value_equals'] = helpers['equals'];
    helpers['numbers'] = helpers['inc'];
    helpers['lowerCase'] = helpers['lowercase'];

    for (var name in helpers) {
        if (helpers.hasOwnProperty(name)) {
             Handlebars.registerHelper(name, helpers[name]);
        }
    }

    return helpers;

});

define('core/js/scrolling',[
    'core/js/adapt'
], function(Adapt) {

    var Scrolling = Backbone.Controller.extend({

        $html: null,
        $app: null,
        isLegacyScrolling : true,

        initialize: function() {
            this._checkApp();
            Adapt.once('configModel:loadCourseData', this._loadConfig.bind(this));
        },

        _checkApp: function() {
            this.$html = $('html');
            this.$app = $('#app');
            if (this.$app.length) return;
            this.$app = $('<div id="app">');
            $('body').append(this.$app);
            this.$app.append($('#wrapper'));
            Adapt.log.warn("UPDATE - Your html file needs to have #app adding. See https://github.com/adaptlearning/adapt_framework/issues/2168");
        },

        _loadConfig: function() {
            var config = Adapt.config.get("_scrollingContainer");
            if (!config || !config._isEnabled) return;
            var limitTo = config._limitToSelector;
            var isIncluded = !limitTo || (this.$html.is(limitTo) || this.$html.hasClass(limitTo));
            if (!isIncluded) return;
            this.isLegacyScrolling = false;
            this._addStyling();
            this._fixJQuery();
            this._fixScrollTo();
            this._fixBrowser();
        },

        _addStyling: function() {
            this.$html.addClass("adapt-scrolling");
        },

        _fixJQuery: function() {
            var selectorScrollTop = $.fn.scrollTop;
            var $app = Adapt.scrolling.$app;
            $.fn.scrollTop = function() {
                if (this[0] === window || this[0] === document.body) {
                    return selectorScrollTop.apply($app, arguments);
                }
                return selectorScrollTop.apply(this, arguments);
            };
            var selectorOffset = $.fn.offset;
            $.fn.offset = function() {
                var $app = Adapt.scrolling.$app;
                var $element = this;
                var elementOffset = selectorOffset.call($element);
                var isCorrectedContainer = $element.parents().add($element).filter('html,body,#app').length;
                if (!isCorrectedContainer) {
                    // Do not adjust the offset measurement as not in $app container and isn't html or body
                    return elementOffset;
                }
                // Adjust measurement by scrolling and offset of $app container
                var scrollTop = parseInt($app.scrollTop());
                var scrollLeft = parseInt($app.scrollLeft());
                var appOffset = selectorOffset.call($app);
                elementOffset.top += (scrollTop - appOffset.top);
                elementOffset.left += (scrollLeft - appOffset.left);
                return elementOffset;
            };
        },

        _fixScrollTo: function() {
            var selectorScrollTo = $.fn.scrollTo;
            var scrollTo = $.scrollTo;
            var $app = Adapt.scrolling.$app;
            $.fn.scrollTo = function(target, duration, settings) {
                if (this[0] === window || this[0] === document.body) {
                    return selectorScrollTo.apply($app, arguments);
                }
                return selectorScrollTo.apply(this, arguments);
            };
            $.scrollTo = function(target, duration, settings) {
                return selectorScrollTo.apply($app, arguments);
            };
            _.extend($.scrollTo, scrollTo);
        },

        _fixBrowser: function() {
            var app = Adapt.scrolling.$app[0];
            window.scrollTo = function(x, y) {
                app.scrollTop = y || 0;
                app.scrollLeft = x || 0;
            };
            var $window = $(window);
            this.$app.on("scroll", function() {
                $window.scroll();
            });
        }

    });

    Adapt.scrolling = new Scrolling();

    Adapt.scrollTo = function(selector, settings) {
        // Get the current location - this is set in the router
        var location = (Adapt.location._contentType) ?
            Adapt.location._contentType : Adapt.location._currentLocation;
        // Trigger initial scrollTo event
        Adapt.trigger(location+':scrollTo', selector);
        //Setup duration variable passed upon arguments
        var settings = (settings || {});
        var disableScrollToAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;
        if (disableScrollToAnimation) {
            settings.duration = 0;
        }
        else if (!settings.duration) {
            settings.duration = $.scrollTo.defaults.duration;
        }

        var offsetTop = 0;
        if (Adapt.scrolling.isLegacyScrolling) {
            offsetTop = -$(".navigation").outerHeight();
            // prevent scroll issue when component description aria-label coincident with top of component
            if ($(selector).hasClass('component')) {
                offsetTop -= $(selector).find('.aria-label').height() || 0;
            }
        }

        if (!settings.offset) settings.offset = { top: offsetTop, left: 0 };
        if (settings.offset.top === undefined) settings.offset.top = offsetTop;
        if (settings.offset.left === undefined) settings.offset.left = 0;

        if (settings.offset.left === 0) settings.axis = "y";

        if (Adapt.get("_canScroll") !== false) {
            // Trigger scrollTo plugin
            $.scrollTo(selector, settings);
        }

        // Trigger an event after animation
        // 300 milliseconds added to make sure queue has finished
        _.delay(function() {
            $(selector).focusNext();
            Adapt.trigger(location+':scrolledTo', selector);
        }, settings.duration+300);
    };
    
});

define('core/js/views/headingView',[
    'core/js/adapt'
], function(Adapt) {

    var HeadingView = Backbone.View.extend({

        initialize: function() {
            this.listenTo(Adapt, "remove", this.remove);
            this.listenTo(this.model, "change:_isComplete", this.render);
            this.render();
        },

        render: function() {
            var template = Handlebars.templates[this.constructor.template];
            var data = this.model.toJSON();
            var customHeadingType = this.$el.attr('data-a11y-heading-type');
            if (customHeadingType) data._type = customHeadingType;
            this.$el.html(template(data));
            this.checkCompletion();
        },

        checkCompletion: function() {
            var isComplete = this.model.get("_isComplete");
            this.$el
            .toggleClass("complete", isComplete)
            .toggleClass("incomplete", !isComplete);
        }

    }, {
        template: 'heading'
    });

    return HeadingView;

});

define('core/js/headings',[
    './adapt',
    './views/headingView'
], function(Adapt, HeadingView) {

    var Headings = Backbone.Controller.extend({

        initialize: function() {
            var types = [ 'menu', 'page', 'article', 'block', 'component' ];
            var eventNames = types.concat(['']).join('View:render ');
            this.listenTo(Adapt, eventNames, this.onViewRender);
        },

        onViewRender: function(view) {
            var $headingSeats = view.$('.js-heading');
            $headingSeats.each(function(index, el) {
                new HeadingView({
                    el: el,
                    model: view.model
                });
            });
        }

    });

    return new Headings();

});



define('components/adapt-contrib-assessmentResults/js/assessmentResultsModel',[
    'core/js/adapt',
    'core/js/models/componentModel'
], function(Adapt, ComponentModel) {

    var AssessmentResultsModel = ComponentModel.extend({

        init: function() {
            this.set('originalBody', this.get('body'));// save the original body text so we can restore it when the assessment is reset

            this.listenTo(Adapt, {
                'assessments:complete': this.onAssessmentComplete,
                'assessments:reset': this.onAssessmentReset
            });
        },

        /**
         * Checks to see if the assessment was completed in a previous session or not
         */
        checkIfAssessmentComplete: function() {
            if (!Adapt.assessment || this.get('_assessmentId') === undefined) {
                return;
            }

            var assessmentModel = Adapt.assessment.get(this.get('_assessmentId'));
            if (!assessmentModel || assessmentModel.length === 0) return;

            var state = assessmentModel.getState();
            if (state.isComplete) {
                this.onAssessmentComplete(state);
                return;
            }

            this.setVisibility();
        },

        onAssessmentComplete: function(state) {
            if (this.get('_assessmentId') === undefined ||
                this.get('_assessmentId') != state.id) return;

            /*
            make shortcuts to some of the key properties in the state object so that
            content developers can just use {{attemptsLeft}} in json instead of {{state.attemptsLeft}}
            */
            this.set( {
                _state: state,
                attempts: state.attempts,
                attemptsSpent: state.attemptsSpent,
                attemptsLeft: state.attemptsLeft,
                score: state.score,
                scoreAsPercent: state.scoreAsPercent,
                maxScore: state.maxScore,
                isPass: state.isPass
            });

            this.setFeedbackBand(state);

            this.checkRetryEnabled(state);

            this.setFeedbackText();

            this.toggleVisibility(true);
        },

        setFeedbackBand: function(state) {
            var scoreProp = state.isPercentageBased ? 'scoreAsPercent' : 'score';
            var bands = _.sortBy(this.get('_bands'), '_score');

            for (var i = (bands.length - 1); i >= 0; i--) {
                var isScoreInBandRange =  (state[scoreProp] >= bands[i]._score);
                if (!isScoreInBandRange) continue;

                this.set('_feedbackBand', bands[i]);
                break;
            }
        },

        checkRetryEnabled: function(state) {
            var assessmentModel = Adapt.assessment.get(state.id);
            if (!assessmentModel.canResetInPage()) return false;

            var feedbackBand = this.get('_feedbackBand');
            var isRetryEnabled = (feedbackBand && feedbackBand._allowRetry) !== false;
            var isAttemptsLeft = (state.attemptsLeft > 0 || state.attemptsLeft === 'infinite');
            var showRetry = isRetryEnabled && isAttemptsLeft && (!state.isPass || state.allowResetIfPassed);

            this.set({
                _isRetryEnabled: showRetry,
                retryFeedback: showRetry ? this.get('_retry').feedback : ''
            });
        },

        setFeedbackText: function() {
            var feedbackBand = this.get('_feedbackBand');

            // ensure any handlebars expressions in the .feedback are handled...
            var feedback = feedbackBand ? Handlebars.compile(feedbackBand.feedback)(this.toJSON()) : '';

            this.set({
                feedback: feedback,
                body: this.get('_completionBody')
            });
        },

        setVisibility: function() {
            if (!Adapt.assessment) return;

            var isVisibleBeforeCompletion = this.get('_isVisibleBeforeCompletion') || false;
            var wasVisible = this.get('_isVisible');

            var assessmentModel = Adapt.assessment.get(this.get('_assessmentId'));
            if (!assessmentModel || assessmentModel.length === 0) return;

            var state = assessmentModel.getState();
            var isComplete = state.isComplete;
            var isAttemptInProgress = state.attemptInProgress;
            var attemptsSpent = state.attemptsSpent;
            var hasHadAttempt = (!isAttemptInProgress && attemptsSpent > 0);

            var isVisible = (isVisibleBeforeCompletion && !isComplete) || hasHadAttempt;

            if (!wasVisible && isVisible) isVisible = false;

            this.toggleVisibility(isVisible);
        },

        toggleVisibility: function (isVisible) {
            if (isVisible === undefined) {
                isVisible = !this.get('_isVisible');
            }

            this.set('_isVisible', isVisible, {pluginName: 'assessmentResults'});
        },

        checkCompletion: function() {
            if (this.get('_setCompletionOn') === 'pass' && !this.get('isPass')) {
                return;
            }

            this.setCompletionStatus();
        },

        /**
         * Handles resetting the component whenever its corresponding assessment is reset
         * The component can either inherit the assessment's reset type or define its own
         */
        onAssessmentReset: function(state) {
            if (this.get('_assessmentId') === undefined ||
                this.get('_assessmentId') != state.id) return;

            var resetType = this.get('_resetType');
            if (!resetType || resetType === 'inherit') {
                resetType = state.resetType || 'hard';// backwards compatibility - state.resetType was only added in assessment v2.3.0
            }
            this.reset(resetType, true);
        },

        reset: function() {
            this.set({
                body: this.get('originalBody'),
                state: null,
                feedback: '',
                _feedbackBand: null,
                retryFeedback: '',
                _isRetryEnabled: false
            });

            ComponentModel.prototype.reset.apply(this, arguments);
        }
    });

    return AssessmentResultsModel;

});

define('core/js/views/componentView',[
    'core/js/adapt',
    'core/js/views/adaptView'
], function(Adapt, AdaptView) {

    var ComponentView = AdaptView.extend({

        attributes: function() {
            if (!this.model.get("_isA11yRegionEnabled")) {
                return AdaptView.resultExtend('attributes', {}, this);
            }
            return AdaptView.resultExtend('attributes', {
                "aria-labelledby": this.model.get('_id')+"-heading",
                "role": "region"
            }, this);
        },

        className: function() {
            return [
                'component',
                this.model.get('_component') +'-component',
                this.model.get('_id'),
                this.model.get('_classes'),
                this.setVisibility(),
                this.setHidden(),
                'component-' + this.model.get('_layout'),
                'nth-child-' + this.model.get('_nthChild'),
                (this.model.get('_isComplete') ? 'completed' : '')
            ].join(' ');
        },

        renderState: function() {
            Adapt.log.warn("REMOVED - renderState is removed and moved to item title");
        },

        /**
         * Allows components that want to use inview for completion to set that up
         * @param {string} [inviewElementSelector] Allows to you to specify (via a selector) which DOM element to use for inview.
         * Defaults to `'.component-inner'` if not supplied.
         * @param {function} [callback] Allows you to specify what function is called when the component has been viewed, should
         * you want to perform additional checks before setting the component to completed - see adapt-contrib-assessmentResults
         * for an example. Defaults to `view.setCompletionStatus` if not specified.
         */
        setupInviewCompletion: function(inviewElementSelector, callback) {
            this.$inviewElement = this.$(inviewElementSelector || '.component-inner');
            this.inviewCallback = (callback || this.setCompletionStatus);

            this.$inviewElement.on('inview.componentView', this.onInview.bind(this));
        },

        removeInviewListener: function() {
            if (!this.$inviewElement) return;
            this.$inviewElement.off('inview.componentView');
            this.$inviewElement = null;
        },

        onInview: function(event, visible, visiblePartX, visiblePartY) {
            if (!visible) return;

            switch (visiblePartY) {
                case 'top':
                    this.hasSeenTop = true;
                    break;
                case 'bottom':
                    this.hasSeenBottom = true;
                    break;
                case 'both':
                    this.hasSeenTop = this.hasSeenBottom = true;
            }

            if (!this.hasSeenTop || !this.hasSeenBottom) return;

            this.inviewCallback();

            if (this.model.get('_isComplete')) {
                this.removeInviewListener();
            }
        },

        postRender: function() {},

        remove: function() {
            this.removeInviewListener();

            AdaptView.prototype.remove.call(this);
        }

    }, {
        type:'component'
    });

    return ComponentView;

});

define('components/adapt-contrib-assessmentResults/js/assessmentResultsView',[
    'core/js/adapt',
    'core/js/views/componentView'
], function(Adapt, ComponentView) {

    var AssessmentResultsView = ComponentView.extend({

        events: {
            'click .results-retry-button button': 'onRetryClicked'
        },

        preRender: function () {
            this.model.setLocking('_isVisible', false);

            this.listenTo(Adapt, 'preRemove', function () {
                this.model.unsetLocking('_isVisible');
            });

            this.listenTo(this.model, {
                'change:_feedbackBand': this.addClassesToArticle,
                'change:body': this.render
            });

            this.model.checkIfAssessmentComplete();
        },

        postRender: function() {
            this.setReadyStatus();
            this.setupInviewCompletion('.component-inner', this.model.checkCompletion.bind(this.model));
        },

        /**
         * Resets the state of the assessment and optionally redirects the user
         * back to the assessment for another attempt.
         */
        onRetryClicked: function() {
            var state = this.model.get('_state');

            Adapt.assessment.get(state.id).reset();

            if (this.model.get('_retry')._routeToAssessment === true) {
                Adapt.navigateToElement('.' + state.articleId);
            }
        },

        /**
         * If there are classes specified for the feedback band, apply them to the containing article
         * This allows for custom styling based on the band the user's score falls into
         */
        addClassesToArticle: function(model, value) {
            if (!value || !value._classes) return;

            this.$el.parents('.article').addClass(value._classes);
        }

    }, {
        template: 'assessmentResults'
    });

    return AssessmentResultsView;
});

define('components/adapt-contrib-assessmentResults/js/adapt-contrib-assessmentResults',[
    'core/js/adapt',
    './assessmentResultsModel',
    './assessmentResultsView'
], function(Adapt, AssessmentResultsModel, AssessmentResultsView) {

    return Adapt.register("assessmentResults", {
        model: AssessmentResultsModel,
        view: AssessmentResultsView
    });

});

define('components/adapt-contrib-graphic/js/adapt-contrib-graphic',[
    'core/js/adapt',
    'core/js/views/componentView',
    'core/js/models/componentModel'
], function(Adapt, ComponentView, ComponentModel) {

    var GraphicView = ComponentView.extend({

        preRender: function() {
            this.listenTo(Adapt, 'device:changed', this.resizeImage);

            this.checkIfResetOnRevisit();
        },

        postRender: function() {
            this.resizeImage(Adapt.device.screenSize, true);
        },

        checkIfResetOnRevisit: function() {
            var isResetOnRevisit = this.model.get('_isResetOnRevisit');

            if (isResetOnRevisit) {
                this.model.reset(isResetOnRevisit);
            }
        },

        resizeImage: function(width, setupInView) {
            var imageWidth = width === 'medium' ? 'small' : width;
            var imageSrc = (this.model.get('_graphic')) ? this.model.get('_graphic')[imageWidth] : '';
            this.$('.graphic-widget img').attr('src', imageSrc);

            this.$('.graphic-widget').imageready(function() {
                this.setReadyStatus();

                if (setupInView) {
                    this.setupInviewCompletion('.component-widget');
                }
            }.bind(this));
        }
    });

    return Adapt.register('graphic', {
        model: ComponentModel.extend({}),// create a new class in the inheritance chain so it can be extended per component type if necessary later
        view: GraphicView
    });

});

define('core/js/views/buttonsView',[
    'core/js/adapt',
    'core/js/enums/buttonStateEnum'
], function(Adapt, BUTTON_STATE) {

    //convert BUTTON_STATE to property name
    var textPropertyName = {
        "SUBMIT": "submit",
        "CORRECT": "correct",
        "INCORRECT": "incorrect",
        "SHOW_CORRECT_ANSWER": "showCorrectAnswer",
        "HIDE_CORRECT_ANSWER": "hideCorrectAnswer",
        "SHOW_FEEDBACK": "showFeedback",
        "RESET": "reset"
    };

    var ButtonsView = Backbone.View.extend({

        initialize: function(options) {
            this.parent = options.parent;

            this.listenTo(Adapt, 'remove', this.remove);
            this.listenTo(this.model, 'change:_buttonState', this.onButtonStateChanged);
            this.listenTo(this.model, 'change:feedbackMessage', this.onFeedbackMessageChanged);
            this.listenTo(this.model, 'change:_attemptsLeft', this.onAttemptsChanged);
            this.render();
        },

        events: {
            'click .buttons-action': 'onActionClicked',
            'click .buttons-feedback': 'onFeedbackClicked'
        },

        render: function() {
            var data = this.model.toJSON();
            var template = Handlebars.templates['buttons'];
            _.defer(_.bind(function() {
                this.postRender();
                Adapt.trigger('buttonsView:postRender', this);
            }, this));
            this.$el.html(template(data));
        },

        postRender: function() {
            this.refresh();
        },

        checkResetSubmittedState: function() {
            var isSubmitted = this.model.get('_isSubmitted');

            if (!isSubmitted) {

                var $icon = this.$('.buttons-marking-icon');
                $icon.removeClass('icon-cross');
                $icon.removeClass('icon-tick');
                $icon.addClass('display-none');
                this.$el.removeClass("submitted");
                this.model.set('feedbackMessage', undefined);
                this.$('.buttons-feedback').a11y_cntrl_enabled(false);

            } else {

                this.$el.addClass("submitted");

            }
        },

        onActionClicked: function() {
            var buttonState = this.model.get('_buttonState');
            this.trigger('buttons:stateUpdate', BUTTON_STATE(buttonState));
            this.checkResetSubmittedState();
        },

        onFeedbackClicked: function() {
            this.trigger('buttons:stateUpdate', BUTTON_STATE.SHOW_FEEDBACK);
        },

        onFeedbackMessageChanged: function(model, changedAttribute) {
            if (changedAttribute && this.model.get('_canShowFeedback')) {
                //enable feedback button
                this.$('.buttons-feedback').a11y_cntrl_enabled(true);
            } else {
                //disable feedback button
                this.$('.buttons-feedback').a11y_cntrl_enabled(false);
            }
        },

        onButtonStateChanged: function(model, changedAttribute) {

            this.updateAttemptsCount();

            // Use 'correct' instead of 'complete' to signify button state
            var $buttonsAction = this.$('.buttons-action');
            var buttonState = BUTTON_STATE(changedAttribute);
            if (changedAttribute === BUTTON_STATE.CORRECT || changedAttribute === BUTTON_STATE.INCORRECT) {
                // Both 'correct' and 'incorrect' states have no model answer, so disable the submit button

                $buttonsAction.a11y_cntrl_enabled(false);

            } else {

                var propertyName = textPropertyName[buttonState.asString];
                var ariaLabel = this.model.get('_buttons')["_" + propertyName].ariaLabel;
                var buttonText = this.model.get('_buttons')["_" + propertyName].buttonText;

                // Enable the button, make accessible and update aria labels and text
                $buttonsAction.a11y_cntrl_enabled(true).html(buttonText).attr('aria-label', ariaLabel);

                // Make model answer button inaccessible (but still enabled) for visual users due to
                // the inability to represent selected incorrect/correct answers to a screen reader, may need revisiting
                switch (changedAttribute) {
                    case BUTTON_STATE.SHOW_CORRECT_ANSWER:
                    case BUTTON_STATE.HIDE_CORRECT_ANSWER:

                        $buttonsAction.a11y_cntrl(false);
                }

            }
        },

        checkFeedbackState: function(){
            var canShowFeedback = this.model.get('_canShowFeedback');

            this.$('.buttons-action').toggleClass('buttons-action-fullwidth buttons-action-enlarge', !canShowFeedback);
            this.$('.buttons-feedback').toggleClass('no-feedback', !canShowFeedback);
            this.$('.buttons-marking-icon').toggleClass('no-feedback', !canShowFeedback);
        },

        updateAttemptsCount: function(model, changedAttribute) {
            var isInteractionComplete = this.model.get('_isInteractionComplete');
            var attemptsLeft = (this.model.get('_attemptsLeft')) ? this.model.get('_attemptsLeft') : this.model.get('_attempts');
            var isCorrect = this.model.get('_isCorrect');
            var shouldDisplayAttempts = this.model.get('_shouldDisplayAttempts');
            var attemptsString;

            this.checkResetSubmittedState();

            if (!isInteractionComplete && attemptsLeft != 0) {
                attemptsString = attemptsLeft + " ";
                if (attemptsLeft > 1) {
                    attemptsString += this.model.get('_buttons').remainingAttemptsText;
                } else if (attemptsLeft === 1){
                    attemptsString += this.model.get('_buttons').remainingAttemptText;
                }

            } else {
                this.$('.buttons-display-inner').addClass('visibility-hidden');
                this.showMarking();
            }

            if (shouldDisplayAttempts) {
                this.$('.buttons-display-inner').html(attemptsString);
            }

        },

        showMarking: function() {
            if (!this.model.get('_canShowMarking')) return;

            var isCorrect = this.model.get('_isCorrect');
            var ariaLabels = Adapt.course.get('_globals')._accessibility._ariaLabels;

            this.$('.buttons-marking-icon')
                .removeClass('display-none')
                .addClass(isCorrect ? 'icon-tick' : 'icon-cross')
                .attr('aria-label', isCorrect ? ariaLabels.answeredCorrectly : ariaLabels.answeredIncorrectly);
        },

        refresh: function() {
            this.updateAttemptsCount();
            this.checkResetSubmittedState();
            this.checkFeedbackState();
            this.onButtonStateChanged(null, this.model.get('_buttonState'));
            this.onFeedbackMessageChanged(null, this.model.get('feedbackMessage'));
        }

    });

    return ButtonsView;

});

define('core/js/views/questionView',[
    'core/js/adapt',
    'core/js/views/componentView',
    'core/js/views/buttonsView',
    'core/js/models/questionModel',
    'core/js/enums/buttonStateEnum'
], function(Adapt, ComponentView, ButtonsView, QuestionModel, BUTTON_STATE) {

    var useQuestionModelOnly = false;

    var QuestionView = ComponentView.extend({

        className: function() {
            return "component "
            + "question-component "
            + this.model.get('_component')
            + "-component " + this.model.get('_id')
            + " " + this.model.get('_classes')
            + " " + this.setVisibility()
            + " component-" + this.model.get('_layout')
            + " nth-child-" + this.model.get("_nthChild")
            + (this.model.get('_isComplete') ? ' completed' : '');
        },

        //////
        // Setup question types
        ////

        preRender: function() {
            // Setup listener for _isEnabled
            this.listenTo(this.model, 'change:_isEnabled', this.onEnabledChanged);

            this.listenTo(this.model, 'question:refresh', this.refresh);

            // Checks to see if the question should be reset on revisit
            this.checkIfResetOnRevisit();
            // This method helps setup default settings on the model
            this._runModelCompatibleFunction("setupDefaultSettings");
            // Blank method for setting up questions before rendering
            this.setupQuestion();

        },

        // Used in the question view to disabled the question when _isEnabled has been set to false
        onEnabledChanged: function(model, changedAttribute) {

            // If isEnabled == false add disabled class
            // else remove disabled class
            if (!changedAttribute) {
                this.$('.component-widget').addClass('disabled');
                this.disableQuestion();
            } else {
                this.$('.component-widget').removeClass('disabled');
                this.enableQuestion();
            }

        },

        // Used by the question to disable the question during submit and complete stages
        disableQuestion: function() {},

        // Used by the question to enable the question during interactions
        enableQuestion: function() {},

        // Used to check if the question should reset on revisit
        checkIfResetOnRevisit: function() {

            var isResetOnRevisit = this.model.get('_isResetOnRevisit');

            // If reset is enabled set defaults
            // Call blank method for question to handle
            if (isResetOnRevisit) {

                this.model.reset(isResetOnRevisit, true);

                 // Defer is added to allow the component to render
                _.defer(_.bind(function() {
                   this.resetQuestionOnRevisit(isResetOnRevisit);
                }, this));

            } else {

                // If complete - display users answer
                // or reset the question if not complete
                var isInteractionComplete = this.model.get('_isInteractionComplete');

                if (isInteractionComplete) {
                    this.model.set('_buttonState', BUTTON_STATE.HIDE_CORRECT_ANSWER);
                    // Defer is added to allow the component to render
                    _.defer(_.bind(function() {
                        this.onHideCorrectAnswerClicked();
                    }, this));

                } else {
                    this.model.set('_buttonState', BUTTON_STATE.SUBMIT);
                    // Defer is added to allow the component to render
                    _.defer(_.bind(function() {
                        this.onResetClicked();
                    }, this));
                }

            }

        },

        // Used by the question to reset the question when revisiting the component
        resetQuestionOnRevisit: function(type) {},

        // Left blank for question setup - should be used instead of preRender
        setupQuestion: function() {},

        // Calls default methods to setup after the question is rendered
        postRender: function() {
            this.addButtonsView();
            this.onQuestionRendered();
        },

        // Used to setup buttonsView and sets up the internal events for the question
        addButtonsView: function() {
            this.buttonsView = new ButtonsView({model: this.model, el: this.$('.buttons')});

            this.listenTo(this.buttonsView, 'buttons:stateUpdate', this.onButtonStateUpdate);

        },

        onButtonStateUpdate: function(button_state) {

            switch (button_state) {
                case BUTTON_STATE.SUBMIT:
                    this.onSubmitClicked();
                    break;
                case BUTTON_STATE.RESET:
                    this.onResetClicked();
                    break;
                case BUTTON_STATE.SHOW_CORRECT_ANSWER:
                    this.onShowCorrectAnswerClicked();
                    break;
                case BUTTON_STATE.HIDE_CORRECT_ANSWER:
                    this.onHideCorrectAnswerClicked();
                    break;
                case BUTTON_STATE.SHOW_FEEDBACK:
                    this.showFeedback();
                    break;
            }

        },

        // Blank method used just like postRender is for presentational components
        onQuestionRendered: function() {},

        //////
        // Submit process
        ////

        // Triggered when the submit button is clicked
        onSubmitClicked: function() {
            // canSubmit is setup in questions and should return a boolean
            // If the question stops the user form submitting - show instruction error
            // and give a blank method, onCannotSubmit to the question
            var canSubmit = this._runModelCompatibleFunction("canSubmit");

            if(!canSubmit) {
                this.showInstructionError();
                this.onCannotSubmit();
                return;
            }

            // Used to update the amount of attempts the question has
            this._runModelCompatibleFunction("updateAttempts");

            // Used to set attributes on the model after being submitted
            // Also adds a class of submitted
            this._runModelCompatibleFunction("setQuestionAsSubmitted");

            // Used to remove instruction error that is set when
            // the user has interacted in the wrong way
            this.removeInstructionError();

            // Used to store the users answer for later
            // This is a blank method given to the question
            this._runModelCompatibleFunction("storeUserAnswer");

            // Used to set question as correct:true/false
            // Calls isCorrect which is blank for the question
            // to fill out and return a boolean
            this._runModelCompatibleFunction("markQuestion", "isCorrect");

            // Used by the question to set the score on the model
            this._runModelCompatibleFunction("setScore");

            // Used by the question to display markings on the component
            this.showMarking();

            // Used to check if the question is complete
            // Triggers setCompletionStatus and adds class to widget
            this._runModelCompatibleFunction("checkQuestionCompletion");

            this.recordInteraction();

            // Used to setup the feedback by checking against
            // question isCorrect or isPartlyCorrect
            this._runModelCompatibleFunction("setupFeedback");

            // Used to trigger an event so plugins can display feedback
            // Do this before updating the buttons so that the focus can be
            // shifted immediately
            this.showFeedback();

            // Used to update buttonsView based upon question state
            // Update buttons happens before showFeedback to preserve tabindexes and after setupFeedback to allow buttons to use feedback attribute
            this._runModelCompatibleFunction("updateButtons");

            this.onSubmitted();
        },

        // Adds a validation error class when the canSubmit returns false
        showInstructionError: function() {
            this.$(".component-instruction-inner").addClass("validation-error");
            this.$el.a11y_focus();
        },

        // Blank method for question to fill out when the question cannot be submitted
        onCannotSubmit: function() {},

        // Blank method for question to fill out when the question was successfully submitted
        onSubmitted: function() {},

        // Used to set _isEnabled and _isSubmitted on the model
        // Also adds a 'submitted' class to the widget
        setQuestionAsSubmitted: function() {
            this.model.setQuestionAsSubmitted();
            this.$(".component-widget").addClass("submitted");
        },

        // Removes validation error class when the user canSubmit
        removeInstructionError: function() {
            this.$(".component-instruction-inner").removeClass("validation-error");
        },

        // This is important and should give the user feedback on how they answered the question
        // Normally done through ticks and crosses by adding classes
        showMarking: function() {},

        // Checks if the question should be set to complete
        // Calls setCompletionStatus and adds complete classes
        checkQuestionCompletion: function() {

            var isComplete = this.model.checkQuestionCompletion();

            if (isComplete) {
                this.$('.component-widget').addClass('complete show-user-answer');
            }

        },

        recordInteraction:function() {
            if (this.model.get('_recordInteraction') === true || !this.model.has('_recordInteraction')) {
                Adapt.trigger('questionView:recordInteraction', this);
            }
        },

        // Used to show feedback based upon whether _canShowFeedback is true
        showFeedback: function() {

            if (this.model.get('_canShowFeedback')) {
                Adapt.trigger('questionView:showFeedback', this);
            } else {
                Adapt.trigger('questionView:disabledFeedback', this);
            }

        },

        onResetClicked: function() {
            this.setQuestionAsReset();

            this._runModelCompatibleFunction("updateButtons");

            this._runModelCompatibleFunction("resetUserAnswer");

            this.resetQuestion();

            // onResetClicked is called as part of the checkIfResetOnRevisit
            // function and as a button click. if the view is already rendered,
            // then the button was clicked, focus on the first tabbable element
            if (!this.model.get("_isReady")) return;
            // Attempt to get the current page location
            var currentModel = Adapt.findById(Adapt.location._currentId);
            // Make sure the page is ready
            if (!currentModel || !currentModel.get("_isReady")) return;
            // Focus on the first readable item in this element
            this.$el.focusNext();

        },

        setQuestionAsReset: function() {
            this.model.setQuestionAsReset();
            this.$(".component-widget").removeClass("submitted");
        },

        // Used by the question view to reset the look and feel of the component.
        // This could also include resetting item data
        // This is triggered when the reset button is clicked so it shouldn't
        // be a full reset
        resetQuestion: function() {},

        refresh: function() {
            this.model.set('_buttonState', this.model.getButtonState());

            if (this.model.get('_canShowMarking') && this.model.get('_isInteractionComplete') && this.model.get('_isSubmitted')) {
                this.showMarking();
            }

            if (this.buttonsView) {
                _.defer(_.bind(this.buttonsView.refresh, this.buttonsView));
            }
        },

        onShowCorrectAnswerClicked: function() {
            this.setQuestionAsShowCorrect();

            this._runModelCompatibleFunction("updateButtons");

            this.showCorrectAnswer();
        },

        setQuestionAsShowCorrect: function() {
            this.$(".component-widget")
                .addClass("submitted show-correct-answer")
                .removeClass("show-user-answer");
        },

        // Used by the question to display the correct answer to the user
        showCorrectAnswer: function() {},

        onHideCorrectAnswerClicked: function() {
            this.setQuestionAsHideCorrect();

            this._runModelCompatibleFunction("updateButtons");

            this.hideCorrectAnswer();
        },

        setQuestionAsHideCorrect: function() {
            this.$(".component-widget")
                .addClass("submitted show-user-answer")
                .removeClass("show-correct-answer");
        },

        // Used by the question to display the users answer and
        // hide the correct answer
        // Should use the values stored in storeUserAnswer
        hideCorrectAnswer: function() {},

        // Time elapsed between the time the interaction was made available to the learner for response and the time of the first response
        getLatency:function() {
            return null;
        },

        // This function is overridden if useQuestionModeOnly: false. see below.
        _runModelCompatibleFunction: function(name, lookForViewOnlyFunction) {
            return this.model[name](); //questionModel Only
        }

    }, {
        _isQuestionType: true
    });


    //allows us to turn on and off the questionView style and use the separated questionModel+questionView style only
    if (useQuestionModelOnly) return QuestionView;

    /*BACKWARDS COMPATIBILITY SECTION
    * This section below is only for compatibility between the separated questionView+questionModel and the old questionView
    * Remove this section in when all components use questionModel and there is no need to have model behaviour in the questionView
    */

    var viewOnlyCompatibleQuestionView = {

        /* All of these functions have been moved to the questionModel.js file.
         * On the rare occasion that they have not been overridden by the component and
                that they call the view only questionView version,
                these functions are included as redirects to the new Question Model.
                It is very unlikely that these are needed but they are included to ensure compatibility.
         * If you need to override these in your component you should now make and register a component model.
         * Please remove them from your question component's view.
        */

            // Returns an object specific to the question type.
            getInteractionObject: function() {
                return this.model.getInteractionObject();
            },

            // Retturns a string detailing how the user answered the question.
            getResponse: function() {
                return this.model.getResponse();
            },

            // Returns a string describing the type of interaction: "choice" and "matching" supported (see scorm wrapper)
            getResponseType: function() {
                return this.model.getResponseType();
            },

            // Calls default methods to setup on questions
            setupDefaultSettings: function() {
                return this.model.setupDefaultSettings();
            },

            // Used to setup either global or local button text
            setupButtonSettings: function() {
                return this.model.setupButtonSettings();
            },

            // Used to setup either global or local question weight/score
            setupWeightSettings: function() {
                return this.model.setupWeightSettings();
            },

            // Use to check if the user is allowed to submit the question
            // Maybe the user has to select an item?
            canSubmit: function() {
                return this.model.canSubmit();
            },

            // Used to update the amount of attempts the user has left
            updateAttempts: function() {
                return this.model.updateAttempts();
            },

            // This is important for returning or showing the users answer
            // This should preserve the state of the users answers
            storeUserAnswer: function() {
                return this.model.storeUserAnswer();
            },

            // Used by the question view to reset the stored user answer
            resetUserAnswer: function() {
                return this.model.resetUserAnswer();
            },

            // Sets _isCorrect:true/false based upon isCorrect method below
            markQuestion: function() {

                if (this._isInViewOnlyCompatibleMode("isCorrect")) {

                    if (this.isCorrect()) {
                        this.model.set('_isCorrect', true);
                    } else {
                        this.model.set('_isCorrect', false);
                    }

                } else {
                    return this.model.markQuestion();
                }
            },

            // Should return a boolean based upon whether to question is correct or not
            isCorrect: function() {
                return this.model.isCorrect();
            },

            // Used to set the score based upon the _questionWeight
            setScore: function() {
                return this.model.setScore();
            },

            // Updates buttons based upon question state by setting
            // _buttonState on the model which buttonsView listens to
            updateButtons: function() {
                return this.model.updateButtons();
            },

            // Used to setup the correct, incorrect and partly correct feedback
            setupFeedback: function() {

                if (this._isInViewOnlyCompatibleMode("isPartlyCorrect")) {

                    // Use view based feedback where necessary
                    if (this.model.get('_isCorrect')) {
                        this._runModelCompatibleFunction("setupCorrectFeedback");
                    } else if (this.isPartlyCorrect()) {
                        this._runModelCompatibleFunction("setupPartlyCorrectFeedback");
                    } else {
                        this._runModelCompatibleFunction("setupIncorrectFeedback");
                    }

                } else {
                    // Use model based feedback
                    this.model.setupFeedback();
                }

            },

            // Used by the question to determine if the question is incorrect or partly correct
            // Should return a boolean
            isPartlyCorrect: function() {
                return this.model.isPartlyCorrect();
            },

            setupCorrectFeedback: function() {
                return this.model.setupCorrectFeedback();
            },

            setupPartlyCorrectFeedback: function() {
                return this.model.setupPartlyCorrectFeedback();
            },

            setupIncorrectFeedback: function() {
                return this.model.setupIncorrectFeedback();
            },


        //Helper functions for compatibility layer
        _runModelCompatibleFunction: function(name, lookForViewOnlyFunction) {
            if (this._isInViewOnlyCompatibleMode(name, lookForViewOnlyFunction)) {
                return this[name](); //questionView
            } else {
                return this.model[name](); //questionModel
            }
        },

        _isInViewOnlyCompatibleMode: function(name, lookForViewOnlyFunction) {
            //return false uses the model function questionModel
            //return true uses the view only function questionView

            var checkForFunction = (lookForViewOnlyFunction || name);

            //if the function does NOT exist on the view at all, use the model only
            if (!this.constructor.prototype[checkForFunction]) return false; //questionModel

            //if the function DOES exist on the view and MATCHES the compatibility function above, use the model only
            if (this.constructor.prototype[checkForFunction] === viewOnlyCompatibleQuestionView[checkForFunction])  {
                switch (checkForFunction) {
                    case "setupFeedback":
                    case "markQuestion":
                        return true; //questionView
                }
                return false; //questionModel
            }

            //if the function DOES exist on the view and does NOT match the compatibility function above, use the view function
            return true; //questionView
        }

    };

    //return question view class extended with the compatibility layer
    return QuestionView.extend(viewOnlyCompatibleQuestionView, {
        _isQuestionType: true
    });

    /*END OF BACKWARDS COMPATIBILITY SECTION*/

});

define('components/adapt-contrib-mcq/js/mcqView',[
    'core/js/adapt',
    'core/js/views/questionView'
], function(Adapt, QuestionView) {

    var McqView = QuestionView.extend({

        events: {
            'focus .component-item input':'onItemFocus',
            'blur .component-item input':'onItemBlur',
            'change .component-item input':'onItemSelect',
            'keyup .component-item input':'onKeyPress'
        },

        isCorrectAnswerShown: false,

        initialize: function() {
            QuestionView.prototype.initialize.apply(this, arguments);
            this.update = _.debounce(this.update.bind(this), 1);
            this.listenTo(this.model, {
                "change:_isEnabled change:_isComplete change:_isSubmitted": this.update
            });
            this.listenTo(this.model.getChildren(), {
                "change:_isActive": this.update
            });
        },

        resetQuestionOnRevisit: function() {
            this.resetQuestion();
        },

        setupQuestion: function() {
            this.model.setupRandomisation();
        },

        onQuestionRendered: function() {
            this.setReadyStatus();
            this.update();
        },

        onKeyPress: function(event) {
            if (event.which !== 13) return;
            //<ENTER> keypress
            this.onItemSelect(event);
        },

        onItemFocus: function(event) {
            if (!this.model.isInteractive()) return;

            $('label[for='+$(event.currentTarget).attr('id')+']').addClass('highlighted');
        },

        onItemBlur: function(event) {
            $('label[for='+$(event.currentTarget).attr('id')+']').removeClass('highlighted');
        },

        onItemSelect: function(event) {
            if (!this.model.isInteractive()) return;

            var index = $(event.currentTarget).data('adapt-index');
            var itemModel = this.model.getItem(index);
            var shouldSelect = !itemModel.get("_isActive");

            if (this.model.isSingleSelect()) {
                // Assume a click is always a selection
                shouldSelect = true;
                this.model.resetActiveItems();
            } else if (shouldSelect && this.model.isAtActiveLimit()) {
                // At the selection limit, deselect the last item
                this.model.getLastActiveItem().toggleActive(false);
            }

            // Select or deselect accordingly
            itemModel.toggleActive(shouldSelect);
        },

        // Blank method to add functionality for when the user cannot submit
        // Could be used for a popup or explanation dialog/hint
        onCannotSubmit: function() {},

        // This is important and should give the user feedback on how they answered the question
        // Normally done through ticks and crosses by adding classes
        showMarking: function() {
            this.update();
        },

        // Used by the question view to reset the look and feel of the component.
        resetQuestion: function() {
            this.model.resetActiveItems();
            this.model.resetItems();
        },

        showCorrectAnswer: function() {
            this.isCorrectAnswerShown = true;
            this.update();
        },

        hideCorrectAnswer: function() {
            this.isCorrectAnswerShown = false;
            this.update();
        },

        update: function() {
            this.updateSelection();
            this.updateMarking();
        },

        updateSelection: function() {

            var isEnabled = this.model.get("_isEnabled");

            this.model.getChildren().each(function(itemModel) {

                var isSelected = this.isCorrectAnswerShown ?
                    itemModel.get("_shouldBeSelected") :
                    itemModel.get("_isActive");

                var index = itemModel.get('_index');
                this.$('label').filter('[data-adapt-index="' + index + '"]')
                    .toggleClass('selected', isSelected)
                    .toggleClass('disabled', !isEnabled);

                this.$('input').filter('[data-adapt-index="' + index + '"]')
                    .prop('checked', isSelected)
                    .prop('disabled', !isEnabled);

            }.bind(this));

        },

        updateMarking: function() {

            var isInteractive = this.model.isInteractive();
            var canShowMarking = this.model.get('_canShowMarking');
            var ariaLabels = Adapt.course.get('_globals')._accessibility._ariaLabels;

            this.model.getChildren().each(function(itemModel) {

                var index = itemModel.get('_index');
                var $itemInput = this.$('input').filter('[data-adapt-index="' + index + '"]');
                var $item = $itemInput.parents('.component-item');

                if (isInteractive || !canShowMarking) {
                    // Remove item marking
                    $item.removeClass('correct incorrect');
                    $itemInput.attr('aria-label', $.a11y_normalize(itemModel.get("text")));
                    return;
                }

                // Mark item
                var shouldBeSelected = itemModel.get("_shouldBeSelected");
                var isCorrect = Boolean(itemModel.get("_isCorrect"));
                var isActive = Boolean(itemModel.get("_isActive"));

                $item
                    .toggleClass('correct', isCorrect)
                    .toggleClass('incorrect', !isCorrect);

                $itemInput.attr('aria-label', [
                    (shouldBeSelected ? ariaLabels.correct : ariaLabels.incorrect),
                    ", ",
                    (isActive ? ariaLabels.selectedAnswer : ariaLabels.unselectedAnswer),
                    ". ",
                    $.a11y_normalize(itemModel.get("text"))
                ].join(""));

            }.bind(this));

        }

    });

    return McqView;

});

define('core/js/models/itemModel',[],function() {

    var ItemModel = Backbone.Model.extend({

        defaults: {
            _isActive: false,
            _isVisited: false
        },

        reset: function() {
            this.set({ _isActive: false, _isVisited: false });
        },

        toggleActive: function(isActive) {
            if (isActive === undefined) {
                isActive = !this.get('_isActive');
            }

            this.set('_isActive', isActive);
        },

        toggleVisited: function(isVisited) {
            if (isVisited === undefined) {
                isVisited = !this.get('_isVisited');
            }

            this.set('_isVisited', isVisited);
        }

    });

    return ItemModel;

});

define('core/js/models/itemsComponentModel',[
    'core/js/models/componentModel',
    'core/js/models/itemModel'
], function(ComponentModel, ItemModel) {

    var ItemsComponentModel = ComponentModel.extend({

        toJSON: function() {
            var json = _.clone(this.attributes);
            json._items = this.get('_children').toJSON();

            return json;
        },

        init: function() {
            this.setUpItems();

            this.listenTo(this.get('_children'), {
                'change:_isVisited': this.checkCompletionStatus
            });
        },

        setUpItems: function() {
            var items = this.get('_items');
            items.forEach(function(item, index) {
                item._index = index;
            });

            this.set('_children', new Backbone.Collection(items, { model: ItemModel }));
        },

        getItem: function(index) {
            return this.get('_children').findWhere({ _index: index });
        },

        getVisitedItems: function() {
            return this.get('_children').where({ _isVisited: true });
        },

        getActiveItems: function() {
            return this.get('_children').where({ _isActive: true });
        },

        getActiveItem: function() {
            return this.get('_children').findWhere({ _isActive: true });
        },

        areAllItemsCompleted: function() {
            return this.getVisitedItems().length === this.get('_children').length;
        },

        checkCompletionStatus: function() {
            if (this.areAllItemsCompleted()) {
                this.setCompletionStatus();
            }
        },

        reset: function(type, force) {
            this.get('_children').each(function(item) { item.reset(); });

            ComponentModel.prototype.reset.call(this, type, force);
        },

        resetActiveItems: function() {
            this.get('_children').each(function(item) { item.toggleActive(false); });
        },

        setActiveItem: function(index) {
            var activeItem = this.getActiveItem();
            if (activeItem) activeItem.toggleActive(false);
            this.getItem(index).toggleActive(true);
        }

    });

    return ItemsComponentModel;

});

define('core/js/models/itemsQuestionModel',[
    'core/js/adapt',
    'core/js/models/questionModel',
    'core/js/models/itemsComponentModel'
], function(Adapt, QuestionModel, ItemsComponentModel) {

    var BlendedModel = QuestionModel.extend(ItemsComponentModel.prototype);
    var ItemsQuestionModel = BlendedModel.extend({

        init: function() {
            QuestionModel.prototype.init.call(this);
            ItemsComponentModel.prototype.init.call(this);

            this.set('_isRadio', this.isSingleSelect());
        },

        restoreUserAnswers: function() {
            if (!this.get('_isSubmitted')) return;

            var itemModels = this.getChildren();
            var userAnswer = this.get('_userAnswer');
            itemModels.each(function(item, index) {
                item.toggleActive(userAnswer[item._index]);
            });

            this.setQuestionAsSubmitted();
            this.markQuestion();
            this.setScore();
            this.setupFeedback();
        },

        setupRandomisation: function() {
            if (!this.get('_isRandom') || !this.get('_isEnabled')) return;
            var children = this.getChildren();
            children.set(children.shuffle());
        },

        // check if the user is allowed to submit the question
        canSubmit: function() {
            var activeItems = this.getActiveItems();
            return activeItems.length > 0;
        },

        // This is important for returning or showing the users answer
        // This should preserve the state of the users answers
        storeUserAnswer: function() {
            var items = this.getChildren().slice(0);
            items.sort(function(a, b) {
                return a.get('_index') - b.get('_index');
            });

            var userAnswer = items.map(function(itemModel) {
                return itemModel.get('_isActive');
            });
            this.set('_userAnswer', userAnswer);
        },

        isCorrect: function() {

            var props = {
                _numberOfRequiredAnswers: 0,
                _numberOfIncorrectAnswers: 0,
                _isAtLeastOneCorrectSelection: false,
                _numberOfCorrectAnswers: 0,
            };

            this.getChildren().each(function(itemModel) {
                var itemShouldBeActive = itemModel.get('_shouldBeSelected');
                if (itemShouldBeActive) {
                    props._numberOfRequiredAnswers++;
                }

                if (!itemModel.get('_isActive')) return;

                if (!itemShouldBeActive) {
                    props._numberOfIncorrectAnswers++;
                    return;
                }

                props._isAtLeastOneCorrectSelection = true;
                props._numberOfCorrectAnswers++;
                itemModel.set('_isCorrect', true);
            });

            this.set(props);

            var hasRightNumberOfCorrectAnswers = (props._numberOfCorrectAnswers === props._numberOfRequiredAnswers);
            var hasNoIncorrectAnswers = !props._numberOfIncorrectAnswers;

            return hasRightNumberOfCorrectAnswers && hasNoIncorrectAnswers;
        },

        // Sets the score based upon the questionWeight
        // Can be overwritten if the question needs to set the score in a different way
        setScore: function() {
            var questionWeight = this.get('_questionWeight');
            var answeredCorrectly = this.get('_isCorrect');
            var score = answeredCorrectly ? questionWeight : 0;
            this.set('_score', score);
        },

        setupFeedback: function() {
            if (!this.has('_feedback')) return;

            if (this.get('_isCorrect')) {
                this.setupCorrectFeedback();
                return;
            }

            if (this.isPartlyCorrect()) {
                this.setupPartlyCorrectFeedback();
                return;
            }

            // apply individual item feedback
            var activeItem = this.getActiveItem();
            if (this.isSingleSelect() && activeItem.get('feedback')) {
                this.setupIndividualFeedback(activeItem);
                return;
            }

            this.setupIncorrectFeedback();
        },

        setupIndividualFeedback: function(selectedItem) {
            this.set({
                feedbackTitle: this.getFeedbackTitle(this.get('_feedback')),
                feedbackMessage: selectedItem.get("feedback")
            });
        },

        isPartlyCorrect: function() {
            return this.get('_isAtLeastOneCorrectSelection');
        },

        resetUserAnswer: function() {
            this.set('_userAnswer', []);
        },

        isAtActiveLimit: function() {
            var selectedItems = this.getActiveItems();
            return (selectedItems.length === this.get('_selectable'));
        },

        isSingleSelect: function() {
            return (this.get('_selectable') === 1);
        },

        getLastActiveItem: function(){
            var selectedItems = this.getActiveItems();
            return selectedItems[selectedItems.length-1];
        },

        resetItems: function() {
            this.resetActiveItems();
            this.set('_isAtLeastOneCorrectSelection', false);
        },

        getInteractionObject: function() {
            var interactions = {
                correctResponsesPattern: [],
                choices: []
            };

            interactions.choices = this.getChildren().map(function(itemModel) {
                return {
                    id: (itemModel.get('_index') + 1).toString(),
                    description: itemModel.get('text')
                };
            });

            var correctItems = this.getChildren().filter(function(itemModel) {
                return itemModel.get('_shouldBeSelected');
            });

            interactions.correctResponsesPattern = [
                correctItems.map(function(itemModel) {
                    // indexes are 0-based, we need them to be 1-based for cmi.interactions
                    return String(itemModel.get('_index') + 1);
                })
                .join('[,]')
            ];

            return interactions;
        },

        /**
        * used by adapt-contrib-spoor to get the user's answers in the format required by the cmi.interactions.n.student_response data field
        * returns the user's answers as a string in the format '1,5,2'
        */
        getResponse: function() {
            var activeItems = this.getActiveItems();
            var activeIndexes = activeItems.map(function(itemModel) {
                // indexes are 0-based, we need them to be 1-based for cmi.interactions
                return itemModel.get('_index') + 1;
            });
            return activeIndexes.join(',');
        },

        /**
        * used by adapt-contrib-spoor to get the type of this question in the format required by the cmi.interactions.n.type data field
        */
        getResponseType: function() {
            return 'choice';
        }

    });

    return ItemsQuestionModel;

});

define('components/adapt-contrib-mcq/js/adapt-contrib-mcq',[
    'core/js/adapt',
    './mcqView',
    'core/js/models/itemsQuestionModel'
], function(Adapt, McqView, ItemsQuestionModel) {

    return Adapt.register("mcq", {
        view: McqView,
        // Extend ItemsQuestionModel to distinguish McqModel in
        // the inheritance chain and allow targeted model extensions.
        model: ItemsQuestionModel.extend({})
    });

});

define('components/adapt-contrib-narrative/js/modeEnum',[],function() {

    return new ENUM([
        'SMALL',
        'LARGE'
    ]);

});

define('components/adapt-contrib-narrative/js/narrativeView',[
    'core/js/adapt',
    'core/js/views/componentView',
    './modeEnum'
], function(Adapt, ComponentView, MODE) {
    'use strict';

    var NarrativeView = ComponentView.extend({

        _isInitial: true,

        events: {
            'click .narrative-strapline-title': 'openPopup',
            'click .narrative-controls': 'onNavigationClicked',
            'click .narrative-indicators .narrative-progress': 'onProgressClicked'
        },

        preRender: function() {
            this.listenTo(Adapt, {
                'device:changed device:resize': this.reRender,
                'notify:closed': this.closeNotify
            });
            this.renderMode();

            this.listenTo(this.model.get('_children'), {
                'change:_isActive': this.onItemsActiveChange,
                'change:_isVisited': this.onItemsVisitedChange
            });

            this.checkIfResetOnRevisit();
            this.calculateWidths();
        },

        onItemsActiveChange: function(item, _isActive) {
            if (_isActive === true) {
                this.setStage(item);
            }
        },

        onItemsVisitedChange: function(item, isVisited) {
            if (!isVisited) return;
            this.$('[data-index="' + item.get('_index') + '"]').addClass('visited');
        },

        calculateMode: function() {
            var mode = Adapt.device.screenSize === 'large' ?
                MODE.LARGE :
                MODE.SMALL;
            this.model.set('_mode', mode);
        },

        renderMode: function() {
            this.calculateMode();
            if (this.isLargeMode()) {
                this.$el.addClass('mode-large').removeClass('mode-small');
            } else {
                this.$el.addClass('mode-small').removeClass('mode-large');
            }
        },

        isLargeMode: function() {
            return this.model.get('_mode') === MODE.LARGE;
        },

        postRender: function() {
            this.renderMode();
            this.setupNarrative();

            this.$('.narrative-slider').imageready(this.setReadyStatus.bind(this));

            if (Adapt.config.get('_disableAnimation')) {
                this.$el.addClass('disable-animation');
            }
        },

        checkIfResetOnRevisit: function() {
            var isResetOnRevisit = this.model.get('_isResetOnRevisit');
            // If reset is enabled set defaults
            if (isResetOnRevisit) {
                this.model.reset(isResetOnRevisit);
            }
        },

        setupNarrative: function() {
            this.renderMode();
            var items = this.model.get('_children');
            if (!items || !items.length) return;

            var activeItem = this.model.getActiveItem();
            if (!activeItem) {
                activeItem = this.model.getItem(0);
                activeItem.toggleActive(true);
            } else {
                // manually trigger change as it is not fired on reentry
                items.trigger('change:_isActive', activeItem, true);
            }

            this.calculateWidths();

            if (!this.isLargeMode() && !this.model.get('_wasHotgraphic')) {
                this.replaceInstructions();
            }
            this.setupEventListeners();
            this._isInitial = false;
        },

        calculateWidths: function() {
            var itemCount = this.model.get('_children').length;
            this.model.set({
                '_totalWidth': 100 * itemCount,
                '_itemWidth': 100 / itemCount
            });
        },

        resizeControl: function() {
            var previousMode = this.model.get('_mode');
            this.renderMode();
            if (previousMode !== this.model.get('_mode')) this.replaceInstructions();
            this.evaluateNavigation();
            var activeItem = this.model.getActiveItem();
            if (activeItem) this.setStage(activeItem);
        },

        reRender: function() {
            if (this.model.get('_wasHotgraphic') && this.isLargeMode()) {
                this.replaceWithHotgraphic();
            } else {
                this.resizeControl();
            }
        },

        closeNotify: function() {
            this.evaluateCompletion();
        },

        replaceInstructions: function() {
            if (this.isLargeMode()) {
                this.$('.narrative-instruction-inner').html(this.model.get('instruction'));
            } else if (this.model.get('mobileInstruction') && !this.model.get('_wasHotgraphic')) {
                this.$('.narrative-instruction-inner').html(this.model.get('mobileInstruction'));
            }
        },

        replaceWithHotgraphic: function() {
            if (!Adapt.componentStore.hotgraphic) throw "Hotgraphic not included in build";
            var HotgraphicView = Adapt.componentStore.hotgraphic.view;

            var model = this.prepareHotgraphicModel();
            var newHotgraphic = new HotgraphicView({ model: model });
            var $container = $(".component-container", $("." + this.model.get("_parentId")));

            $container.append(newHotgraphic.$el);
            this.remove();
            $.a11y_update();
            _.defer(function() {
                Adapt.trigger('device:resize');
            });
        },

        prepareHotgraphicModel: function() {
            var model = this.model;
            model.resetActiveItems();
            model.set({
                '_isPopupOpen': false,
                '_component': 'hotgraphic',
                'body': model.get('originalBody'),
                'instruction': model.get('originalInstruction')
            });

            return model;
        },

        moveSliderToIndex: function(itemIndex) {
            var offset = this.model.get('_itemWidth') * itemIndex;
            if (Adapt.config.get('_defaultDirection') === 'ltr') {
                offset *= -1;
            }
            var cssValue = 'translateX('+offset+'%)';
            var $sliderElm = this.$('.narrative-slider');
            var $straplineHeaderElm = this.$('.narrative-strapline-header-inner');

            $sliderElm.css('transform', cssValue);
            $straplineHeaderElm.css('transform', cssValue);

            if (Adapt.config.get('_disableAnimation') || this._isInitial) {
                this.onTransitionEnd();
            } else {
                $sliderElm.one('transitionend', this.onTransitionEnd.bind(this));
            }
        },

        onTransitionEnd: function() {
            if (this._isInitial) return;

            var index = this.model.getActiveItem().get('_index');
            if (this.isLargeMode()) {
                this.$('.narrative-content-item[data-index="'+index+'"]').a11y_focus();
            } else {
                this.$('.narrative-strapline-title').a11y_focus();
            }
        },

        setStage: function(item) {
            var index = item.get('_index');
            if (this.isLargeMode()) {
                // Set the visited attribute for large screen devices
                item.toggleVisited(true);
            }

            var $slideGraphics = this.$('.narrative-slider-graphic');
            this.$('.narrative-progress:visible').removeClass('selected').filter('[data-index="'+index+'"]').addClass('selected');
            $slideGraphics.children('.controls').a11y_cntrl_enabled(false);
            $slideGraphics.filter('[data-index="'+index+'"]').children('.controls').a11y_cntrl_enabled(true);
            this.$('.narrative-content-item').addClass('narrative-hidden').a11y_on(false).filter('[data-index="'+index+'"]').removeClass('narrative-hidden').a11y_on(true);
            this.$('.narrative-strapline-title').a11y_cntrl_enabled(false).filter('[data-index="'+index+'"]').a11y_cntrl_enabled(true);

            this.evaluateNavigation();
            this.evaluateCompletion();
            this.moveSliderToIndex(index);
        },

        evaluateNavigation: function() {
            var active = this.model.getActiveItem();
            if (!active) return;

            var currentStage = active.get('_index');
            var itemCount = this.model.get('_children').length;

            var isAtStart = currentStage === 0;
            var isAtEnd = currentStage === itemCount - 1;

            this.$('.narrative-control-left').toggleClass('narrative-hidden', isAtStart);
            this.$('.narrative-control-right').toggleClass('narrative-hidden', isAtEnd);
        },

        evaluateCompletion: function() {
            if (this.model.areAllItemsCompleted()) {
                this.trigger('allItems');
            }
        },

        openPopup: function(event) {
            event && event.preventDefault();

            var currentItem = this.model.getActiveItem();
            Adapt.trigger('notify:popup', {
                title: currentItem.get('title'),
                body: currentItem.get('body')
            });

            Adapt.on('popup:opened', function() {
                // Set the visited attribute for small and medium screen devices
                currentItem.toggleVisited(true);
            });
        },

        onNavigationClicked: function(event) {
            var stage = this.model.getActiveItem().get('_index');

            if ($(event.currentTarget).hasClass('narrative-control-right')) {
                this.model.setActiveItem(++stage);
            } else if ($(event.currentTarget).hasClass('narrative-control-left')) {
                this.model.setActiveItem(--stage);
            }
        },

        onProgressClicked: function(event) {
            event && event.preventDefault();
            var clickedIndex = $(event.target).data('index');
            this.model.setActiveItem(clickedIndex);
        },

        setupEventListeners: function() {
            if (this.model.get('_setCompletionOn') === 'inview') {
                this.setupInviewCompletion('.component-widget');
            }
        }

    });

    return NarrativeView;

});

define('components/adapt-contrib-narrative/js/adapt-contrib-narrative',[
    'core/js/adapt',
    './narrativeView',
    'core/js/models/itemsComponentModel'
], function(Adapt, NarrativeView, ItemsComponentModel) {

    return Adapt.register('narrative', {
        model: ItemsComponentModel,
        view: NarrativeView
    });

});

define('components/adapt-contrib-text/js/adapt-contrib-text',[
    'core/js/adapt',
    'core/js/views/componentView',
    'core/js/models/componentModel'
], function(Adapt, ComponentView, ComponentModel) {

    var TextView = ComponentView.extend({

        preRender: function() {
            this.checkIfResetOnRevisit();
        },

        postRender: function() {
            this.setReadyStatus();

            this.setupInview();
        },

        setupInview: function() {
            var selector = this.getInviewElementSelector();
            if (!selector) {
                this.setCompletionStatus();
                return;
            }

            this.setupInviewCompletion(selector);
        },

        /**
         * determines which element should be used for inview logic - body, instruction or title - and returns the selector for that element
         */
        getInviewElementSelector: function() {
            if (this.model.get('body')) return '.component-body';

            if (this.model.get('instruction')) return '.component-instruction';

            if (this.model.get('displayTitle')) return '.component-title';

            return null;
        },

        checkIfResetOnRevisit: function() {
            var isResetOnRevisit = this.model.get('_isResetOnRevisit');

            // If reset is enabled set defaults
            if (isResetOnRevisit) {
                this.model.reset(isResetOnRevisit);
            }
        }
    },
    {
        template: 'text'
    });

    return Adapt.register('text', {
        model: ComponentModel.extend({}),// create a new class in the inheritance chain so it can be extended per component type if necessary later
        view: TextView
    });
});



/**
 * pageActions
 */
define('components/adapt-lmw-activity/js/handlers/pageActions',['require'],function(require) {
    return {
        /**
         * hideObject()
         */
        hideObject: function(page, event, it, data, objectName) {
            var self = this;
            var target = page.findObjectByName(objectName);
            if (target) {
                target.isHidden = true;
                target.$el.addClass('activity-object-hide');
            } else {
                throw ('Could not find object: ' + objectName);
            }
            it.next(false);
        },

        /**
         * showObject()
         */
        showObject: function(page, event, it, data, objectName) {
            var self = this;
            var target = page.findObjectByName(objectName);
            if (target) {
                target.isHidden = false;
                target.$el.removeClass('activity-object-hide');
            } else {
                throw ('Could not find object: ' + objectName);
            }
            it.next(false);
        },

        /**
         * disableObject()
         */
        disableObject: function(page, event, it, data, objectName) {
            var self = this;
            var target = page.findObjectByName(objectName);
            if (target) {
                target.$classObject.prop('disabled', true);
            } else {
                throw ('Could not find object: ' + objectName);
            }
            it.next(false);
        },

        /**
         * enableObject()
         */
        enableObject: function(page, event, it, data, objectName) {
            var self = this;
            var target = page.findObjectByName(objectName);
            if (target) {
                target.$classObject.prop('disabled', false);
            } else {
                throw ('Could not find object: ' + objectName);
            }
            it.next(false);
        },

        /**
         * setObjectFocus()
         */
        setObjectFocus: function(page, event, it, data, objectName) {
            var self = this;
            var target = page.findObjectByName(objectName);
            if (target) {
                target.$classObject.focus().val(target.text);
            } else {
                throw ('Could not find object: ' + objectName);
            }
            it.next(false);
        },

        /**
         * setObjectValue()
         */
        setObjectValue: function(page, event, it, data, objectName, value) {
            var self = this;
            var target = page.findObjectByName(objectName);
            if (target) {
                target.$classObject.val(value);
            } else {
                throw ('Could not find object: ' + objectName);
            }
            it.next(false);
        },

        /**
         * highlightObject()
         */
        highlightObject: function(page, event, it, data, objectName) {
            var self = this;
            var target = page.findObjectByName(objectName);
            if (target) {
                target.$classObject.addClass('highlight');
            } else {
                throw ('Could not find object: ' + objectName);
            }
            it.next(false);
        },

        /**
         * triggerEvent()
         */
        triggerEvent: function(page, event, it, data, eventName) {
            var self = this;
            page.triggerEvent(eventName, function() {
                it.next(false);
            });
        },


        /**
         * enableEvent()
         */
        enableEvent: function(page, event, it, data, eventName) {
            var self = this;
            var target = page.findObjectEventByName(eventName);
            if (target) {
                target.isActive = true;
            }
            it.next(false);
        },

        /**
         * disableEvent()
         */
        disableEvent: function(page, event, it, data, eventName) {
            var self = this;
            var target = page.findObjectEventByName(eventName);
            if (target) {
                target.isActive = false;
            }
            it.next(false);
        },

        /**
         * gotoPage()
         */
        gotoPage: function(page, event, it, data, pageName) {
            var self = this;
            page.controller.showPage(pageName);
            it.next(true);
        },

        /**
         * showInstruction()
         */
        showInstruction: function(page, event, it, data, text) {
            var self = this;
            // don't print if previous instruction is the same
            var $list = page.$el.find('.activity-instructionList');
            var $curr = $list.find('li').last();
            if ($curr.html() !== text) {
                $list.append($('<li>').html(text));
            }
            it.next(false);
        },

        /**
         * showInstructionPrepend()
         */
        showInstructionPrepend: function(page, event, it, data, text) {
            var self = this;
            // don't print if previous instruction is the same
            var $list = page.$el.find('.activity-instructionList');
            var $curr = $list.find('li').last();
            if ($curr.html() !== text) {
                $list.prepend($('<li>').html(text));
            }
            it.next(false);
        },

        /**
         * clearAndShowInstruction()
         */
        clearAndShowInstruction: function(page, event, it, data, text) {
            var self = this;
            var $list = page.$el.find('.activity-instructionList');
            $list.empty();
            // don't print if previous instruction is the same
            var $curr = $list.find('li').last();
            if ($curr.html() !== text) {
                $list.append($('<li>').html(text));
            }
            it.next(false);
        },

        /**
         * clearInstructions()
         */
        clearInstructions: function(page, event, it, data) {
            var self = this;
            var $list = page.$el.find('.activity-instructionList');
            $list.empty();
            it.next(false);
        },

        /**
         * completeActivity()
         */
        completeActivity: function(page, event, it, data) {
            var self = this;
            page.controller.onActivityComplete();
            it.next(false);
        },

        /**
         * closeActivity()
         */
        closeActivity: function(page, event, it, data) {
            var self = this;
            page.controller.onActivityClose();
            it.next(true);
        },

        /**
         * wait()
         */
        wait: function(page, event, it, data, time) {
            var self = this;
            time = parseInt(time);
            if (time > 0) {
                page.activityTimeout = setTimeout(function() {
                    it.next(false);
                }, time);
            } else {
                it.next(false);
            }
        },

        /**
         * animateTyping()
         */
        animateTyping: function(page, event, it, data, objectName, text) {
            var self = this;
            var target = page.findObjectByName(objectName);
            if (target) {
                var time = data.animationDuration;
                if (time > 0 && text.length > 0) {
                    var count = 0;
                    var curr = '';
                    page.activityInterval = setInterval(function() {
                        if (count >= text.length) {
                            clearInterval(page.activityInterval);
                            it.next(false);
                        } else {
                            curr += text[count];
                            target.$classObject.val(curr);
                        }
                        count++;
                    }, time);
                } else {
                    target.$classObject.val(text);
                    it.next(false);
                }
            } else {
                throw ('Could not find object: ' + objectName);
            }
        },

        /**
         * animateObject()
         */
        animateObject: function(page, event, it, data, objectName) {
            var self = this;
            data.animationObject = objectName;
            it.next(false);
        },

        /**
         * animateDuration()
         */
        animateDuration: function(page, event, it, data, duration) {
            var self = this;
            data.animationDuration = parseFloat(duration);
            it.next(false);
        },

        /**
         * animateMoveTo()
         */
        animateMoveTo: function(page, event, it, data, objectName) {
            var self = this;
            data.animationTarget = objectName;
            page.triggerAnimation(function() {
                it.next(false);
            });
        },

        /**
         * consoleLog()
         */
        consoleLog: function(page, event, it, data, text) {
            var self = this;
            console.log(text);
            it.next(false);
        }
    };
});


/**
 * adapt-lmw-activity
 * pageView
 */
define('components/adapt-lmw-activity/js/handlers/pageView',['require','backbone','coreJS/adapt','./pageActions'],function(require) {
    var Backbone = require('backbone');
    var Adapt = require('coreJS/adapt');
    var PageActions = require('./pageActions');

    var PageView = Backbone.View.extend({
        events: {},
        objectTemplates: {
            button: {
                name: 'activityObjectButton',
                class: '.activity-object-button'
            },
            coordinate: {
                name: 'activityObjectCoordinate',
                class: '.activity-object-coordinate'
            },
            hotspot: {
                name: 'activityObjectHotspot',
                class: '.activity-object-hotspot'
            },
            sprite: {
                name: 'activityObjectSprite',
                class: '.activity-object-sprite'
            },
            text: {
                name: 'activityObjectText',
                class: '.activity-object-text'
            },
            textInput: {
                name: 'activityObjectTextInput',
                class: '.activity-object-textInput'
            },
            textInputArea: {
                name: 'activityObjectTextInputArea',
                class: '.activity-object-textInputArea'
            }
        },

        /**
         * initialize()
         */
        initialize: function() {
            var self = this;

            self.activityAnimationCurrent = null;
            self.activityTimeout = null;
            self.activityInterval = null;
            self.activityLocked = false;

            self.model.set('_data', {});
        },

        /**
         * reset()
         */
        reset: function() {
            var self = this;

            self.model.set('_data', {});            

            self.activityLocked = false;
            self.resetWorkers();

            // re-render model view
            self.render();
        },

        /**
         * resetWorkers
         */
        resetWorkers: function() {
            var self = this;

            if (self.activityAnimationCurrent) {
                // terminate currently playing animation
                self.activityAnimationCurrent.$el.stop(true);
            }
            if (self.activityTimeout) {
                // terminate timeout if in progress
                clearTimeout(self.activityTimeout);
            }
            if (self.activityInterval) {
                // terminate interval if in progress
                clearInterval(self.activityInterval);
            }
            self.activityAnimationCurrent = null;
            self.activityTimeout = null;
        },

        /**
         * preload()
         */
        preload: function(loaded) {
            var self = this;

            // create and preload page background image
            self.$pageImage = $('<img>');
            self.$pageImage.addClass('activity-frame-page-content-bg-image');
            self.$pageImage.attr('src', self.model.get('_backgroundImage'));
            self.$pageImage.on('load', loaded);
        },

        /**
         * render()
         */
        render: function() {
            var self = this;

            // build page html
            var template = Handlebars.templates['activityPage'];
            self.$el.html(template(self.model.toJSON()));

            // setup page content
            self.$page = self.$el.find('.activity-frame-page-content');
            self.$page.empty();  // remove all existing page elements
            self.$page.unbind(); // remove all existing events bound to page

            // setup background colour
            if (self.model.get('_backgroundColor')) {
                self.$page.css('background-color', self.model.get('_backgroundColor'));
            }

            // setup window event listeners
            $(window).off('keyup.activity').on('keyup.activity', function(event) {
                self.$page.trigger('activity:keyUp', [event.keyCode]);
            });
            $(window).off('resize.activity').on('resize.activity', function() {
                self.$page.trigger('activity:pageResize');
            });

            // setup wrapper scroll event listener
            self.$el.find('.activity-frame-page-wrapper').on('scroll.activity', function() {
                self.$page.trigger('activity:pageScroll');
            });

            // deactivate existing object states
            self.model.set('_objects', self.model.get('_objects').filter(function(it) {
                it.isActive = false;
                // remove existing page object
                return (it._name !== 'page');
            }));

            try {
                // setup objects/events
                self.setupPageObjectElements();
                self.setupPageObjectEvents();

                // setup background image element
                self.$page.append(self.$pageImage);

                // setup resize handler
                self.pageWidth = self.$page[0].clientWidth;
                self.pageHeight = self.$page[0].clientHeight;
                function resizeHandler() {
                    if (self.isActive()) {
                        let width = self.$page[0].clientWidth;
                        let height = self.$page[0].clientHeight;                
                        if (self.pageWidth !== width ||
                            self.pageHeight !== height) {
                            self.setupPageLayoutObjectsTransforms();
                            self.pageWidth = width;
                            self.pageHeight = height;
                        }
                        window.requestAnimationFrame(resizeHandler);
                    }
                }
                window.requestAnimationFrame(resizeHandler);
            } catch (ex) {
                console.error('[Activity]: ' + ex);
            }
        },

        /**
         * setupPageObjectElements()
         */
        setupPageObjectElements: function() {
            var self = this;

            var objects = self.model.get('_objects');

            // create default page object which we be used to listen to page events such as load and keyUp
            objects.unshift({
                '_name': 'page',
                'isActive': true,
                '$el': self.$page,
                '$classObject': self.$page,
                '_events': []
            });

            // setup activity page object structure
            objects.forEach(function(it) {
                // check if object name is unique
                if (!it.isActive) {
                    if (!self.findObjectByName(it._name)) {
                        // generate object html element if object type has available template
                        if (it._type in self.objectTemplates) {
                            it.isActive = true;
                            if (!('_originalPosition' in it)) {
                                it._originalPosition = $.extend({}, it._position);
                            }
                            it._position = $.extend({}, it._originalPosition);
                            it._template = self.objectTemplates[it._type];
                            template = Handlebars.templates[it._template.name];
                            var $html = $('<div>').html(template(it));
                            $html.css({left: it._position.x, top: it._position.y, position: 'absolute'});
                            $html.addClass('activity-object');
                            $html.attr('name', it._name);
                            it.$classObject = $html.find(it._template.class).first();
                            it._events = [];
                            it.isHidden = false;
                            if (it.$classObject.length > 0) {
                                if (it._classes) {
                                    it.$classObject.addClass(it._classes);
                                    it.$classObject.css({
                                        'width':  it._position.w,
                                        'height': it._position.h
                                    });
                                }
                            } else {
                                throw Error('Class object not defined: ' + it._template.class);
                            }
                            if (it._hidden) {
                                it.isHidden = true;
                                $html.addClass('activity-object-hide');
                            }
                            it.$el = $html;
                            self.$page.append($html);
                        }
                    } else {
                        throw Error(it._name + ' is already defined!');
                    }
                }
            });
        },

        /**
         * setupPageObjectEvents()
         */
        setupPageObjectEvents: function() {
            var self = this;

            var objectEvents =  self.model.get('_events');

            // setup activity page object events
            objectEvents.forEach(function(it) {
                it.isActive = !it._disabled;
                var trigger =  it._trigger;
                if (trigger) {
                    var object = self.findObjectByName(trigger._object);
                    if (object) {
                        // try to apply trigger event listener to specified object
                        var validEventTriggers = [
                            'activity:pageLoad',
                            'activity:pageResize',
                            'activity:keyUp',
                            'tap',
                            'doubletap',
                            'swipeleft',
                            'swiperight',
                            'swipe',
                            'taphold',
                            'click',
                            'dblclick',
                            'change',
                            'input'
                        ];

                        // check specified event handlers are valid
                        trigger.on = trigger.on.trim();
                        trigger.on.split(' ').forEach(function(value) {
                            if (!_.contains(validEventTriggers, value)) {
                                throw Error('Invalid event handler: ' + trigger.on);
                            } else {
                                if (!_.contains(object._events, value)) {
                                    object._events.push(value);
                                }
                            }
                        });

                        // add additional touch events for double click
                        if (_.contains(trigger.on, 'dblclick')) {
                            trigger.on += ' doubletap';
                        }

                        // attach event listnener to object (only allow one listener per event type)
                        object.$classObject.off(trigger.on).on(trigger.on, function(event, value) {
                            event.stopPropagation();
                            if (!object.isHidden) {
                                // check the correct object is being interacted with
                                if ($(event.target).is($(event.currentTarget))) {
                                    // check if this page view is active
                                    if (self.isActive() && !self.activityLocked) {
                                        // search for the event to trigger
                                        objectEvents.every(function(searchEvent) {
                                            if (searchEvent.isActive &&
                                                searchEvent._trigger &&
                                                searchEvent._trigger._object === trigger._object &&
                                                searchEvent._trigger.on === trigger.on) {
                                                if (searchEvent._trigger.key &&
                                                    searchEvent._trigger.key > 0) {
                                                    var fire = (searchEvent._trigger.key === value);
                                                    if (searchEvent._trigger.keyInvert) {
                                                        fire = (searchEvent._trigger.key !== value);
                                                    }
                                                    if (fire) {
                                                        self.activityLocked = true;
                                                        return !self.triggerEvent(searchEvent._name);
                                                    }
                                                } else {
                                                    self.activityLocked = true;
                                                    return !self.triggerEvent(searchEvent._name);
                                                }
                                            }
                                            return true;
                                        });                                            
                                    }
                                }
                            }
                        });
                    } else {
                        throw Error('Invalid object: ' + trigger._object);
                    }
                }
            });
        },

        /**
         * setupPageLayoutObjectsTransforms()
         */
        setupPageLayoutObjectsTransforms: function() {
            var self = this;

            var objects = self.model.get('_objects');

            var pb = self.$page[0].getBoundingClientRect();
            var pw = pb.width;
            var ph = pb.height;

            var hh = self.$el.find('.activity-frame-page-headbar ').height();

            var nw = self.$pageImage[0].naturalWidth;
            var nh = self.$pageImage[0].naturalHeight;

            var sh = ((nh*Math.min((pw/nw), (ph/nh)))-hh);

            self.$pageImage.height(sh);

            var ib = self.$pageImage[0].getBoundingClientRect();
            var ix = ib.left;
            var iy = ib.top;
            var iw = ib.width;
            var ih = ib.height;

            //console.log('%f %f | %f %f %f %f', pw, ph, ix, iy, iw, ih);
            
            // calculate scaling values
            var ir = Math.min((iw/nw), (ih/nh));

            // apply new styling attributes to all objects
            objects.forEach(function(it) {
                if (it._name === 'page') {
                    return; // ignore page object
                }

                it._scaling = ir;
                it.$el.css({
                    'left': ((it._position.x*it._scaling)+ix),
                    'top':  ((it._position.y*it._scaling)+iy)
                });
                it.$classObject.css({
                    'width': it._position.w,
                    'height': it._position.h,
                    '-webkit-transform': 'scale(' + it._scaling + ')',
                    '-webkit-transform-origin': 'top left',
                    '-ms-transform': 'scale(' + it._scaling + ')',
                    '-ms-transform-origin': 'top left',
                    'transform': 'scale(' + it._scaling + ')',
                    'transform-origin': 'top left',
                    'pointer-events': 'auto'
                });
            });
        },

        /**
         * triggerAudio()
         */
        triggerAudio: function(html, success) {
            // check if audio controller is present
            if (typeof window.AudioController !== 'undefined') {
                window.AudioController.play($('<span>').html(html)[0], [], success);
            } else if (_.isFunction(success)) {
                success();
            }
        },

        /**
         * triggerAnimation()
         */
        triggerAnimation: function(success) {
            var self = this;
            // setup jquery animation
            var animationObject = self.findObjectByName(self.model.get('_data').animationObject);
            var animationTarget = self.findObjectByName(self.model.get('_data').animationTarget);
            if (animationObject && animationTarget && !self.activityAnimationCurrent) {
                var animationDuration = (self.model.get('_data').animationDuration || 1000);
                var target = {
                    x: animationTarget.$classObject.offset().left,
                    y: animationTarget.$classObject.offset().top,
                    w: animationTarget.$classObject.width(),
                    h: animationTarget.$classObject.height()
                };
                animationObject.$el.animate({
                    'left': (target.x+target.w*animationTarget._scaling/2),
                    'top' : (target.y+target.h*animationTarget._scaling/2)
                }, animationDuration, function() {
                    // update object position
                    animationObject._position.x = (animationTarget._position.x+animationTarget._position.w/2);
                    animationObject._position.y = (animationTarget._position.y+animationTarget._position.h/2);
                    // complete animation
                    self.activityAnimationCurrent = null;
                    if (_.isFunction(success)) {
                        success();
                    }
                });
                self.activityAnimationCurrent = animationObject;
            } else {
                if (_.isFunction(success)) {
                    success();
                }
            }
        },

        /**
         * triggerEvent()
         */
        triggerEvent: function(name, success) {
            var self = this;
            var objectEvent = self.findObjectEventByName(name);
            try {
                if (objectEvent && objectEvent.isActive) {
                    // test if all event conditions have been met
                    var execute = true;
                    if (objectEvent._conditions) {
                        objectEvent._conditions.every(function(condition) {
                            var object = self.findObjectByName(condition._object);
                            if (object) {
                                // check if specified object meets the condition
                                var objectValue = object.$classObject.val();
                                // perform condition test
                                switch (condition.test) {
                                    case 'equal': {
                                        execute = (objectValue == condition.value);
                                    } break;
                                    case 'similar': {
                                        var v1 = objectValue.trim().toLowerCase();
                                        var v2 = condition.value.trim().toLowerCase();
                                        execute = (v1 == v2);
                                    } break;
                                    case 'notSimilar': {
                                        var v1 = objectValue.trim().toLowerCase();
                                        var v2 = condition.value.trim().toLowerCase();
                                        execute = (v1 != v2);
                                    } break;
                                    case 'greaterThan': {
                                        execute = (parseFloat(objectValue) > parseFloat(condition.value));
                                    } break;
                                    case 'greaterThanOrEqual': {
                                        execute = (parseFloat(objectValue) >= parseFloat(condition.value));
                                    } break;
                                    case 'lessThan': {
                                        execute = (parseFloat(objectValue) < parseFloat(condition.value));
                                    } break;
                                    case 'lessThanOrEqual': {
                                        execute = (parseFloat(objectValue) <= parseFloat(condition.value));
                                    } break;
                                    case 'notEqual': {
                                        execute = (objectValue != condition.value);
                                    } break;
                                    case 'regex': {
                                        var exp = new RegExp(condition.value, "g");
                                        execute = exp.test(objectValue);
                                    } break;
                                }
                            }
                            return execute;
                        });
                    }
                    // execute event actions
                    if (execute && self.activityLocked) {
                        var actionIterator = {
                            currentActionIndex: 0,
                            next: function(done) {
                                if (actionIterator.currentActionIndex < objectEvent._actions.length &&
                                    !done &&
                                    self.activityLocked) {
                                    var action = objectEvent._actions[actionIterator.currentActionIndex];
                                    actionIterator.currentActionIndex++;
                                    if (action._action in PageActions) {
                                        self.setupPageLayoutObjectsTransforms();
                                        // call current action handler function
                                        PageActions[action._action](
                                            self,
                                            objectEvent,
                                            actionIterator,
                                            self.model.get('_data'),
                                            action._args,
                                            action._argsParam);
                                    } else {
                                        throw Error('Invalid action: ' + action._action);
                                    }
                                } else {
                                    // if complete callback is specified then do not unlock activity as this
                                    // function is probably being called by a nested triggerEvent action
                                    if (_.isFunction(success)) {
                                        success();
                                    } else {
                                        self.activityLocked = false;
                                    }
                                }
                            }
                        };
                        // start iterating through actions
                        actionIterator.next(false);
                    } else {
                        if (_.isFunction(success)) {
                            success();
                        } else {
                            self.activityLocked = false;
                        }
                        return false;
                    }
                } else {
                    throw Error('Could not find event: ' + name);
                }
            } catch (ex) {
                console.error('[Activity]: ' + ex);
            }
            return true;
        },

        /**
         * findObjectByName()
         */
        findObjectByName: function(name) {
            var self = this;
            return _.findWhere(self.model.get('_objects'), {_name: name, isActive: true});
        },

        /**
         * findObjectByName()
         */
        findObjectEventByName: function(name) {
            var self = this;
            return _.findWhere(self.model.get('_events'),  {_name: name});
        },

        /**
         * isActive()
         */
        isActive: function() {
            var self = this;
            // return whether if the current page view is active (visible)
            return (self.controller &&
                    self.controller.isActive &&
                    self.controller.model.get('_currentPage') === self.model.get('_name'));
        }
    });
    return PageView;
});



/**
 * adapt-lmw-activity
 */
define('components/adapt-lmw-activity/js/adapt-lmw-activity',['require','backbone','coreViews/componentView','coreJS/adapt','./handlers/pageView'],function(require) {
    var Backbone = require('backbone');
    var ComponentView = require('coreViews/componentView');
    var Adapt = require('coreJS/adapt');
    var PageView = require('./handlers/pageView');

    var Component = ComponentView.extend({
        events: {
            'click .activity-start-button': 'onActivityStart',
            'click .activity-restart-button': 'onActivityRestart',
            'click .activity-close-button': 'onActivityClose'
        },

        /**
         * setupActivity()
         */
        setupActivity: function() {
            var self = this;

            // initialise activity
            self.isActive = false;
            self.isComplete = false;

            // check if we are on a mobile device
            self.isMobile = Adapt.device.touch || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

            self.pageCount = self.model.get('_pages').length;

            // initialise page views
            if (self.pageCount > 0) {
                var pagesPreloaded = 0;
                self.model.get('_pages').forEach(function(it, index) {
                    if (it._view) {
                        it._view.resetWorkers();
                    }

                    var model = new Backbone.Model(it);                
                    model.set('_component', self.model.toJSON());

                    it._view = new PageView({
                        model: model,
                        el: self.$('.activity-frame-page').eq(index)
                    });
                    it._view.controller = self;

                    // pre-load page assets
                    it._view.preload(function() {
                        pagesPreloaded++;
                        if (pagesPreloaded >= self.pageCount) {
                            self.setReadyStatus();
                        }
                    });
                });
            } else {
                self.setReadyStatus();
            }
        },

        /**
         * showPage()
         */
        showPage: function(name) {
            var self = this;

            // find page index
            var pages = self.model.get('_pages');
            if (pages.length > 0) {
                if (typeof name === 'undefined') {
                    name = pages[0]._name;
                }
                pages.forEach(function(page) {
                    if (page._name === name) {
                        if (self.model.get('_currentPageView')) {
                            self.model.get('_currentPageView').resetWorkers();
                        }
                        self.model.set('_currentPageView', page._view);
                        self.model.set('_currentPage', name);
                        page._view.reset();
                        page._view.$el.removeClass('activity-hide');
                        page._view.$page.trigger('activity:pageLoad');
                        page._view.$page.trigger('activity:pageResize');
                    } else {
                        page._view.$el.addClass('activity-hide');
                    }
                });
            } else {
                console.error('Activity has no pages');
            }
        },

        /**
         * preRender()
         */
        preRender: function() {
            var self = this;
        },

        /**
         * postRender()
         */
        postRender: function() {
            var self = this;
            // check if we need to show mobile alternative mode
            if (self.isMobile && self.model.get('_mobileAlternative')) {
                if (self.model.get('_mobileAlternativeCondition') === Adapt.device.screenSize ||
                    self.model.get('_mobileAlternativeCondition') === 'all') {
                    // hide activity
                    self.$el.find('.activity-widget').hide();
                    self.$el.find('.activity-start-button').hide();
                    self.setReadyStatus();
                    self.onActivityComplete(); // automatically set activity as complete
                } else {
                    self.$el.find('.activity-mobileAlternative').hide();
                    self.setupActivity();
                }
            } else {
                self.$el.find('.activity-mobileAlternative').hide();
                self.setupActivity();
            }
        },        

        /**
         * onActivityStart()
         */
        onActivityStart: function(event) {
            var self = this;
            
            event.preventDefault();
            if (!self.isActive) {
                self.isActive = true;

                self.$('.activity-container').show();

                self.showPage();
                self.lockScreen(true);
            }
        },

        /**
         * onActivityComplete()
         */
        onActivityComplete: function(event) {
            var self = this;
            self.isComplete = true;
            self.setCompletionStatus();
        },

        /**
         * onActivityRestart()
         */
        onActivityRestart: function(event) {
            var self = this;
            self.showPage();
        },

        /**
         * onActivityClose()
         */
        onActivityClose: function(event) {
            var self = this;
            self.isActive = false;
            self.$('.activity-container').hide();
            self.lockScreen(false);

            // trigger trickle (if present) if activity has been completed
            if (self.isComplete) {
                self.$el
                    .closest('.block')
                    .find('.trickle-button-inner > button')
                    .click();
            }
        },

        /**
         * lockScreen()
         */
        lockScreen: function(state) {
            var self = this;
            // prevent background from scrolling and maintain current scroll position
            if (state) {
                self.currentScrollPosition = $(window).scrollTop();
                $('html').addClass('activity-lockScreen');
            } else {
                $('html').removeClass('activity-lockScreen');
                $(window).scrollTop(self.currentScrollPosition);
            }
            return self.currentScrollPosition;
        }
    });

    Adapt.register('activity', Component);
    return Component;
});

/*
 * adapt-tf-photostory
 */
define('components/adapt-lmw-photostory/js/adapt-lmw-photostory',['require','coreViews/componentView','coreJS/adapt'],function(require) {
    var ComponentView = require('coreViews/componentView');
    var Adapt = require('coreJS/adapt');
    var Component = ComponentView.extend({
        /**
         *
         */
        events: {
            'click .photostory-item-next-button': 'onNextButtonClicked'
        },

        /**
         *
         */
        setupPhotostory: function() {
            var self = this;
            self.model.set('_stage_count', self.model.get('_items').length);
            if (self.model.get('_stage')) {
                self.setStoryStage(self.model.get('_stage'));
            } else {
                self.setStoryStage(0);
            }
        },

        /**
         *
         */
        preRender: function() {
            var self = this;
            // check if we need to reset story stage
            var isResetOnRevisit = self.model.get('_isResetOnRevisit');
            if (isResetOnRevisit) {
                self.model.reset(isResetOnRevisit);
                self.model.set('_stage', 0);
            }
        },

        /**
         *
         */
        postRender: function() {
            var self = this;
            // initialisation
            self.setReadyStatus();
            self.setupPhotostory();
        },

        /**
         *
         */
        setStoryStage: function(stage) {
            var self = this;
            // set visible states for all item elements based on current stage index
            self.$('.photostory-content-item').each(function(index, element) {
                var item = self.$(element).children('.photostory-content-item-slide');
                var next = self.$(element).children('.photostory-item-next-button');
                // add/remove .hide classes
                self.$(next).addClass('hide');
                if (index <= stage) {
                    self.$(item).removeClass('hide');
                } else {
                    self.$(item).addClass('hide');
                }
                if (index === (stage+1)) {
                    self.$(next).removeClass('hide');
                }
            });
            // set completion status if stage index beyond stage count
            if ((stage+1) >= self.model.get('_stage_count')) {
                self.setCompletionStatus();
            } else {
                self.model.set('_stage', stage);
            }
        },

        /**
         *
         */
        onNextButtonClicked: function(event) {
            var self = this;
            event.preventDefault();
            // show next story stage
            self.setStoryStage(self.model.get('_stage')+1);
        }
    });
    Adapt.register('photostory', Component);
    return Component;
});
define('extensions/adapt-contrib-assessment/js/adapt-assessmentArticleView',[
    'core/js/adapt',
    'core/js/views/articleView'
], function(Adapt, AdaptArticleView) {

    var AssessmentView = {

        postRender: function() {
            AdaptArticleView.prototype.postRender.call(this);
            if (this.model.isAssessmentEnabled()) {
                this._setupEventListeners();

                var config = this.model.getConfig();
                if (config && config._questions && config._questions._canShowMarking === false) {
                    this.$el.addClass('no-marking');
                }
            }
            this.$el.addClass('assessment');
        },

        _setupEventListeners: function() {
            this.listenTo(Adapt, {
                'assessments:complete': this._onAssessmentComplete,
                'assessments:reset': this._onAssessmentReset,
                remove: this._onRemove
            });
        },

        _removeEventListeners: function() {
            this.stopListening(Adapt, {
                'assessments:complete': this._onAssessmentComplete,
                'assessments:reset': this._onAssessmentReset
            });
        },

        _onAssessmentComplete: function(state, model) {
            if (state.id != this.model.get('_assessment')._id) return;

            console.log('assessment complete', state, model);
        },

        _onAssessmentReset: function(state, model) {
            if (state.id != this.model.get('_assessment')._id) return;

            console.log('assessment reset', state, model);

        },

        _onRemove: function() {
            this._removeEventListeners();
        }

    };

    return AssessmentView;

});

define('extensions/adapt-contrib-assessment/js/adapt-assessmentQuestionBank',['require'],function(require) {

    var QuestionBank = function(quizBankid, articleId, numQuestionBlocks, uniqueQuestions) {

        this._id = quizBankid;
        this._articleId = articleId;
        this._numQuestionBlocks = numQuestionBlocks;
        this._uniqueQuestions = uniqueQuestions;
        this.questionBlocks = [];
        this.unUsedQuestionBlocks = undefined;
        this.usedQuestionBlocks = [];

    };

    QuestionBank.prototype = {

        getID: function() {
            return this._id;
        },

        addBlock: function(block) {
            this.questionBlocks.push(block);
        },

        getRandomQuestionBlocks: function() {
            this.checkResetUnunsedBlocks();

            var questionBlocks = [];
            var usedQuestionBlocks = this.usedQuestionBlocks.slice(0);

            for (var i = 0; i < this._numQuestionBlocks; i++) {
                var question = this.getRandomQuestion();
                if (question !== undefined) {
                    questionBlocks.push(question);
                } else {
                    if (usedQuestionBlocks.length === 0) break;
                    var index = Math.floor(Math.random() * (usedQuestionBlocks.length-1));
                    question = usedQuestionBlocks.splice(index, 1)[0];
                    questionBlocks.push(question);
                }
            }

            return questionBlocks;
        },

        checkResetUnunsedBlocks: function() {
            if (this.unUsedQuestionBlocks !== undefined && this._uniqueQuestions) return;

            this.unUsedQuestionBlocks = this.questionBlocks.slice(0);
        },

        getRandomQuestion: function() {
            if (this.unUsedQuestionBlocks !== undefined && this.unUsedQuestionBlocks.length < 1) {
               console.warn('assessment:'+ this._articleId +' No more unique questions for _assessment._quizBankID ' + this._id);
               return undefined;
            }

            var index = Math.round(Math.random() * (this.unUsedQuestionBlocks.length-1));
            var questionBlock = this.unUsedQuestionBlocks[index];
            this.usedQuestionBlocks.push(questionBlock);

            this.unUsedQuestionBlocks.splice(index, 1);

            return questionBlock;
        }

    };

    return QuestionBank;

});
define('extensions/adapt-contrib-assessment/js/adapt-assessmentArticleModel',[
    'core/js/adapt',
    './adapt-assessmentQuestionBank'
], function(Adapt, QuestionBank) {


    var givenIdCount = 0;
    var assessmentConfigDefaults = {
        _isEnabled: true,
        _questions: {
            _resetType: 'soft',
            _canShowFeedback: false,
            _canShowMarking: false,
            _canShowModelAnswer: false
        },
        _suppressMarking: false,
        _isPercentageBased : true,
        _scoreToPass : 100,
        _includeInTotalScore: true,
        _assessmentWeight: 1,
        _isResetOnRevisit: true,
        _reloadPageOnReset: true,
        _attempts: 'infinite',
        _allowResetIfPassed: false
    };

    var AssessmentModel = {

    //Private functions

        _postInitialize: function() {
            if (!this.isAssessmentEnabled()) return;

            var assessmentConfig = this.getConfig();

            _.extend(this, {
                _currentQuestionComponents: null,
                _originalChildModels: null,
                _questionBanks: null,
                _forceResetOnRevisit: false
            });

            var attemptsLeft;
            switch (assessmentConfig._attempts) {
                case 'infinite': case 0: case undefined: case -1: case null:
                     attemptsLeft = 'infinite';
                    break;
                default:
                    attemptsLeft = assessmentConfig._attempts;
                    break;
            }

            this.set({
                _currentQuestionComponentIds: [],
                _assessmentCompleteInSession: false,
                _attemptInProgress: false,
                _isAssessmentComplete: false,
                _numberOfQuestionsAnswered: 0,
                _lastAttemptScoreAsPercent: 0,
                _attempts: attemptsLeft,
                _attemptsLeft: attemptsLeft,
                _attemptsSpent: 0
            });

            this.listenToOnce(Adapt, 'app:dataReady', this._onDataReady);
            this.listenTo(Adapt, 'remove', this._onRemove);

        },

        init: function() {
            //save original children
            this._originalChildModels = this.getChildren().models;
            //collect all question components
            this._currentQuestionComponents = this.findDescendantModels('components', {where: { _isQuestionType: true }});
            this.set('_currentQuestionComponentIds', this._currentQuestionComponents.map(function(comp) {
                return comp.get('_id');
            }));

            this._setAssessmentOwnershipOnChildrenModels();

        },

        _setAssessmentOwnershipOnChildrenModels: function() {
            //mark all children components as belonging to an assessment
            var assessmentConfig = this.get('_assessment');
            var childConfig = {
                _isPartOfAssessment: true,
                _assessmentId: assessmentConfig._id
            };
            for (var i = 0, l = this._originalChildModels.length; i < l; i++) {
                var blockModel = this._originalChildModels[i];
                blockModel.set(childConfig);
                //make sure components are set to _isPartOfAssessment for plp checking
                blockModel.setOnChildren(childConfig);
            }
        },


        _onDataReady: function() {
            //register assessment
            Adapt.assessment.register(this);
        },

        _setupAssessmentData: function(force, callback) {
            var assessmentConfig = this.getConfig();
            var state = this.getState();
            var shouldResetAssessment = (!this.get('_attemptInProgress') && !state.isPass) || force === true;
            var shouldResetQuestions = (assessmentConfig._isResetOnRevisit && (state.allowResetIfPassed || !state.isPass)) || force === true;

            if (shouldResetAssessment || shouldResetQuestions) {
                Adapt.trigger('assessments:preReset', this.getState(), this);
            }

            var quizModels;
            if (shouldResetAssessment) {
                this.set({
                    _numberOfQuestionsAnswered: 0,
                    _isAssessmentComplete: false,
                    _assessmentCompleteInSession: false,
                    _score: 0
                });
                this.getChildren().models = this._originalChildModels;
                if(assessmentConfig._banks &&
                        assessmentConfig._banks._isEnabled &&
                        assessmentConfig._banks._split.length > 1) {

                    quizModels = this._setupBankedAssessment();
                } else if(assessmentConfig._randomisation &&
                        assessmentConfig._randomisation._isEnabled) {

                    quizModels = this._setupRandomisedAssessment();
                }
            }

            if (!quizModels) {
                // leave the order as before, completed or not
                quizModels = this.getChildren().models;
            } else if ( quizModels.length === 0 ) {
                quizModels = this.getChildren().models;
                console.warn('assessment: Not enough unique questions to create a fresh assessment, using last selection');
            }

            this.getChildren().models = quizModels;

            this._currentQuestionComponents = this.findDescendantModels('components', {where: { _isQuestionType: true }});
            this.set('_currentQuestionComponentIds', this._currentQuestionComponents.map(function(comp) {
                return comp.get('_id');
            }));

            if (shouldResetAssessment || shouldResetQuestions) {
                this._resetQuestions(function() {
                    this.set('_attemptInProgress', true);
                    Adapt.trigger('assessments:reset', this.getState(), this);

                    finalise.apply(this);
                }.bind(this));
            } else {
                finalise.apply(this);
            }

            function finalise() {
                if (!state.isComplete) {
                    this.set('_attemptInProgress', true);
                }

                this._overrideQuestionComponentSettings();
                this._setupQuestionListeners();
                this._checkNumberOfQuestionsAnswered();
                this._updateQuestionsState();

                Adapt.assessment.saveState();

                if (typeof callback == 'function') callback.apply(this);

                if (shouldResetAssessment || shouldResetQuestions) {
                    Adapt.trigger('assessments:postReset', this.getState(), this);
                }
            }
        },

        _setupBankedAssessment: function() {
            var assessmentConfig = this.getConfig();

            this._setupBanks();

            //get random questions from banks
            var questionModels = [];
            for (var bankId in this._questionBanks) {
                if(this._questionBanks.hasOwnProperty(bankId)) { // skip over properties that were added to Array.prototype by the ES5-shim for IE8
                    var questionBank = this._questionBanks[bankId];
                    var questions = questionBank.getRandomQuestionBlocks();
                    questionModels = questionModels.concat(questions);
                }
            }

            //if overall question order should be randomized
            if (assessmentConfig._banks._randomisation) {
                questionModels = _.shuffle(questionModels);
            }

            return questionModels;
        },

        _setupBanks: function() {
            var assessmentConfig = this.getConfig();
            var banks = assessmentConfig._banks._split.split(',');
            var bankId;

            this._questionBanks = [];

            //build fresh banks
            for (var i = 0, l = banks.length; i < l; i++) {
                var bank = banks[i];
                bankId = (i + 1);
                var questionBank = new QuestionBank(bankId, this.get('_id'), bank, true);

                this._questionBanks[bankId] = questionBank;
            }

            //add blocks to banks
            var children = this.getChildren().models;
            for (var j = 0, count = children.length; j < count; j++) {
                var blockModel = children[j];
                var blockAssessmentConfig = blockModel.get('_assessment');
                bankId = blockAssessmentConfig._quizBankID;
                this._questionBanks[bankId].addBlock(blockModel);
            }

        },

        _setupRandomisedAssessment: function() {
            var assessmentConfig = this.getConfig();

            var randomisationModel = assessmentConfig._randomisation;
            var blockModels = this.getChildren().models;

            var questionModels = _.shuffle(blockModels);

            if (randomisationModel._blockCount > 0) {
                questionModels = questionModels.slice(0, randomisationModel._blockCount);
            }

            return questionModels;
        },

        _overrideQuestionComponentSettings: function() {
            var newSettings = this._getMarkingSettings();

            // Add any additional setting overrides here
            var questionConfig = this.getConfig()._questions;
            if (questionConfig.hasOwnProperty('_canShowFeedback')) {
                newSettings._canShowFeedback = questionConfig._canShowFeedback;
            }

            if (!_.isEmpty(newSettings)) {
                for (var i = 0, l = this._currentQuestionComponents.length; i < l; i++) {
                    this._currentQuestionComponents[i].set(newSettings, { pluginName: '_assessment' });
                }
            }
        },

        _setupQuestionListeners: function() {
            var questionComponents = this._currentQuestionComponents;
            for (var i = 0, l = questionComponents.length; i < l; i++) {
                var question = questionComponents[i];
                if (question.get('_isInteractionComplete')) continue;
                this.listenTo(question, 'change:_isInteractionComplete', this._onQuestionCompleted);
            }
        },

        _checkNumberOfQuestionsAnswered: function() {
            var questionComponents = this._currentQuestionComponents;
            var numberOfQuestionsAnswered = 0;
            for (var i = 0, l = questionComponents.length; i < l; i++) {
                var question = questionComponents[i];
                if (question.get('_isInteractionComplete')) {
                    numberOfQuestionsAnswered++;
                }
            }
            this.set('_numberOfQuestionsAnswered', numberOfQuestionsAnswered);
        },

        _removeQuestionListeners: function() {
            var questionComponents = this._currentQuestionComponents;
            if (!questionComponents) return;
            for (var i = 0, l = questionComponents.length; i < l; i++) {
                var question = questionComponents[i];
                this.stopListening(question, 'change:_isInteractionComplete', this._onQuestionCompleted);
            }
        },

        _onQuestionCompleted: function(questionModel, value) {
            if (value === false) return;
            if(!questionModel.get('_isInteractionComplete')) return;

            var numberOfQuestionsAnswered = this.get('_numberOfQuestionsAnswered');
            numberOfQuestionsAnswered++;
            this.set('_numberOfQuestionsAnswered', numberOfQuestionsAnswered);

            this._updateQuestionsState();
            Adapt.assessment.saveState();

            this._checkAssessmentComplete();
        },

        _checkAssessmentComplete: function() {
            var numberOfQuestionsAnswered = this.get('_numberOfQuestionsAnswered');

            var allQuestionsAnswered = numberOfQuestionsAnswered >= this._currentQuestionComponents.length;
            if (!allQuestionsAnswered) return;

            this._onAssessmentComplete();
        },

        _onAssessmentComplete: function() {
            var assessmentConfig = this.getConfig();

            this.set('_attemptInProgress', false);
            this._spendAttempt();

            var scoreAsPercent = this._getScoreAsPercent();
            var score = this._getScore();
            var maxScore = this._getMaxScore();

            this.set({
                _scoreAsPercent: scoreAsPercent,
                _score: score,
                _maxScore: maxScore,
                _lastAttemptScoreAsPercent: scoreAsPercent,
                _assessmentCompleteInSession: true,
                _isAssessmentComplete: true
            });

            this._updateQuestionsState();

            this._checkIsPass();

            this._removeQuestionListeners();

            if (this._isMarkingSuppressionEnabled() && !this._isAttemptsLeft()) {
                _.defer(function() {
                    this._overrideMarkingSettings();
                    this._refreshQuestions();
                }.bind(this));
            }

            Adapt.trigger('assessments:complete', this.getState(), this);
        },

        _updateQuestionsState: function() {
            var questions = [];

            var questionComponents = this._currentQuestionComponents;
            for (var i = 0, l = questionComponents.length; i < l; i++) {
                var questionComponent = questionComponents[i];

                var questionModel = {
                    _id: questionComponent.get('_id'),
                    _isCorrect: questionComponent.get('_isCorrect') === undefined ? null : questionComponent.get('_isCorrect')
                };

                //build array of questions
                questions.push(questionModel);

            }

            this.set('_questions', questions);
        },

        _checkIsPass: function() {
            var assessmentConfig = this.getConfig();

            var isPercentageBased = assessmentConfig._isPercentageBased;
            var scoreToPass = assessmentConfig._scoreToPass;

            var scoreAsPercent = this.get('_scoreAsPercent');
            var score = this.get('_score');

            var isPass = isPercentageBased ? (scoreAsPercent >= scoreToPass) : (score >= scoreToPass);

            this.set('_isPass', isPass);
        },

        _getMarkingSettings: function() {
            var markingSettings = {};

            if (this._shouldSuppressMarking()) {
                markingSettings = {
                    _canShowMarking: false,
                    _canShowModelAnswer: false
                };
            } else {
                var questionConfig = this.getConfig()._questions;

                if (questionConfig.hasOwnProperty('_canShowModelAnswer')) {
                    markingSettings._canShowModelAnswer = questionConfig._canShowModelAnswer;
                }

                if (questionConfig.hasOwnProperty('_canShowMarking')) {
                    markingSettings._canShowMarking = questionConfig._canShowMarking;
                }
            }

            return markingSettings;
        },

        _overrideMarkingSettings: function() {
            var newMarkingSettings = this._getMarkingSettings();
            for (var i = 0, l = this._currentQuestionComponents.length; i < l; i++) {
                this._currentQuestionComponents[i].set(newMarkingSettings, {
                    pluginName: '_assessment'
                });
            }
        },

        _refreshQuestions: function() {
            for (var a = 0, b = this._currentQuestionComponents.length; a < b; a++) {
                var question = this._currentQuestionComponents[a];
                question.refresh();
            }
        },

        _shouldSuppressMarking: function() {
            return this._isMarkingSuppressionEnabled() && this._isAttemptsLeft();
        },

        _isMarkingSuppressionEnabled: function() {
            var assessmentConfig = this.getConfig();
            return assessmentConfig._suppressMarking;
        },

        _isAttemptsLeft: function() {
            if (this.get('_isAssessmentComplete') && this.get('_isPass')) return false;

            if (this.get('_attemptsLeft') === 0) return false;

            return true;
        },

        _spendAttempt: function() {
            if (!this._isAttemptsLeft()) return false;

            var attemptsSpent = this.get('_attemptsSpent');
            this.set('_attemptsSpent', ++attemptsSpent);

            if (this.get('_attempts') == 'infinite') return true;

            var attemptsLeft = this.get('_attemptsLeft');
            this.set('_attemptsLeft', --attemptsLeft);

            return true;
        },

        _getScore: function() {
            var score = 0;
            var questionComponents = this._currentQuestionComponents;
            for (var i = 0, l = questionComponents.length; i < l; i++) {
                var question = questionComponents[i];
                if (question.get('_isCorrect') &&
                    question.get('_questionWeight')) {
                    score += question.get('_questionWeight');
                }
            }
            return score;
        },

        _getMaxScore: function() {
            var maxScore = 0;
            var questionComponents = this._currentQuestionComponents;
            for (var i = 0, l = questionComponents.length; i < l; i++) {
                var question = questionComponents[i];
                if (question.get('_questionWeight')) {
                    maxScore += question.get('_questionWeight');
                }
            }
            return maxScore;
        },

        _getScoreAsPercent: function() {
            if (this._getMaxScore() === 0) return 0;
            return Math.round((this._getScore() / this._getMaxScore()) * 100);
        },

        _getLastAttemptScoreAsPercent: function() {
            return this.get('_lastAttemptScoreAsPercent');
        },

        _checkReloadPage: function() {
            if (!this.canResetInPage()) return false;

            var parentId = this.getParent().get('_id');
            var currentLocation = Adapt.location._currentId;

            //check if on assessment page and should rerender page
            if (currentLocation != parentId) return false;
            if (!this.get('_isReady')) return false;

            return true;
        },

        _reloadPage: function() {
            this._forceResetOnRevisit = true;

            _.delay(function() {
                Backbone.history.navigate('#/id/' + Adapt.location._currentId, { replace:true, trigger: true });
            }, 250);
        },

        _resetQuestions: function(callback) {
            var assessmentConfig = this.getConfig();
            var syncIterations = 1; // number of synchronous iterations to perform
            var i = 0, qs = this._currentQuestionComponents, len = qs.length;

            function step() {
                for (var j = 0, count=Math.min(syncIterations, len-i); j < count; i++, j++) {
                    var question = qs[i];
                    question.reset(assessmentConfig._questions._resetType, true);
                }

                i == len ? callback() : setTimeout(step);
            }

            step();
        },

        _onRemove: function() {
            this._removeQuestionListeners();
        },

        _setCompletionStatus: function() {
            this.set({
                _isComplete: true,
                _isInteractionComplete: true
            });
        },

        _checkIfQuestionsWereRestored: function() {
            if (this.get('_assessmentCompleteInSession')) return;
            if (!this.get('_isAssessmentComplete')) return;

            //fix for courses that do not remember the user selections
            //force assessment to reset if user revisits an assessment page in a new session which is completed
            var wereQuestionsRestored = true;

            var questions = this.get('_questions');
            for (var i = 0, l = questions.length; i < l; i++) {
                var question = questions[i];
                var questionModel = Adapt.findById(question._id);
                if (!questionModel.get('_isSubmitted')) {
                    wereQuestionsRestored = false;
                    break;
                }
            }

            if (!wereQuestionsRestored) {
                this.set('_assessmentCompleteInSession', true);
                return true;
            }

            return false;
        },


    //Public Functions

        isAssessmentEnabled: function() {
            if (this.get('_assessment') &&
                this.get('_assessment')._isEnabled) return true;
            return false;
        },

        canResetInPage: function() {
            var assessmentConfig = this.getConfig();
            if (assessmentConfig._reloadPageOnReset === false) return false;
            return true;
        },

        reset: function(force, callback) {

            if (this._isResetInProgress) {
                // prevent multiple resets from executing.
                // keep callbacks in queue for when current reset is finished
                this.once('reset', function() {
                    this._isResetInProgress = false;
                    if (typeof callback == 'function') {
                        callback(true);
                    }
                });
                return;
            }

            var assessmentConfig = this.getConfig();

            //check if forcing reset via page revisit or force parameter
            force = this._forceResetOnRevisit || force === true;
            this._forceResetOnRevisit = false;

            var isPageReload = this._checkReloadPage();

            //stop resetting if not complete or not allowed
            if (this.get('_assessmentCompleteInSession') &&
                    !assessmentConfig._isResetOnRevisit &&
                    !isPageReload &&
                    !force) {
                if (typeof callback == 'function') {
                    callback(false);
                }
                return false;
            }

            //check if new session and questions not restored
            var wereQuestionsRestored = this._checkIfQuestionsWereRestored();
            force = force || wereQuestionsRestored;
            // the assessment is going to be reset so we must reset attempts
            // otherwise assessment may not be set up properly in next session
            if (force && !this._isAttemptsLeft()) {
                this.set({
                    _attemptsLeft: this.get('_attempts'),
                    _attemptsSpent: 0
                });
            }

            var allowResetIfPassed = this.get('_assessment')._allowResetIfPassed;
            //stop resetting if no attempts left and allowResetIfPassed is false
            if (!this._isAttemptsLeft() && !force && !allowResetIfPassed) {
                if (typeof callback == 'function') callback(false);
                return false;
            }

            if (!isPageReload) {
                // only perform this section when not attempting to reload the page
                // wait for reset to trigger
                this.once('reset', function() {
                    this._isResetInProgress = false;
                    if (typeof callback == 'function') {
                        callback(true);
                    }
                });
                this._isResetInProgress = true;
                // perform asynchronous reset
                this._setupAssessmentData(force, function() {
                    this.trigger('reset');
                });
            } else {
                this._reloadPage();
                if (typeof callback == 'function') {
                    callback(true);
                }
            }

            return true;
        },

        getSaveState: function() {
            var state = this.getState();
            var indexByIdQuestions = [];
            var cfg = this.getConfig();
            var banksActive = cfg._banks && cfg._banks._isEnabled && cfg._banks._split.length > 1;
            var randomisationActive = cfg._randomisation && cfg._randomisation._isEnabled;

            if (!banksActive && !randomisationActive) {
                // include presentation component IDs in save state so that blocks without questions aren't removed
                this.findDescendantModels('components').forEach(function(component) {
                    var componentModel = {
                        _id: component.get('_id'),
                        _isCorrect: component.get('_isCorrect') === undefined ? null : component.get('_isCorrect')
                    };

                    indexByIdQuestions.push(componentModel);

                });

                indexByIdQuestions = _.indexBy(indexByIdQuestions, '_id');
            } else {
                indexByIdQuestions = _.indexBy(state.questions, '_id');
            }

            for (var id in indexByIdQuestions) {
                if(indexByIdQuestions.hasOwnProperty(id)) {
                    indexByIdQuestions[id] = indexByIdQuestions[id]._isCorrect;
                }
            }

            var saveState = [
                state.isComplete ? 1:0,
                state.attemptsSpent,
                state.maxScore,
                state.score,
                state.attemptInProgress ? 1:0,
                indexByIdQuestions
            ];

            return saveState;
        },

        setRestoreState: function(restoreState) {
            var id;
            var isComplete = restoreState[0] == 1 ? true : false;
            var attempts = this.get('_attempts');
            var attemptsSpent = restoreState[1];
            var maxScore = restoreState[2];
            var score = restoreState[3];
            var attemptInProgress = restoreState[4] == 1 ? true : false;
            var scoreAsPercent;

            var indexByIdQuestions = restoreState[5];

            var blockIds = {};
            for (id in indexByIdQuestions) {
                if(indexByIdQuestions.hasOwnProperty(id)) {
                    var blockId = Adapt.findById(id).get('_parentId');
                    blockIds[blockId] = Adapt.findById(blockId);
                }
            }
            var restoredChildrenModels = _.values(blockIds);

            if (indexByIdQuestions) this.getChildren().models = restoredChildrenModels;


            this.set({
                _isAssessmentComplete: isComplete,
                _assessmentCompleteInSession: false,
                _attemptsSpent: attemptsSpent,
                _attemptInProgress: attemptInProgress,
                _attemptsLeft: (attempts === 'infinite' ? attempts : attempts - attemptsSpent),
                _maxScore: maxScore || this._getMaxScore(),
                _score: score || 0
            });

            if (score) {
                scoreAsPercent = Math.round( score / maxScore  * 100);
            } else {
                scoreAsPercent = 0;
            }

            this.set({
                _scoreAsPercent: scoreAsPercent,
                _lastAttemptScoreAsPercent: scoreAsPercent
            });

            var questions = [];
            for (id in indexByIdQuestions) {
                if(indexByIdQuestions.hasOwnProperty(id) && Adapt.findById(id).get('_isQuestionType')) {
                    questions.push({
                        _id: id,
                        _isCorrect: indexByIdQuestions[id]
                    });
                }
            }

            this.set('_questions', questions);

            if (isComplete) this._checkIsPass();

            Adapt.trigger('assessments:restored', this.getState(), this);

        },

        getState: function() {
            //return the current state of the assessment
            //create snapshot of values so as not to create memory leaks
            var assessmentConfig = this.getConfig();

            var state = {
                id: assessmentConfig._id,
                type: 'article-assessment',
                pageId: this.getParent().get('_id'),
                articleId: this.get('_id'),
                isEnabled: assessmentConfig._isEnabled,
                isComplete: this.get('_isAssessmentComplete'),
                isPercentageBased: assessmentConfig._isPercentageBased,
                scoreToPass: assessmentConfig._scoreToPass,
                score: this.get('_score'),
                scoreAsPercent: this.get('_scoreAsPercent'),
                maxScore: this.get('_maxScore'),
                isPass: this.get('_isPass'),
                includeInTotalScore: assessmentConfig._includeInTotalScore,
                assessmentWeight: assessmentConfig._assessmentWeight,
                attempts: this.get('_attempts'),
                attemptsSpent: this.get('_attemptsSpent'),
                attemptsLeft: this.get('_attemptsLeft'),
                attemptInProgress: this.get('_attemptInProgress'),
                lastAttemptScoreAsPercent: this.get('_lastAttemptScoreAsPercent'),
                questions: this.get('_questions'),
                resetType: assessmentConfig._questions._resetType,
                allowResetIfPassed: assessmentConfig._allowResetIfPassed,
                questionModels: new Backbone.Collection(this._currentQuestionComponents)
            };

            return state;
        },

        getConfig: function() {
            var assessmentConfig = this.get('_assessment');

            if (!assessmentConfig) {
                assessmentConfig = $.extend(true, {}, assessmentConfigDefaults);
            } else {
                assessmentConfig = $.extend(true, {}, assessmentConfigDefaults, assessmentConfig);
            }

            if (assessmentConfig._id === undefined) {
                assessmentConfig._id = 'givenId'+(givenIdCount++);
            }

            this.set('_assessment', assessmentConfig);

            return assessmentConfig;
        }

    };

    return AssessmentModel;
});

define('extensions/adapt-contrib-assessment/js/assessment',[
    'core/js/adapt'
], function(Adapt) {

    /*
        Here we setup a registry for all assessments
    */
    var assessmentsConfigDefaults = {
        _isPercentageBased: true,
        _scoreToPass: 100,
        _isDefaultsLoaded: true
    };

    Adapt.assessment = _.extend({

    //Private functions

        _assessments: _.extend([], {
            _byPageId: {},
            _byAssessmentId: {}
        }),

        initialize: function() {
            this.listenTo(Adapt, {
                'assessments:complete': this._onAssessmentsComplete,
                'router:location': this._checkResetAssessmentsOnRevisit,
                'router:plugin': this._handleRoute,
                'app:dataReady': this._onDataReady
            });
        },

        _onAssessmentsComplete: function(state) {
            var assessmentId = state.id;

            state.isComplete = true;

            if (assessmentId === undefined) return;

            if (!this._getStateByAssessmentId(assessmentId)) {
                Adapt.log.warn('assessments: state was not registered when assessment was created');
            }

            this.saveState();

            this._setPageProgress();

            this._checkAssessmentsComplete();

        },

        _restoreModelState: function(assessmentModel) {

            if (!this._saveStateModel) {
                this._saveStateModel = Adapt.offlineStorage.get('assessment');
            }
            if (this._saveStateModel) {
                var state = assessmentModel.getState();
                if (this._saveStateModel[state.id]) {
                    assessmentModel.setRestoreState(this._saveStateModel[state.id]);
                }
            }

        },

        /**
         * Allow navigating to an assessment via the URL.
         */
        _handleRoute: function(plugin, id) {
            if (plugin !== 'assessment' && plugin !== 'article-assessment' || id === undefined) {
                return;
            }

            // Check the 'id' passed is that of an article.
            if (!Adapt.findById(id)) {
                // The 'id' passed may have been the assessment _id/name, not the article _id.
                var assessment = Adapt.assessment._assessments._byAssessmentId[id];
                if (assessment) {
                    // Set 'id' to the article _id.
                    id = assessment.get('_id');
                } else {
                    Adapt.log.warn('Assessment not found with _id: ' + id);
                    return;
                }
            }

            _.defer(function() {
                // Defer this call so that the router's _canNavigate flag is true.
                Backbone.history.navigate('#/id/' + id, { trigger: true, replace: true });
            });
        },

        _checkResetAssessmentsOnRevisit: function(toObject) {
            /*
                Here we hijack router:location to reorganise the assessment blocks
                this must happen before trickle listens to block completion
            */
            if (toObject._contentType !== 'page') return;

            //initialize assessment on page visit before pageView:preRender (and trickle)
            var pageAssessmentModels = this._getAssessmentByPageId(toObject._currentId);
            if (pageAssessmentModels === undefined) return;

            /*
                Here we further hijack the router to ensure the asynchronous assessment
                reset completes before routing completes
            */
            Adapt.wait.for(function resetAllAssessments(allAssessmentHaveReset) {

                var numberOfAssessments = pageAssessmentModels.length;
                var numberOfResetAssessments = 0;
                var forceAssessmentReset = false;

                pageAssessmentModels.forEach(function(model) {

                    model.reset(forceAssessmentReset, function() {

                        numberOfResetAssessments++;
                        var haveAllModelsReset = (numberOfResetAssessments === numberOfAssessments);
                        if (!haveAllModelsReset) {
                            return;
                        }

                        allAssessmentHaveReset();

                    });

                });

            });

            this._setPageProgress();
        },

        _onDataReady: function() {
            this._assessments = _.extend([], {
                _byPageId: {},
                _byAssessmentId: {}
            });

            this._restoredCount = 0;
        },

        _checkAssessmentsComplete: function() {
            var allAssessmentsComplete = true;
            var assessmentToPostBack = 0;
            var states = this._getStatesByAssessmentId();

            var assessmentStates = [];

            for (var id in states) {
                var state = states[id];
                if (!state.includeInTotalScore) continue;
                if (!state.isComplete) {
                    allAssessmentsComplete = false;
                    break;
                }
                assessmentToPostBack++;
                assessmentStates.push(state);
            }

            if (!allAssessmentsComplete || assessmentToPostBack === 0) return false;

            if (assessmentToPostBack === 1) {
                this._setupSingleAssessmentConfiguration(assessmentStates[0]);
            }

            _.defer(function() {
                Adapt.trigger('assessment:complete', this.getState());
            }.bind(this));

            return true;
        },

        _setupSingleAssessmentConfiguration: function(assessmentState) {
            var assessmentsConfig = Adapt.course.get('_assessment');
            $.extend(true, assessmentsConfig, {
                _isPercentageBased: assessmentState.isPercentageBased,
                _scoreToPass: assessmentState.scoreToPass
            });
            Adapt.course.set('_assessment', assessmentsConfig);
        },

        _getAssessmentByPageId: function(pageId) {
            return this._assessments._byPageId[pageId];
        },

        _getStateByAssessmentId: function(assessmentId) {
            if (assessmentId === undefined) {
                return null;
            }

            return this._assessments._byAssessmentId[assessmentId].getState();
        },

        _getStatesByAssessmentId: function() {
            var states = {};
            for (var i = 0, l = this._assessments.length; i < l; i++) {
                var assessmentModel = this._assessments[i];
                var state = assessmentModel.getState();
                states[state.id] = state;
            }
            return states;
        },

        _setPageProgress: function() {
            //set _subProgressTotal and _subProgressComplete on pages that have assessment progress indicator requirements

            for (var k in this._assessments._byPageId) {

                var assessments = this._assessments._byPageId[k];

                var assessmentsTotal = assessments.length;
                var assessmentsPassed = 0;

                for (var i = 0, l = assessments.length; i < l; i++) {
                    var assessmentState = assessments[i].getState();

                    if (assessmentState.includeInTotalScore && !assessmentState.isPass) continue;

                    if (assessmentState.isComplete) {
                        assessmentsPassed++;
                    }
                }

                try {
                    var pageModel = Adapt.findById(k);
                    pageModel.set({
                        _subProgressTotal: assessmentsTotal,
                        _subProgressComplete: assessmentsPassed
                    });
                } catch(e) {

                }

            }
        },

        _addToAssessmentIdMap: function(id, model) {
            if (id === undefined) {
                Adapt.log.warn('An assessment has been registered with an undefined value for "_id"');
                return;
            }

            if (id === '') {
                Adapt.log.warn('An assessment has been registered with an empty value for "_id"');
            }

            if (!this._assessments._byAssessmentId[id]) {
                this._assessments._byAssessmentId[id] = model;
            } else {
                Adapt.log.warn('An assessment with an _id of "' + id + '" already exists!');
            }
        },

        _setupQuestionNumbering: function() {
            var getRelatedQuestions = function(data) {
                var currentAssessmentId = data._assessmentId;
                var currentAssessment =  Adapt.assessment.get(currentAssessmentId);
                return currentAssessment.getState().questions;
            };

            Handlebars.registerHelper('questionNumber', function getQuestionNumber() {
                var data = this.view ? this.view.model.toJSON() : this;
                if (!data._isPartOfAssessment) return;

                var related = _.pluck(getRelatedQuestions(data), '_id');

                return related.indexOf(data._id) + 1;
            });

            Handlebars.registerHelper('questionCount', function getTotalQuestions() {
                var data = this.view ? this.view.model.toJSON() : this;
                if (!data._isPartOfAssessment) return;
                return getRelatedQuestions(data).length;
            });
        },

    //Public functions

        register: function(assessmentModel) {
            var state = assessmentModel.getState();
            var assessmentId = state.id;
            var pageId = state.pageId;

            if (this._assessments._byPageId[pageId] === undefined) {
                this._assessments._byPageId[pageId] = [];
            }

            this._assessments._byPageId[pageId].push(assessmentModel);

            this._addToAssessmentIdMap(assessmentId, assessmentModel);

            this._assessments.push(assessmentModel);

            this._restoreModelState(assessmentModel);
            this._restoredCount++;

            Adapt.trigger('assessments:register', state, assessmentModel);

            this._setPageProgress();

            this._setupQuestionNumbering();

            if (this._restoredCount === this._assessments.length) {
                // Since all assessments have been stored, broadcast an
                // event which has the collated state.
                Adapt.trigger('assessment:restored', this.getState());
            }
        },

        get: function(id) {
            if (id === undefined) {
                return this._assessments.slice(0);
            } else {
                return this._assessments._byAssessmentId[id];
            }
        },

        saveState: function() {

            this._saveStateModel = {};
            for (var i = 0, assessmentModel; assessmentModel = this._assessments[i++];) {
                var state = assessmentModel.getState();
                this._saveStateModel[state.id] = assessmentModel.getSaveState();
            }

            Adapt.offlineStorage.set('assessment', this._saveStateModel);
        },

        getConfig: function () {
            var assessmentsConfig = Adapt.course.get('_assessment');

            if (assessmentsConfig && assessmentsConfig._isDefaultsLoaded) {
                return assessmentsConfig;
            }

            if (assessmentsConfig === undefined) {
                assessmentsConfig = $.extend(true, {}, assessmentsConfigDefaults);
            } else {
                assessmentsConfig = $.extend(true, {}, assessmentsConfigDefaults, assessmentsConfig);
            }

            Adapt.course.set('_assessment', assessmentsConfig);

            return assessmentsConfig;
        },

        getState: function() {
            var assessmentsConfig = this.getConfig();

            var score = 0;
            var maxScore = 0;
            var isPass = false;
            var totalAssessments = 0;

            var states = this._getStatesByAssessmentId();

            var assessmentsComplete = 0;

            for (var id in states) {
                var state = states[id];
                if (!state.includeInTotalScore) continue;
                if (state.isComplete) assessmentsComplete++;
                totalAssessments++;
                maxScore += state.maxScore / state.assessmentWeight;
                score += state.score / state.assessmentWeight;
            }

            var isComplete = assessmentsComplete == totalAssessments;

            var scoreAsPercent = Math.round((score / maxScore) * 100);

            if ((assessmentsConfig._scoreToPass || 100) && isComplete) {
                if (assessmentsConfig._isPercentageBased !== false) {
                    if (scoreAsPercent >= assessmentsConfig._scoreToPass) isPass = true;
                } else {
                    if (score >= assessmentsConfig._scoreToPass) isPass = true;
                }
            }

            return {
                isComplete: isComplete,
                isPercentageBased: assessmentsConfig._isPercentageBased,
                isPass: isPass,
                scoreAsPercent: scoreAsPercent,
                maxScore: maxScore,
                score: score,
                scoreToPass: assessmentsConfig._scoreToPass,
                assessmentsComplete: assessmentsComplete,
                assessments: totalAssessments
            };
        }

    }, Backbone.Events);

    Adapt.assessment.initialize();

});

define('extensions/adapt-contrib-assessment/js/adapt-assessmentArticleExtension',[
    'core/js/views/articleView',
    'core/js/models/articleModel',
    './adapt-assessmentArticleView',
    './adapt-assessmentArticleModel',
    './assessment'
], function(ArticleView, ArticleModel, AdaptAssessmentArticleView, AdaptAssessmentArticleModel) {

    /*
        Here we are extending the articleView and articleModel in Adapt.
        This is to accomodate the assessment functionality on the article.
        The advantage of this method is that the assessment behaviour can utilize all of the predefined article behaviour in both the view and the model.
    */

    //Extends core/js/views/articleView.js
    var ArticleViewInitialize = ArticleView.prototype.initialize;
    ArticleView.prototype.initialize = function(options) {
        if (this.model.get('_assessment') && this.model.get('_assessment')._isEnabled === true) {
            //extend the articleView with new functionality
            _.extend(this, AdaptAssessmentArticleView);
        }
        //initialize the article in the normal manner
        return ArticleViewInitialize.apply(this, arguments);
    };

    //Extends core/js/models/articleModel.js
    var ArticleModelInitialize = ArticleModel.prototype.initialize;
    ArticleModel.prototype.initialize = function(options) {
        if (this.get('_assessment') && this.get('_assessment')._isEnabled === true) {
            //extend the articleModel with new functionality
            _.extend(this, AdaptAssessmentArticleModel);

            //initialize the article in the normal manner
            var returnValue = ArticleModelInitialize.apply(this, arguments);

            //initialize assessment article
            this._postInitialize();

            return returnValue;
        }

        //initialize the article in the normal manner if no assessment
        return ArticleModelInitialize.apply(this, arguments);
    };

});

/*
* adapt-contrib-blockslider
* License - http://github.com/LearningPool/adapt-contrib-blockslider/LICENSE
* Maintainers - Kevin Corry <kevinc@learningpool.com>
*/
define('extensions/adapt-contrib-blockslider/js/adapt-contrib-blockslider',[
  'coreJS/adapt'
], function(Adapt) {

  function setupBlockSliderView(blockSliderArticle) {

    var BlockSliderView = Backbone.View.extend({

      className: "extension-blockslider",

      el: '.' + blockSliderArticle.get('_id'),

      events: {
        'click .blockslider-controls': 'navigateClick',
        'click .blockslider-tab': 'navigateTab'
      },

      initialize: function() {
        this.setupBlockSlider();
        this.checkDeviceLayout();
        this.render();

        _.defer(_.bind(function() {
          this.setInitialSlide();
        }, this));

        this.listenTo(Adapt, 'remove', this.remove, this);
        this.listenTo(Adapt, 'device:changed', this.checkDeviceLayout, this);
        this.listenTo(Adapt, 'device:resize', this.calculateDimensions, this);
        this.listenTo(Adapt, 'pageView:ready', this.setBlockHeight, this);

        // Listen directly to window resize also - as blockslider is added
        // to the DOM post-render, resize events on blockslider-container
        // are fired too late, so we need to pick them up right away
        $(window).on('resize', _.bind(
          function() {
            this.calculateDimensions();
          }, this)
        );
      },

      setInitialSlide: function() {
        var initialSlide = this.model.get('_blockSlider')._initial ? this.model.get('_blockSlider')._initial - 1 : 0;
        var movementSize = this.$('.blockslider-container').width();
        this.$('.blockslider').css({ 'margin-left': - (movementSize * initialSlide) });
        this.setStage(initialSlide);
      },

      render: function() {
        // Add controls to the article
        var data = this.model.toJSON();
        var template = Handlebars.templates["blockslider"];
        this.$('.article-inner').addClass('blockslider-article');
        $(template(data)).insertBefore(this.$('.blockslider-container'));
        this.$('.blockslider-tab').first().addClass('active');
        return this;
      },

      checkDeviceLayout: function() {
        if (Adapt.device.screenSize == 'small') {
          this.unwrapBlocks();
        } else if (!this.model.get('_active') && Adapt.device.screenSize != 'small') {
          this.wrapBlocks();
        }
      },

      wrapBlocks: function() {
        this.$(".block").wrapAll("<div class='blockslider' />");
        this.$(".blockslider").wrapAll("<div class='blockslider-container' />");
        this.$('.blockslider-controls-container').removeClass('blockslider-hidden');
        this.model.set('_active', true);
      },

      getAvailableBlocks: function() {
        return _.filter(this.model.getChildren().models, function(block) {
          return block.get('_isAvailable');
        });
      },

      unwrapBlocks: function() {
        this.$(".blockslider").unwrap();
        this.$(".block").unwrap();
        this.$('.blockslider-controls-container').addClass('blockslider-hidden');

        var availableBlocks = this.getAvailableBlocks();

        _.each(availableBlocks, function(availableBlock) {
          availableBlock.set('_isVisible', availableBlock.get('_previousVisibleState'));
        });

        this.model.set('_active', false);
      },

      setupBlockSlider: function() {
        var availableBlocks = this.getAvailableBlocks();

        _.each(availableBlocks, function(availableBlock) {
          // Keep a record of the state before blockSlider was initialised
          availableBlock.set('_previousVisibleState', availableBlock.get('_isVisible'));
          // Set the block to not visible first - we'll update this via setStage
          // as we progress through the blockSlider
          availableBlock.set('_isVisible', false);
        }, this);

        this.model.set('_blocks', availableBlocks);
        this.model.set('_blockCount', availableBlocks.length);

        this.wrapBlocks();
        this.calculateDimensions();
      },

      calculateDimensions: function() {
        var slideWidth = this.$('.article-body').width();
        var slideCount = this.model.get('_blockCount');
        var stage = this.model.get('_stage');
        var margin = -(stage * slideWidth);
        this.$('.blockslider-container').width(slideWidth);
        this.$('.blockslider').width(slideWidth * slideCount);
        this.$('.block').width(slideWidth);
        this.$('.blockslider').css('margin-left', margin);
      },

      navigateClick: function(event) {
        event.preventDefault();

        var stage = this.model.get('_stage');
        var movementSize = this.$('.blockslider-container').width();

        if (this.$(event.currentTarget).hasClass('blockslider-control-right')) {
          this.navigateToIndex(++stage, movementSize);
        }
        if (this.$(event.currentTarget).hasClass('blockslider-control-left')) {
          this.navigateToIndex(--stage, movementSize);
        }
      },

      navigateTab: function(event) {
        event.preventDefault();
        this.$('.blockslider-tab').removeClass('active');
        this.$(event.currentTarget).addClass('active');
        var movementSize = this.$('.blockslider-container').width();
        var currentIndex = this.$('.blockslider-tab.active').index();
        this.navigateToIndex(currentIndex, movementSize);
      },

      navigateToIndex: function(stage, movementSize) {
        if (stage < this.model.get('_blockCount') && stage >= 0) {
          this.$('.blockslider').stop().animate({ 'margin-left': - (movementSize * stage) });
          this.setStage(stage);
        }
      },

      setStage: function(stage) {
        this.model.set('_stage', stage);

        this.$('.blockslider-tab').removeClass('active');
        this.$('.blockslider-tab').eq(stage).addClass('active');

        // Set the block to visible when we navigate to it
        if (!this.model.get('_blocks')[stage].get('_isVisible')) {
          this.model.get('_blocks')[stage].set('_isVisible', true);
        }

        this.evaluateNavigation();
      },

      setBlockHeight: function() {
        // If the user has specified a fixed hieght for slider, use that,
        // otherwise css will dictate that it's auto
        if (_.isNumber(parseFloat(this.model.get('_blockSlider')._height))) {
          this.$('.blockslider-container').height(this.model.get('_blockSlider')._height);
        }
      },

      evaluateNavigation: function() {
        var currentStage = this.model.get('_stage');
        var itemCount = this.model.get('_blockCount');

        if (currentStage > 0) {
          this.$('.blockslider-control-left').removeClass('blockslider-hidden');
        } else {
          this.$('.blockslider-control-left').addClass('blockslider-hidden');
        }

        if (itemCount > 1 && currentStage != --itemCount) {
          this.$('.blockslider-control-right').removeClass('blockslider-hidden');
        } else {
          this.$('.blockslider-control-right').addClass('blockslider-hidden');
        }
      }

    });

    new BlockSliderView({ model: blockSliderArticle });
  }

  function onArticleViewPreRender(article) {
    if (!article.model.get('_blockSlider') || !article.model.get('_blockSlider')._isEnabled) {
      return;
    }

    if (!article.model.get('body')) {
      article.model.set('body', '&nbsp;');
    }
  }

  function onArticleViewPostRender(article) {
    if (!article.model.get('_blockSlider') || !article.model.get('_blockSlider')._isEnabled) {
      return;
    }

    setupBlockSliderView(article.model);
  }

  function onDataReady() {
    // do not proceed until blockslider enabled on course.json
    if (!Adapt.course.get('_blockSlider') || !Adapt.course.get('_blockSlider')._isEnabled) {
      return;
    }

    Adapt.on('articleView:preRender', onArticleViewPreRender);
    Adapt.on('articleView:postRender', onArticleViewPostRender);
  }

  Adapt.once('app:dataReady', onDataReady);

});

define('extensions/adapt-contrib-bookmarking/js/adapt-contrib-bookmarking',[
    'core/js/adapt'
], function(Adapt) {

    var Bookmarking = Backbone.Controller.extend({

        bookmarkLevel: null,
        watchViewIds: null,
        watchViews: [],
        restoredLocationID: null,
        currentLocationID: null,

        initialize: function () {
            this.listenToOnce(Adapt, 'router:location', this.onAdaptInitialize);
        },

        onAdaptInitialize: function() {
            if (!this.checkIsEnabled()) return;
            this.setupEventListeners();
            this.checkRestoreLocation();
        },

        checkIsEnabled: function() {
            var courseBookmarkModel = Adapt.course.get('_bookmarking');
            if (!courseBookmarkModel || !courseBookmarkModel._isEnabled) return false;
            if (!Adapt.offlineStorage) return false;
            return true;
        },

        setupEventListeners: function() {
            this._onScroll = _.debounce(this.checkLocation.bind(this), 1000);
            this.listenTo(Adapt, {
                'menuView:ready': this.setupMenu,
                'pageView:preRender': this.setupPage
            });
        },

        checkRestoreLocation: function() {
            this.restoredLocationID = Adapt.offlineStorage.get('location');

            if (!this.restoredLocationID || this.restoredLocationID === 'undefined') return;

            this.listenToOnce(Adapt, 'pageView:ready menuView:ready', this.restoreLocation);
        },

        restoreLocation: function() {
            _.defer(function() {
                this.stopListening(Adapt, 'pageView:ready menuView:ready', this.restoreLocation);

                if ((this.restoredLocationID === Adapt.location._currentId) || !Adapt.findById(this.restoredLocationID)) {
                    return;
                }
                var locationOnscreen = $('.' + this.restoredLocationID).onscreen();
                var isLocationOnscreen = locationOnscreen && (locationOnscreen.percentInview > 0);
                var isLocationFullyInview = locationOnscreen && (locationOnscreen.percentInview === 100);
                if (isLocationOnscreen && isLocationFullyInview) {
                    return;
                }

                if(Adapt.course.get('_bookmarking')._showPrompt === false) {
                    this.navigateToPrevious();
                    return;
                }
                this.showPrompt();

            }.bind(this));
        },

        showPrompt: function() {
            var courseBookmarkModel = Adapt.course.get('_bookmarking');
            var buttons = courseBookmarkModel._buttons || { yes: 'Yes', no: 'No' };

            this.listenToOnce(Adapt, {
                'bookmarking:continue': this.navigateToPrevious,
                'bookmarking:cancel': this.navigateCancel
            });

            var promptObject = {
                title: courseBookmarkModel.title,
                body: courseBookmarkModel.body,
                _prompts:[
                    {
                        promptText: buttons.yes || 'Yes',
                        _callbackEvent: 'bookmarking:continue'
                    },
                    {
                        promptText: buttons.no || 'No',
                        _callbackEvent: 'bookmarking:cancel'
                    }
                ],
                _showIcon: true
            };

            var accessibility = Adapt.config.get('_accessibility');
            if (!accessibility || !accessibility._isActive) {
                Adapt.trigger('notify:prompt', promptObject);
                return;
            }

            $('.loading').show();
            $('#a11y-focuser').focus();
            $('body').attr('aria-hidden', true);
            _.delay(function() {
                $('.loading').hide();
                $('body').removeAttr('aria-hidden');
                Adapt.trigger('notify:prompt', promptObject);
            }, 3000);
        },

        navigateToPrevious: function() {
            _.defer(function() {
                var isSinglePage = Adapt.contentObjects.models.length == 1;
                Backbone.history.navigate('#/id/' + this.restoredLocationID, {trigger: true, replace: isSinglePage});
            }.bind(this));

            this.stopListening(Adapt, 'bookmarking:cancel');
        },

        navigateCancel: function() {
            this.stopListening(Adapt, 'bookmarking:continue');
        },

        resetLocationID: function () {
            this.setLocationID('');
        },

        /**
         * if the learner navigates to the top-level menu, clear the stored bookmark
         * if it's a sub-menu, store the menu's id as the bookmark
         */
        setupMenu: function(menuView) {
            var menuModel = menuView.model;

            if (!menuModel.get('_parentId')) {
                this.resetLocationID();
                return;
            }

            this.setLocationID(menuModel.get('_id'));
        },

        /**
         * Calculates what the bookmarking 'level' will be for any given page.
         * First sets a default using the course-level setting (or 'component' if that's not been set)
         * then checks to see if that's being overridden at page level or not
         * @param {Backbone.Model} pageModel The model for the current page view
         * @return {String} Either 'page', 'block', or 'component' - with 'component' being the default
         */
        getBookmarkLevel: function(pageModel) {
            var defaultLevel = Adapt.course.get('_bookmarking')._level || 'component';
            var bookmarkModel = pageModel.get('_bookmarking');
            var isInherit = !bookmarkModel || !bookmarkModel._level || bookmarkModel._level === 'inherit';
            return isInherit ? defaultLevel : bookmarkModel._level;
        },

        /**
         * Sets up bookmarking for the page the learner just navigated to
         * If bookmarking is disabled for the current page, clear the stored bookmark and return.
         * Otherwise, bookmark the page then - if necessary - set up to calculate which block or component
         * should be bookmarked as the learner scrolls up/down the page
         * @param {Backbone.View} pageView The current page view
         */
        setupPage: function (pageView) {
            var pageBookmarkModel = pageView.model.get('_bookmarking');
            if (pageBookmarkModel && pageBookmarkModel._isEnabled === false) {
                this.resetLocationID();
                return;
            }

            this.setLocationID(pageView.model.get('_id'));

            this.bookmarkLevel = this.getBookmarkLevel(pageView.model);
            if (this.bookmarkLevel === 'page') {
                return;
            }

            this.watchViewIds = pageView.model.findDescendantModels(this.bookmarkLevel + 's').map(function(desc) {
                return desc.get('_id');
            });

            this.listenTo(Adapt, this.bookmarkLevel + 'View:postRender', this.captureViews);
            this.listenToOnce(Adapt, 'remove', this.releaseViews);

            $(window).on('scroll', this._onScroll);
        },

        captureViews: function (view) {
            this.watchViews.push(view);
        },

        setLocationID: function (id) {
            if (!Adapt.offlineStorage) return;
            if (this.currentLocationID == id) return;
            Adapt.offlineStorage.set('location', id);
            this.currentLocationID = id;
        },

        releaseViews: function () {
            this.watchViews.length = 0;
            this.watchViewIds.length = 0;
            this.stopListening(Adapt, 'remove', this.releaseViews);
            this.stopListening(Adapt, this.bookmarkLevel + 'View:postRender', this.captureViews);
            $(window).off('scroll', this._onScroll);
        },

        checkLocation: function() {
            var highestOnscreen = 0;
            var highestOnscreenLocation = '';

            for (var i = 0, l = this.watchViews.length; i < l; i++) {
                var view = this.watchViews[i];

                var isViewAPageChild = (this.watchViewIds.indexOf(view.model.get('_id')) > -1 );

                if ( !isViewAPageChild ) continue;

                var element = $('.' + view.model.get('_id'));
                var measurements = element.onscreen();

                if (!measurements.onscreen) continue;
                if (measurements.percentInview > highestOnscreen) {
                    highestOnscreen = measurements.percentInview;
                    highestOnscreenLocation = view.model.get('_id');
                }
            }

            //set location as most inview component
            if (highestOnscreenLocation) this.setLocationID(highestOnscreenLocation);
        }

    });

    return new Bookmarking();

});

define('extensions/adapt-contrib-resources/js/adapt-contrib-resourcesView',[
    'core/js/adapt'
], function(Adapt) {

    var ResourcesView = Backbone.View.extend({

        className: 'resources',

        initialize: function() {
            this.listenTo(Adapt, 'remove', this.remove);
            this.render();
        },

        events: {
            'click .resources-filter button': 'onFilterClicked'
        },

        render: function() {
            this.$el.html(Handlebars.templates.resources({
                model: this.model.toJSON(),
                resources: this.collection.toJSON()
            }));

            _.defer(function() {
                this.listenTo(Adapt, 'drawer:triggerCustomView', this.remove);
            }.bind(this));

            return this;
        },

        onFilterClicked: function(e) {
            if (e && e.preventDefault) e.preventDefault();

            this.$('.resources-filter button').removeClass('selected');

            var items;
            var filter = $(e.currentTarget).addClass('selected').attr('data-filter');
            if (filter === 'all') {
                items = this.$('.resources-item').removeClass('display-none');
            } else {
                this.$('.resources-item').removeClass('display-none').not('.' + filter).addClass('display-none');
                items = this.$('.resources-item.' + filter);
            }

            if (items.length > 0) $(items[0]).a11y_focus();
        }
    });

    return ResourcesView;
});

define('extensions/adapt-contrib-resources/js/adapt-contrib-resourcesHelpers',[
    'handlebars',
    'core/js/adapt'
], function(Handlebars, Adapt) {

    var helpers = {

        resources_has_type: function(resources, type, block) {
            var hasType = _.some(resources, _.matcher({_type: type}));
            return hasType ? block.fn(this) : block.inverse(this);
        },

        resources_has_multiple_types: function(resources, block) {
            if (resources.length === 1) return block.inverse(this);

            var allSameType = _.every(resources, _.matcher({_type: resources[0]._type}));
            return allSameType ? block.inverse(this) : block.fn(this);
        },

        resources_get_column_count: function(resources) {
            return _.uniq(_.pluck(resources, '_type')).length + 1;// add 1 for the 'All' button column
        },

        /**
         * IE doesn't support the 'download' attribute
         * https://github.com/adaptlearning/adapt_framework/issues/1559
         * and iOS just opens links with that attribute in the same window
         * https://github.com/adaptlearning/adapt_framework/issues/1852
         */
        resources_force_download: function(resource, block) {
            if (Adapt.device.browser === 'internet explorer' || Adapt.device.OS === 'ios') {
                return block.inverse(this);
            }

            return (resource._forceDownload || resource.filename) ? block.fn(this) : block.inverse(this);
        }

    };

    for (var name in helpers) {
        if (helpers.hasOwnProperty(name)) {
            Handlebars.registerHelper(name, helpers[name]);
        }
    }

});

define('extensions/adapt-contrib-resources/js/adapt-contrib-resources',[
    'core/js/adapt',
    './adapt-contrib-resourcesView',
    './adapt-contrib-resourcesHelpers'
], function(Adapt, ResourcesView, ResourcesHelpers) {

    function setupResources(resourcesData) {

        var resourcesModel = new Backbone.Model(resourcesData);
        var resourcesCollection = new Backbone.Collection(resourcesModel.get('_resourcesItems'));

        Adapt.on('resources:showResources', function() {
            Adapt.drawer.triggerCustomView(new ResourcesView({
                model: resourcesModel,
                collection: resourcesCollection
            }).$el);
        });

    }

    function initResources() {

        var courseResources = Adapt.course.get('_resources');

        // do not proceed until resource set on course.json
        if (!courseResources || courseResources._isEnabled === false) return;

        var drawerObject = {
            title: courseResources.title,
            description: courseResources.description,
            className: 'resources-drawer',
            drawerOrder: courseResources._drawerOrder || 0
        };

        Adapt.drawer.addItem(drawerObject, 'resources:showResources');

        setupResources(courseResources);

    }

    Adapt.on('adapt:start', initResources);

});

define ('extensions/adapt-contrib-spoor/js/scorm/wrapper',[
  'libraries/SCORM_API_wrapper'
], function(pipwerks) {

  /*
    IMPORTANT: This wrapper uses the Pipwerks SCORM wrapper and should therefore support both SCORM 1.2 and 2004. Ensure any changes support both versions.
  */

  var ScormWrapper = function() {
    /* configuration */
    this.setCompletedWhenFailed = true;// this only applies to SCORM 2004
    /**
     * whether to commit each time there's a change to lesson_status or not
     */
    this.commitOnStatusChange = true;
    /**
     * how frequently (in minutes) to commit automatically. set to 0 to disable.
     */
    this.timedCommitFrequency = 10;
    /**
     * how many times to retry if a commit fails
     */
    this.maxCommitRetries = 5;
    /**
     * time (in milliseconds) to wait between retries
     */
    this.commitRetryDelay = 1000;

    /**
     * prevents commit from being called if there's already a 'commit retry' pending.
     */
    this.commitRetryPending = false;
    /**
     * how many times we've done a 'commit retry'
     */
    this.commitRetries = 0;
    /**
     * not currently used - but you could include in an error message to show when data was last saved
     */
    this.lastCommitSuccessTime = null;
    /**
     * The exit state to use when course isn't completed yet
     */
    this.exitStateIfIncomplete = "auto";
    /**
     * The exit state to use when the course has been completed/passed
     */
    this.exitStateIfComplete = "auto";


    this.timedCommitIntervalID = null;
    this.retryCommitTimeoutID = null;
    this.logOutputWin = null;
    this.startTime = null;
    this.endTime = null;

    this.lmsConnected = false;
    this.finishCalled = false;

    this.logger = Logger.getInstance();
    this.scorm = pipwerks.SCORM;
    /**
     * Prevent the Pipwerks SCORM API wrapper's handling of the exit status
     */
    this.scorm.handleExitMode = false;

    this.suppressErrors = false;

    if (window.__debug)
        this.showDebugWindow();

    if ((window.API && window.API.__offlineAPIWrapper) || (window.API_1484_11 && window.API_1484_11.__offlineAPIWrapper))
        this.logger.error("Offline SCORM API is being used. No data will be reported to the LMS!");
  };

  // static
  ScormWrapper.instance = null;

  /******************************* public methods *******************************/

  // static
  ScormWrapper.getInstance = function() {
    if (ScormWrapper.instance === null)
        ScormWrapper.instance = new ScormWrapper();

    return ScormWrapper.instance;
  };

  ScormWrapper.prototype.getVersion = function() {
    return this.scorm.version;
  };

  ScormWrapper.prototype.setVersion = function(value) {
    this.logger.debug("ScormWrapper::setVersion: " + value);
    this.scorm.version = value;
  };

  ScormWrapper.prototype.initialize = function() {
    this.logger.debug("ScormWrapper::initialize");
    this.lmsConnected = this.scorm.init();

    if (this.lmsConnected) {
      this.startTime = new Date();

      this.initTimedCommit();
    }
    else {
      this.handleError("Course could not connect to the LMS");
    }

    return this.lmsConnected;
  };

  /**
  * allows you to check if this is the user's first ever 'session' of a SCO, even after the lesson_status has been set to 'incomplete'
  */
  ScormWrapper.prototype.isFirstSession = function() {
    return (this.getValue(this.isSCORM2004() ? "cmi.entry" :"cmi.core.entry") === "ab-initio");
  };

  ScormWrapper.prototype.setIncomplete = function() {
    this.setValue(this.isSCORM2004() ? "cmi.completion_status" : "cmi.core.lesson_status", "incomplete");

    if (this.commitOnStatusChange) this.commit();
  };

  ScormWrapper.prototype.setCompleted = function() {
    this.setValue(this.isSCORM2004() ? "cmi.completion_status" : "cmi.core.lesson_status", "completed");

    if (this.commitOnStatusChange) this.commit();
  };

  ScormWrapper.prototype.setPassed = function() {
    if (this.isSCORM2004()) {
      this.setValue("cmi.completion_status", "completed");
      this.setValue("cmi.success_status", "passed");
    }
    else {
      this.setValue("cmi.core.lesson_status", "passed");
    }

    if (this.commitOnStatusChange) this.commit();
  };

  ScormWrapper.prototype.setFailed = function() {
    if (this.isSCORM2004()) {
      this.setValue("cmi.success_status", "failed");

      if (this.setCompletedWhenFailed) {
        this.setValue("cmi.completion_status", "completed");
      }
    }
    else {
      this.setValue("cmi.core.lesson_status", "failed");
    }

    if (this.commitOnStatusChange) this.commit();
  };

  ScormWrapper.prototype.getStatus = function() {
    var status = this.getValue(this.isSCORM2004() ? "cmi.completion_status" : "cmi.core.lesson_status");

    switch(status.toLowerCase()) {// workaround for some LMSes (e.g. Arena) not adhering to the all-lowercase rule
      case "passed":
      case "completed":
      case "incomplete":
      case "failed":
      case "browsed":
      case "not attempted":
      case "not_attempted":// mentioned in SCORM 2004 docs but not sure it ever gets used
      case "unknown": //the SCORM 2004 version of not attempted
        return status;
      default:
        this.handleError("ScormWrapper::getStatus: invalid lesson status '" + status + "' received from LMS");
        return null;
    }
  };

  ScormWrapper.prototype.setStatus = function(status) {
    switch (status.toLowerCase()){
      case "incomplete":
        this.setIncomplete();
      break;
      case "completed":
        this.setCompleted();
      break;
      case "passed":
        this.setPassed();
      break;
      case "failed":
        this.setFailed();
      break;
      default:
        this.handleError("ScormWrapper::setStatus: the status '" + status + "' is not supported.");
    }
  };

  ScormWrapper.prototype.getScore = function() {
    return this.getValue(this.isSCORM2004() ? "cmi.score.raw" : "cmi.core.score.raw");
  };

  ScormWrapper.prototype.setScore = function(_score, _minScore, _maxScore) {
    if (this.isSCORM2004()) {
      this.setValue("cmi.score.raw", _score);
      this.setValue("cmi.score.min", _minScore);
      this.setValue("cmi.score.max", _maxScore);

      var range = _maxScore - _minScore;
      var scaledScore = ((_score - _minScore) / range).toFixed(7);
      this.setValue("cmi.score.scaled", scaledScore);
    }
    else {
      this.setValue("cmi.core.score.raw", _score);

      if (this.isSupported("cmi.core.score.min")) this.setValue("cmi.core.score.min", _minScore);

      if (this.isSupported("cmi.core.score.max")) this.setValue("cmi.core.score.max", _maxScore);
    }
  };

  ScormWrapper.prototype.getLessonLocation = function() {
    return this.getValue(this.isSCORM2004() ? "cmi.location" : "cmi.core.lesson_location");
  };

  ScormWrapper.prototype.setLessonLocation = function(_location) {
    this.setValue(this.isSCORM2004() ? "cmi.location" : "cmi.core.lesson_location", _location);
  };

  ScormWrapper.prototype.getSuspendData = function() {
    return this.getValue("cmi.suspend_data");
  };

  ScormWrapper.prototype.setSuspendData = function(_data) {
    this.setValue("cmi.suspend_data", _data);
  };

  ScormWrapper.prototype.getStudentName = function() {
    return this.getValue(this.isSCORM2004() ? "cmi.learner_name" : "cmi.core.student_name");
  };

  ScormWrapper.prototype.getStudentId = function(){
    return this.getValue(this.isSCORM2004() ? "cmi.learner_id":"cmi.core.student_id");
  };

  ScormWrapper.prototype.setLanguage = function(_lang){
    if (this.isSCORM2004()) {
      this.setValue("cmi.learner_preference.language", _lang);
    } else {
      if (this.isSupported("cmi.student_preference.language")) {
        this.setValue("cmi.student_preference.language", _lang);
      }
    }
  };

  ScormWrapper.prototype.commit = function() {
    this.logger.debug("ScormWrapper::commit");

    if (this.lmsConnected) {
      if (this.commitRetryPending) {
        this.logger.debug("ScormWrapper::commit: skipping this commit call as one is already pending.");
      }
      else {
        if (this.scorm.save()) {
          this.commitRetries = 0;
          this.lastCommitSuccessTime = new Date();
        }
        else {
          if (this.commitRetries < this.maxCommitRetries && !this.finishCalled) {
            this.commitRetries++;
            this.initRetryCommit();
          }
          else {
            var _errorCode = this.scorm.debug.getCode();

            var _errorMsg = "Course could not commit data to the LMS";
            _errorMsg += "\nError " + _errorCode + ": " + this.scorm.debug.getInfo(_errorCode);
            _errorMsg += "\nLMS Error Info: " + this.scorm.debug.getDiagnosticInfo(_errorCode);

            this.handleError(_errorMsg);
          }
        }
      }
    }
    else {
      this.handleError("Course is not connected to the LMS");
    }
  };

  ScormWrapper.prototype.finish = function() {
    this.logger.debug("ScormWrapper::finish");

    if (this.lmsConnected && !this.finishCalled) {
      this.finishCalled = true;

      if (this.timedCommitIntervalID !== null) {
        window.clearInterval(this.timedCommitIntervalID);
      }

      if(this.commitRetryPending) {
        window.clearTimeout(this.retryCommitTimeoutID);
        this.commitRetryPending = false;
      }

      if (this.logOutputWin && !this.logOutputWin.closed) {
        this.logOutputWin.close();
      }

      this.endTime = new Date();

      if (this.isSCORM2004()) {
        this.scorm.set("cmi.session_time", this.convertToSCORM2004Time(this.endTime.getTime() - this.startTime.getTime()));
        this.scorm.set("cmi.exit", this.getExitState());
      } else {
        this.scorm.set("cmi.core.session_time", this.convertToSCORM12Time(this.endTime.getTime() - this.startTime.getTime()));
        this.scorm.set("cmi.core.exit", this.getExitState());
      }

      // api no longer available from this point
      this.lmsConnected = false;

      if (!this.scorm.quit()) {
        this.handleError("Course could not finish");
      }
    }
    else {
      this.handleError("Course is not connected to the LMS");
    }
  };

  ScormWrapper.prototype.recordInteraction = function(id, response, correct, latency, type) {
    if(this.isSupported("cmi.interactions._count")) {
      switch(type) {
        case "choice":
          this.recordInteractionMultipleChoice.apply(this, arguments);
          break;

        case "matching":
          this.recordInteractionMatching.apply(this, arguments);
          break;

        case "numeric":
          this.isSCORM2004() ? this.recordInteractionScorm2004.apply(this, arguments) : this.recordInteractionScorm12.apply(this, arguments);
          break;

        case "fill-in":
          this.recordInteractionFillIn.apply(this, arguments);
          break;

        default:
          console.error("ScormWrapper.recordInteraction: unknown interaction type of '" + type + "' encountered...");
      }
    }
    else {
      this.logger.info("ScormWrapper::recordInteraction: cmi.interactions are not supported by this LMS...");
    }
  };

  /****************************** private methods ******************************/
  ScormWrapper.prototype.getValue = function(_property) {
    this.logger.debug("ScormWrapper::getValue: _property=" + _property);

    if (this.finishCalled) {
      this.logger.debug("ScormWrapper::getValue: ignoring request as 'finish' has been called");
      return;
    }

    if (this.lmsConnected) {
      var _value = this.scorm.get(_property);
      var _errorCode = this.scorm.debug.getCode();
      var _errorMsg = "";

      if (_errorCode !== 0) {
        if (_errorCode === 403) {
          this.logger.warn("ScormWrapper::getValue: data model element not initialized");
        }
        else {
          _errorMsg += "Course could not get " + _property;
          _errorMsg += "\nError Info: " + this.scorm.debug.getInfo(_errorCode);
          _errorMsg += "\nLMS Error Info: " + this.scorm.debug.getDiagnosticInfo(_errorCode);

          this.handleError(_errorMsg);
        }
      }
      this.logger.debug("ScormWrapper::getValue: returning " + _value);
      return _value + "";
    }
    else {
      this.handleError("Course is not connected to the LMS");
    }
  };

  ScormWrapper.prototype.setValue = function(_property, _value) {
    this.logger.debug("ScormWrapper::setValue: _property=" + _property + " _value=" + _value);

    if (this.finishCalled) {
      this.logger.debug("ScormWrapper::setValue: ignoring request as 'finish' has been called");
      return;
    }

    if (this.lmsConnected) {
      var _success = this.scorm.set(_property, _value);
      var _errorCode = this.scorm.debug.getCode();
      var _errorMsg = "";

      if (!_success) {
        /*
        * Some LMSes have an annoying tendency to return false from a set call even when it actually worked fine.
        * So, we should throw an error _only_ if there was a valid error code...
        */
        if(_errorCode !== 0) {
          _errorMsg += "Course could not set " + _property + " to " + _value;
          _errorMsg += "\nError Info: " + this.scorm.debug.getInfo(_errorCode);
          _errorMsg += "\nLMS Error Info: " + this.scorm.debug.getDiagnosticInfo(_errorCode);

          this.handleError(_errorMsg);
        }
        else {
          this.logger.warn("ScormWrapper::setValue: LMS reported that the 'set' call failed but then said there was no error!");
        }
      }

      return _success;
    }
    else {
      this.handleError("Course is not connected to the LMS");
    }
  };

  /**
  * used for checking any data field that is not 'LMS Mandatory' to see whether the LMS we're running on supports it or not.
  * Note that the way this check is being performed means it wouldn't work for any element that is
  * 'write only', but so far we've not had a requirement to check for any optional elements that are.
  */
  ScormWrapper.prototype.isSupported = function(_property) {
    this.logger.debug("ScormWrapper::isSupported: _property=" + _property);

    if (this.finishCalled) {
      this.logger.debug("ScormWrapper::isSupported: ignoring request as 'finish' has been called");
      return;
    }

    if (this.lmsConnected) {
      var _value = this.scorm.get(_property);
      var _errorCode = this.scorm.debug.getCode();

      return (_errorCode === 401 ? false : true);
    }
    else {
      this.handleError("Course is not connected to the LMS");
      return false;
    }
  };

  ScormWrapper.prototype.initTimedCommit = function() {
    this.logger.debug("ScormWrapper::initTimedCommit");

    if (this.timedCommitFrequency > 0) {
      var delay = this.timedCommitFrequency * (60 * 1000);
      this.timedCommitIntervalID = window.setInterval(this.commit.bind(this), delay);
    }
  };

  ScormWrapper.prototype.initRetryCommit = function() {
    this.logger.debug("ScormWrapper::initRetryCommit " + this.commitRetries + " out of " + this.maxCommitRetries);

    this.commitRetryPending = true;// stop anything else from calling commit until this is done

    this.retryCommitTimeoutID = window.setTimeout(this.doRetryCommit.bind(this), this.commitRetryDelay);
  };

  ScormWrapper.prototype.doRetryCommit = function() {
    this.logger.debug("ScormWrapper::doRetryCommit");

    this.commitRetryPending = false;

    this.commit();
  };

  ScormWrapper.prototype.handleError = function(_msg) {
    this.logger.error(_msg);

    if (!this.suppressErrors && (!this.logOutputWin || this.logOutputWin.closed) && confirm("An error has occured:\n\n" + _msg + "\n\nPress 'OK' to view debug information to send to technical support."))
        this.showDebugWindow();
  };

  ScormWrapper.prototype.getInteractionCount = function(){
    var count = this.getValue("cmi.interactions._count");
    return count === "" ? 0 : count;
  };

  ScormWrapper.prototype.recordInteractionScorm12 = function(id, response, correct, latency, type) {

    id = this.trim(id);

    var cmiPrefix = "cmi.interactions." + this.getInteractionCount();

    this.setValue(cmiPrefix + ".id", id);
    this.setValue(cmiPrefix + ".type", type);
    this.setValue(cmiPrefix + ".student_response", response);
    this.setValue(cmiPrefix + ".result", correct ? "correct" : "wrong");
    if (latency !== null && latency !== undefined) this.setValue(cmiPrefix + ".latency", this.convertToSCORM12Time(latency));
    this.setValue(cmiPrefix + ".time", this.getCMITime());
  };


  ScormWrapper.prototype.recordInteractionScorm2004 = function(id, response, correct, latency, type) {

    id = this.trim(id);

    var cmiPrefix = "cmi.interactions." + this.getInteractionCount();

    this.setValue(cmiPrefix + ".id", id);
    this.setValue(cmiPrefix + ".type", type);
    this.setValue(cmiPrefix + ".learner_response", response);
    this.setValue(cmiPrefix + ".result", correct ? "correct" : "incorrect");
    if (latency !== null && latency !== undefined) this.setValue(cmiPrefix + ".latency", this.convertToSCORM2004Time(latency));
    this.setValue(cmiPrefix + ".timestamp", this.getISO8601Timestamp());
  };


  ScormWrapper.prototype.recordInteractionMultipleChoice = function(id, response, correct, latency, type) {

    if (this.isSCORM2004()) {
      response = response.replace(/,|#/g, "[,]");
    } else {
      response = response.replace(/#/g, ",");
      response = this.checkResponse(response, 'choice');
    }

    var scormRecordInteraction = this.isSCORM2004() ? this.recordInteractionScorm2004 : this.recordInteractionScorm12;

    scormRecordInteraction.call(this, id, response, correct, latency, type);
  };


  ScormWrapper.prototype.recordInteractionMatching = function(id, response, correct, latency, type) {

    response = response.replace(/#/g, ",");

    if(this.isSCORM2004()) {
      response = response.replace(/,/g, "[,]");
      response = response.replace(/\./g, "[.]");
    } else {
      response = this.checkResponse(response, 'matching');
    }

    var scormRecordInteraction = this.isSCORM2004() ? this.recordInteractionScorm2004 : this.recordInteractionScorm12;

    scormRecordInteraction.call(this, id, response, correct, latency, type);
  };


  ScormWrapper.prototype.recordInteractionFillIn = function(id, response, correct, latency, type) {

    var maxLength = this.isSCORM2004() ? 250 : 255;

    if(response.length > maxLength) {
      response = response.substr(0, maxLength);

      this.logger.warn("ScormWrapper::recordInteractionFillIn: response data for " + id + " is longer than the maximum allowed length of " + maxLength + " characters; data will be truncated to avoid an error.");
    }

    var scormRecordInteraction = this.isSCORM2004() ? this.recordInteractionScorm2004 : this.recordInteractionScorm12;

    scormRecordInteraction.call(this, id, response, correct, latency, type);
  };

  ScormWrapper.prototype.showDebugWindow = function() {

    if (this.logOutputWin && !this.logOutputWin.closed) {
      this.logOutputWin.close();
    }

    this.logOutputWin = window.open("log_output.html", "Log", "width=600,height=300,status=no,scrollbars=yes,resizable=yes,menubar=yes,toolbar=yes,location=yes,top=0,left=0");

    if (this.logOutputWin)
        this.logOutputWin.focus();

    return;
  };

  ScormWrapper.prototype.convertToSCORM12Time = function(msConvert) {

    var msPerSec = 1000;
    var msPerMin = msPerSec * 60;
    var msPerHour = msPerMin * 60;

    var ms = msConvert % msPerSec;
    msConvert = msConvert - ms;

    var secs = msConvert % msPerMin;
    msConvert = msConvert - secs;
    secs = secs / msPerSec;

    var mins = msConvert % msPerHour;
    msConvert = msConvert - mins;
    mins = mins / msPerMin;

    var hrs = msConvert / msPerHour;

    if (hrs > 9999) {
      return "9999:99:99.99";
    }
    else {
      var str = [this.padWithZeroes(hrs,4), this.padWithZeroes(mins, 2), this.padWithZeroes(secs, 2)].join(":");
      return (str + '.' + Math.floor(ms/10));
    }
  };

  /**
  * Converts milliseconds into the SCORM 2004 data type 'timeinterval (second, 10,2)'
  * this will output something like 'P1DT3H5M0S' which indicates a period of time of 1 day, 3 hours and 5 minutes
  * or 'PT2M10.1S' which indicates a period of time of 2 minutes and 10.1 seconds
  */
  ScormWrapper.prototype.convertToSCORM2004Time = function(msConvert) {
    var csConvert = Math.floor(msConvert / 10);
    var csPerSec = 100;
    var csPerMin = csPerSec * 60;
    var csPerHour = csPerMin * 60;
    var csPerDay = csPerHour * 24;

    var days = Math.floor(csConvert/ csPerDay);
    csConvert -= days * csPerDay;
    days = days ? days + "D" : "";

    var hours = Math.floor(csConvert/ csPerHour);
    csConvert -= hours * csPerHour;
    hours = hours ? hours + "H" : "";

    var mins = Math.floor(csConvert/ csPerMin);
    csConvert -= mins * csPerMin;
    mins = mins ? mins + "M" : "";

    var secs = Math.floor(csConvert/ csPerSec);
    csConvert -= secs * csPerSec;
    secs = secs ? secs : "0";

    var cs = csConvert;
    cs = cs ? "." + cs : "";

    var seconds = secs + cs + "S";

    var hms = [hours,mins,seconds].join("");

    return "P" + days + "T" + hms;
  };

  ScormWrapper.prototype.getCMITime = function() {

    var date = new Date();

    var hours = this.padWithZeroes(date.getHours(),2);
    var min = this.padWithZeroes(date.getMinutes(),2);
    var sec = this.padWithZeroes(date.getSeconds(),2);

    return [hours, min, sec].join(":");
  };

  /**
  * returns the current date & time in the format YYYY-MM-DDTHH:mm:ss
  */
  ScormWrapper.prototype.getISO8601Timestamp = function() {
    var date = new Date().toISOString();
    return date.replace(/.\d\d\dZ/, "");//Date.toISOString returns the date in the format YYYY-MM-DDTHH:mm:ss.sssZ so we need to drop the last bit to make it SCORM 2004 conformant
  };

  ScormWrapper.prototype.padWithZeroes = function(numToPad, padBy) {

    var len = padBy;

    while(--len){ numToPad = "0" + numToPad; }

    return numToPad.slice(-padBy);
  };

  ScormWrapper.prototype.trim = function(str) {
    return str.replace(/^\s*|\s*$/g, "");
  };

  ScormWrapper.prototype.isSCORM2004 = function() {
    return this.scorm.version === "2004";
  };

  /*
  * SCORM 1.2 requires that the identifiers in cmi.interactions.n.student_response for choice and matching activities be a character from [0-9a-z].
  * When numeric identifiers are used this function attempts to map identifiers 10 to 35 to [a-z]. Resolves issues/1376.
  */
  ScormWrapper.prototype.checkResponse = function(response, responseType) {
    if (!response) return response;
    if (responseType != 'choice' && responseType != 'matching') return response;

    response = response.split(/,|#/);

    var self = this;

    if (responseType == 'choice') {
      response = response.map(checkIdentifier);
    } else {
      response = response.map(function(r) {
        var identifiers = r.split('.');
        return checkIdentifier(identifiers[0]) + '.' + checkIdentifier(identifiers[1]);
      });
    }

    function checkIdentifier(r) {
      var i;

      // if [0-9] then ok
      if (r.length == 1 && r >= '0' && r <= '9') return r;

      // if [a-z] then ok
      if (r.length == 1 && r >= 'a' && r <= 'z') return r;

      // try to map integers 10-35 to [a-z]
      i = parseInt(r);

      if (isNaN(i) || i < 10 || i > 35) {
        self.handleError('Numeric choice/matching response elements must use a value from 0 to 35 in SCORM 1.2');
      }

      return Number(i).toString(36); // 10 maps to 'a', 11 maps to 'b', ..., 35 maps to 'z'
    }

    return response.join(',');
  };

  ScormWrapper.prototype.getExitState = function() {
    var completionStatus = this.scorm.data.completionStatus;
    var isIncomplete = completionStatus === 'incomplete' || completionStatus === 'not attempted';
    var exitState = isIncomplete ? this.exitStateIfIncomplete : this.exitStateIfComplete;

    if (exitState !== 'auto') return exitState;

    if (this.isSCORM2004()) return (isIncomplete ? 'suspend' : 'normal');

    return '';
  };

  return ScormWrapper;

});

Logger = function() {
  this.logArr = [];
  this.registeredViews = [];
};

// static
Logger.instance = null;
Logger.LOG_TYPE_INFO = 0;
Logger.LOG_TYPE_WARN = 1;
Logger.LOG_TYPE_ERROR = 2;
Logger.LOG_TYPE_DEBUG = 3;

Logger.getInstance = function() {
  if (Logger.instance == null)
    Logger.instance = new Logger();
  return Logger.instance;
};

Logger.prototype.getEntries = function() {
  return this.logArr;
};

Logger.prototype.getLastEntry = function() {
  return this.logArr[this.logArr.length - 1];
};

Logger.prototype.info = function(str) {
  this.logArr[this.logArr.length] = {str:str, type:Logger.LOG_TYPE_INFO, time:Date.now()};
  this.updateViews();
};

Logger.prototype.warn = function(str) {
  this.logArr[this.logArr.length] = {str:str, type:Logger.LOG_TYPE_WARN, time:Date.now()};
  this.updateViews();
};

Logger.prototype.error = function(str) {
  this.logArr[this.logArr.length] = {str:str, type:Logger.LOG_TYPE_ERROR, time:Date.now()};
  this.updateViews();
};

Logger.prototype.debug = function(str) {
  this.logArr[this.logArr.length] = {str:str, type:Logger.LOG_TYPE_DEBUG, time:Date.now()};
  this.updateViews();
};

//register a view
Logger.prototype.registerView = function(_view) {
  this.registeredViews[this.registeredViews.length] = _view;
};

//unregister a view
Logger.prototype.unregisterView = function(_view) {
  for (var i = 0; i < this.registeredViews.length; i++) {
    if (this.registeredViews[i] == _view) {
      this.registeredViews.splice(i, 1);
      i--;
    }
  }
};

// update all views
Logger.prototype.updateViews = function() {
  for (var i = 0; i < this.registeredViews.length; i++) {
    if (this.registeredViews[i])
        this.registeredViews[i].update(this);
  }
};

define("extensions/adapt-contrib-spoor/js/scorm/logger", function(){});

define('extensions/adapt-contrib-spoor/js/scorm',[
  'libraries/SCORM_API_wrapper',
  './scorm/wrapper',
  './scorm/logger'
], function(API, wrapper, logger) {

  //Load and prepare SCORM API

  return wrapper.getInstance();

});

define('extensions/adapt-contrib-spoor/js/serializers/default',[
  'core/js/adapt'
], function (Adapt) {

  //Captures the completion status of the blocks
  //Returns and parses a '1010101' style string

  var serializer = {
    serialize: function () {
      return this.serializeSaveState('_isComplete');
    },

    serializeSaveState: function(attribute) {
      if (Adapt.course.get('_latestTrackingId') === undefined) {
        var message = "This course is missing a latestTrackingID.\n\nPlease run the grunt process prior to deploying this module on LMS.\n\nScorm tracking will not work correctly until this is done.";
        console.error(message);
      }

      var excludeAssessments = Adapt.config.get('_spoor') && Adapt.config.get('_spoor')._tracking && Adapt.config.get('_spoor')._tracking._excludeAssessments;

      // create the array to be serialised, pre-populated with dashes that represent unused tracking ids - because we'll never re-use a tracking id in the same course
      var data = [];
      var length = Adapt.course.get('_latestTrackingId') + 1;
      for (var i = 0; i < length; i++) {
        data[i] = "-";
      }

      // now go through all the blocks, replacing the appropriate dashes with 0 (incomplete) or 1 (completed) for each of the blocks
      _.each(Adapt.blocks.models, function(model, index) {
        var _trackingId = model.get('_trackingId'),
            isPartOfAssessment = model.getParent().get('_assessment'),
            state = model.get(attribute) ? 1: 0;

        if (excludeAssessments && isPartOfAssessment) {
          state = 0;
        }

        if (_trackingId === undefined) {
          var message = "Block '" + model.get('_id') + "' doesn't have a tracking ID assigned.\n\nPlease run the grunt process prior to deploying this module on LMS.\n\nScorm tracking will not work correctly until this is done.";
          console.error(message);
        } else {
          data[_trackingId] = state;
        }
      }, this);

      return data.join("");
    },

    deserialize: function (completion, callback) {
      var syncIterations = 1; // number of synchronous iterations to perform
      var i = 0, arr = this.deserializeSaveState(completion), len = arr.length;

      function step() {
        var state;
        for (var j=0, count=Math.min(syncIterations, len-i); j < count; i++, j++) {
          state = arr[i];
          if (state === 1) {
            markBlockAsComplete(Adapt.blocks.findWhere({_trackingId: i}));
          }
        }
        i == len ? callback() : setTimeout(step);
      }

      function markBlockAsComplete(block) {
        if (!block) {
          return;
        }

        block.getChildren().each(function(child) {
          child.set('_isComplete', true);
        });
      }

      step();
    },

    deserializeSaveState: function (string) {
      var completionArray = string.split("");

      for (var i = 0; i < completionArray.length; i++) {
        if (completionArray[i] === "-") {
          completionArray[i] = -1;
        } else {
          completionArray[i] = parseInt(completionArray[i], 10);
        }
      }

      return completionArray;
    }

  };

  return serializer;

});

//https://raw.githubusercontent.com/oliverfoster/SCORMSuspendDataSerializer 2015-06-27
(function(_) {

  function toPrecision(number, precision) {
    if (precision === undefined) precision = 2
    var multiplier = 1 * Math.pow(10, precision);
    return Math.round(number * multiplier) / multiplier;
  }

  function BinaryToNumber(bin, length) {
    return parseInt(bin.substr(0, length), 2);
  }

  function NumberToBinary(number, length) {
    return Padding.fillLeft( number.toString(2), length );
  }

  var Padding = {
    addLeft: function PaddingAddLeft(str, x , char) {
      char = char || "0";
      return (new Array( x + 1)).join(char) + str;
    },
    addRight: function PaddingAddRight(str, x, char) {
      char = char || "0";
      return  str + (new Array( x + 1)).join(char);
    },
    fillLeft: function PaddingFillLeft(str, x, char) {
      if (str.length < x) {
        var paddingLength = x - str.length;
        return Padding.addLeft(str, paddingLength, char)
      }
      return str;
    },
    fillRight: function PaddingFillLeft(str, x, char) {
      if (str.length < x) {
        var paddingLength = x - str.length;
        return Padding.addRight(str, paddingLength, char)
      }
      return str;
    },
    fillBlockLeft: function PaddingFillBlockRight(str, x, char) {
      if (str.length % x) {
        var paddingLength = x - (str.length % x);
        return Padding.addLeft(str, paddingLength, char)
      }
      return str;
    },
    fillBlockRight: function PaddingFillBlockRight(str, x, char) {
      if (str.length % x) {
        var paddingLength = x - (str.length % x);
        return Padding.addRight(str, paddingLength, char)
      }
      return str;
    }
  };

  function Base64() {
    switch (arguments.length) {
    case 1:
      var firstArgumentType = typeof arguments[0];
      switch (firstArgumentType) {
      case "number":
        return Base64._indexes[arguments[0]];
      case "string":
        return Base64._chars[arguments[0]];
      default:
        throw "Invalid arguments type";
      }
    case 2:
      var char = arguments[0];
      var index = arguments[1];
      Base64._chars[char] = index;
      Base64._indexes[index] = char;
      return;
    default:
      throw "Invalid number of arguments";
    }
  }
  Base64._chars = {};
  Base64._indexes = {};
  (function() {
    var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-/";
    for (var i = 0, l = alphabet.length; i<l; i++) {
      Base64(alphabet[i], i);
    }
  })();


  function DataType() {
    switch (arguments.length) {
    case 1:
      switch (typeof  arguments[0]) {
      case "object":
        var item = arguments[0]
        if (DataType._types[item.type] === undefined) DataType._types[item.type] = [];
        DataType._types[item.type].push(item);
        item.index = DataType._indexes.length;
        DataType._indexes.push(item);
        DataType[item.name] = item;
        return;
      case "string":
        return DataType.getName(arguments[0]);
      case "number":
        return DataType.getIndex(arguments[0]);
      default:
        throw "Argument type not allowed";
      }
    default:
      throw "Too many arguments";
    }

  }
  DataType.VARIABLELENGTHDESCRIPTORSIZE = 8;
  DataType._types = {};
  DataType._indexes = [];
  DataType.getName = function DataTypeGetName(name) {
    if (DataType[name])
      return DataType[name];
    throw "Type name not found '"+name+"'";
  };
  DataType.getIndex = function DataTypeGetIndex(index) {
    if (DataType._indexes[index])
      return DataType._indexes[index];
    throw "Type index not found '"+index+"'";
  };
  DataType.getTypes = function DataTypeGetTypes(type) {
    if (DataType._types[type])
      return DataType._types[type];
    throw "Type not found '"+type+"'";
  };
  DataType.checkBounds = function DataTypeCheckBounds(name, number) {
    var typeDef = DataType(name);
    if (number > typeDef.max) throw name + " value is larger than "+typeDef.max;
    if (number < typeDef.min) throw name + " value is smaller than "+typeDef.min;
  };
  DataType.getNumberType = function DataTypeGetNumberType(number) {
    var isDecimal = (number - Math.floor(number)) !== 0;
    var numberDataTypes = DataType.getTypes("number");
    for (var t = 0, type; type = numberDataTypes[t++];) {
      if (number <= type.max && number >= type.min && (!isDecimal || isDecimal == type.decimal) ) {
        return type;
      }
    }
  };
  DataType.getVariableType = function DataTypeGetVariableType(variable) {
    var variableNativeType = variable instanceof Array ? "array" : typeof variable;
    var variableDataType;

    switch(variableNativeType) {
    case "number":
      variableDataType = DataType.getNumberType(variable);
      break;
    case "string":
      variableDataType = DataType.getName("string");
      break;
    default:
      var supportedItemDataTypes = DataType.getTypes(variableNativeType);
      switch (supportedItemDataTypes.length) {
      case 1:
        variableDataType = supportedItemDataTypes[0];
        break;
      default:
        throw "Type not found '"+variableNativeType+"'";
      }
    }

    if (!variableDataType) throw "Cannot assess type '"+variableNativeType+"'";

    return variableDataType;
  };
  DataType.getArrayType = function getArrayType(arr) {
    var foundItemTypes = [];

    for (var i = 0, l = arr.length; i < l; i++) {
      var item = arr[i];
      var itemDataType = DataType.getVariableType(item);

      if (_.findWhere(foundItemTypes, { name: itemDataType.name })) continue;

      foundItemTypes.push(itemDataType);
    }

    switch (foundItemTypes.length) {
    case 0:
      throw "Cannot determine array data types";
    case 1:
      //single value type
       return foundItemTypes[0];
    default:
      //many value types
      var nativeTypeNames = _.pluck(foundItemTypes, 'type');
      var uniqueNativeTypeNames = _.uniq(nativeTypeNames);
      var hasManyNativeTypes = (uniqueNativeTypeNames.length > 1);

      if (hasManyNativeTypes) return DataType("variable"); //multiple types in array

      //single native type in array, multiple datatype lengths
      switch (uniqueNativeTypeNames[0]) {
      case "number":
        var foundDecimal = _.findWhere(foundItemTypes, { decimal: true});
        if (foundDecimal) return foundDecimal;
        return _.max(foundItemTypes, function(type) {
          return type.max;
        });
      }

      throw "Unsupported data types";
    }

  };
  (function() {
    var types = [
      {
        "size": "fixed",
        "length": 1,
        "name": "boolean",
        "type": "boolean"
      },
      {
        "max": 15,
        "min": 0,
        "decimal": false,
        "size": "fixed",
        "length": 4,
        "name": "half",
        "type": "number"
      },
      {
        "max": 255,
        "min": 0,
        "decimal": false,
        "size": "fixed",
        "length": 8,
        "name": "byte",
        "type": "number"
      },
      {
        "max": 65535,
        "min": 0,
        "decimal": false,
        "size": "fixed",
        "length": 16,
        "name": "short",
        "type": "number"
      },
      {
        "max": 4294967295,
        "min": 0,
        "decimal": false,
        "size": "fixed",
        "length": 32,
        "name": "long",
        "type": "number"
      },
      {
        "max": 4294967295,
        "min": -4294967295,
        "decimal": true,
        "precision": 2,
        "size": "variable",
        "name": "double",
        "type": "number"
      },
      {
        "name": "base16",
        "size": "variable",
        "type": "string"
      },
      {
        "name": "base64",
        "size": "variable",
        "type": "string"
      },
      {
        "name": "array",
        "size": "variable",
        "type": "array"
      },
      {
        "name": "variable",
        "size": "variable",
        "type": "variable"
      },
      {
        "name": "string",
        "size": "variable",
        "type": "string"
      }
    ];
    for (var i = 0, type; type = types[i++];) {
        DataType(type);
    }
  })();



  function Converter(fromType, toType) {
    fromType = Converter.translateTypeAlias(fromType);
    toType = Converter.translateTypeAlias(toType);

    var args = [].slice.call(arguments, 2);

    if (fromType != "binary" && toType != "binary") {
      if (!Converter._converters[fromType]) throw "Type not found '" + fromType + "'";
      if (!Converter._converters[fromType]['binary']) throw "Type not found 'binary'";

      var bin = Converter._converters[fromType]['binary'].call(this, args[0], Converter.WRAPOUTPUT);

      if (!Converter._converters['binary'][toType]) throw "Type not found '"+toType+"'";

      return Converter._converters['binary'][toType].call(this, bin, Converter.WRAPOUTPUT);
    }

    if (!Converter._converters[fromType]) throw "Type not found '" + fromType + "'";
    if (!Converter._converters[fromType][toType]) throw "Type not found '" + toType + "'";

    return Converter._converters[fromType][toType].call(this, args[0], Converter.WRAPOUTPUT);
  }
  Converter.WRAPOUTPUT = false;
  Converter.translateTypeAlias = function ConverterTranslateTypeAlias(type) {
    type = type.toLowerCase();
    for (var Type in Converter._typeAliases) {
      if (Type == type || (" "+Converter._typeAliases[Type].join(" ")+" ").indexOf(" "+type+" ") >= 0 ) return Type;
    }
    throw "Type not found '" + type + "'";
  };
  Converter._typeAliases = {
    "base64": [ "b64" ],
    "base16" : [ "hex", "b16" ],
    "double": [ "dbl", "decimal", "d" ],
    "long": [ "lng", "l" ],
    "short": [ "s" ],
    "byte" : [ "b" ],
    "half": [ "h" ],
    "number": [ "num", "n" ],
    "binary": [ "bin" ],
    "boolean": [ "bool" ],
    "array": [ "arr" ]
  };
  Converter._variableWrapLength = function ConverterVariableWrapLength(bin) {
    var variableLength = bin.length;
    var binLength = NumberToBinary(variableLength, DataType.VARIABLELENGTHDESCRIPTORSIZE)

    return binLength + bin;
  };
  Converter._variableLength = function ConverterVariableLength(bin) {
    var VLDS =  DataType.VARIABLELENGTHDESCRIPTORSIZE;
    var variableLength = BinaryToNumber(bin, VLDS );
    return variableLength;
  };
  Converter._variableUnwrapLength = function ConverterVariableUnwrapLength(bin) {
    var VLDS =  DataType.VARIABLELENGTHDESCRIPTORSIZE;
    var variableLength = BinaryToNumber(bin, VLDS );

    return bin.substr( VLDS, variableLength);
  };
  Converter._converters = {
    "base64": {
      "binary": function ConverterBase64ToBinary(base64) { //TODO PADDING... ?
        var firstByte = Base64(base64.substr(0,1));
        var binFirstByte = NumberToBinary(firstByte, 6);
        var paddingLength = BinaryToNumber(binFirstByte, 6);

        var bin = "";
        for (var i = 0, ch; ch = base64[i++];) {
          var block = Base64(ch).toString(2);
          block = Padding.fillLeft(block, 6);
          bin += block;
        }
        bin =  bin.substr(6+paddingLength);
        return bin;
      }
    },
    "base16": {
      "binary": function ConverterBase16ToBinary(hex) {
        var firstByte = Base64(base64.substr(0,1));
        var binFirstByte = NumberToBinary(firstByte, 4);
        var paddingLength = BinaryToNumber(binFirstByte, 4);

        var bin = "";
        for (var i = 0, ch; ch = hex[i++];) {
          var block = parseInt(ch, 16).toString(2);
          block = Padding.fillLeft(block, 4);
          bin += block;
        }

        bin =  bin.substr(6+paddingLength);
        return bin;
      }
    },
    "double": {
      "binary": function ConverterDoubleToBinary(dbl, wrap) {
        var typeDef = DataType("double");
        DataType.checkBounds("double", dbl);

        dbl = toPrecision(dbl, typeDef.precision);

        var dblStr = dbl.toString(10);

        var isMinus = dbl < 0;

        var baseStr, exponentStr, highStr, lowStr, decimalPosition, hasDecimal;


        var exponentPos = dblStr.indexOf("e");
        if (exponentPos > -1) {
          //exponential float representation "nE-x"
          baseStr = dblStr.substr(0, exponentPos);
          exponentStr = Math.abs(dblStr.substr(exponentPos+1));

          if (isMinus) baseStr = baseStr.substr(1);

          decimalPosition = baseStr.indexOf(".");
          hasDecimal = (decimalPosition > -1);

          if (hasDecimal) {
            highStr = baseStr.substr(0, decimalPosition);
            lowStr = baseStr.substr(decimalPosition+1);

            exponentStr = (Math.abs(exponentStr) + lowStr.length);

            baseStr = highStr + lowStr;
          }

        } else {
          //normal long float representation "0.00000000"
          baseStr = dblStr;
          exponentStr = "0";

          if (isMinus) dblStr = dblStr.substr(1);

          decimalPosition = dblStr.indexOf(".");
          hasDecimal = (decimalPosition > -1);
          if (hasDecimal) {
            highStr = dblStr.substr(0, decimalPosition);
            lowStr = dblStr.substr(decimalPosition+1);

            exponentStr = (lowStr.length);
            if (highStr == "0") {
              baseStr = parseInt(lowStr, 10).toString(10);
            } else {
              baseStr = highStr + lowStr;
            }
          } else {
            baseStr = dblStr;
          }

        }

        var bin = [];

        var binLong = Padding.fillBlockLeft (parseInt(baseStr, 10).toString(2), 4);
        var binMinus = isMinus ? "1" : "0";
        var binExponent = Padding.fillLeft( parseInt(exponentStr, 10).toString(2), 7);

        bin.push( binMinus );
        bin.push( binExponent );
        bin.push( binLong );

        if (wrap === false) {
          return bin.join("");
        } else {
          return Converter._variableWrapLength(bin.join(""));
        }
      }
    },
    "long": {
      "binary": function ConverterLongToBinary(value) {
        var typeDef = DataType("long");
        DataType.checkBounds("long", value);
        value = toPrecision(value, 0);
        return Padding.fillLeft(value.toString(2), typeDef.length);
      }
    },
    "short": {
      "binary": function ConverterShortToBinary(value) {
        var typeDef = DataType("short");
        DataType.checkBounds("short", value);
        value = toPrecision(value, 0);
        return Padding.fillLeft(value.toString(2), typeDef.length);
      }
    },
    "byte": {
      "binary": function ConverterByteToBinary(value) {
        var typeDef = DataType("byte");
        DataType.checkBounds("byte", value);
        value = toPrecision(value, 0);
        return Padding.fillLeft(value.toString(2), typeDef.length);
      }
    },
    "half": {
      "binary": function ConverterHalfToBinary(value) {
        var typeDef = DataType("half");
        DataType.checkBounds("half", value);
        value = toPrecision(value, 0);
        return Padding.fillLeft(value.toString(2), typeDef.length);
      }
    },
    "boolean": {
      "binary": function ConverterBooleanToBinary(bool) {
        return bool ? "1" : "0";
      },
    },
    "array": {
      "binary": function ConverterArrayToBinary(arr, wrap) { //TODO PADDING NOT GOOD
        var typeDef = DataType("array");
        var arrayItemType = DataType.getArrayType(arr);
        var isVariableArray = arrayItemType.name == "vairable";

        if (isVariableArray) {
          var bin = half2bin(15);
          //variable array
          return bin;
        } else {
          var binArrayIdentifier = Converter._converters['half']['binary'](arrayItemType.index);

          var binItemsArray = [];
          for (var i = 0, l = arr.length; i < l; i++) {
            var item = arr[i];
            var binItem = Converter._converters[arrayItemType.name]['binary'](item);
            //console.log("binItem", binItem);
            binItemsArray.push( binItem );
          }

          var binItems = binItemsArray.join("");

          var paddingLength = 0;
          if (binItems.length % 4) paddingLength = 4 - (binItems.length % 4);
          var binPaddingLen = NumberToBinary(paddingLength, 2);

          var binPadding = (new Array(paddingLength+1)).join("0");

          var bin = [];
          bin.push(binArrayIdentifier);
          bin.push(binPaddingLen);
          bin.push(binPadding);
          bin.push(binItems);

          var finished = bin.join("");
          //console.log("unwrapped", finished);

          if (wrap === false) return finished;

          var wrapped = Converter._variableWrapLength( finished);
          //console.log("wrapped", wrapped);

          return wrapped;
        }

      }
    },
    "binary": {
      "array": function ConverterBinaryToArray(bin, wrap) { //TODO PADDING NOT GOOD
        var typeDef = DataType("array");

        //console.log("wrapped", bin);
        if (wrap !== false)
          bin = Converter._variableUnwrapLength( bin);
        //console.log("unwrapped", bin);

        var binArrayIdentifier = bin.substr(0, 4);
        var binPaddingLen = bin.substr(4 , 2);

        var arrayIdentifier = Converter._converters['binary'][ 'half' ]( binArrayIdentifier );
        var paddingLength = BinaryToNumber( binPaddingLen, 2 );

        var dataStart = 4 + 2 + paddingLength;
        var dataLength = bin.length - dataStart;

        var binItems = bin.substr(dataStart, dataLength );

        var arrayItemType = DataType(arrayIdentifier);
        var isVariableArray = arrayItemType.name == "variable";

        var rtn = [];
        if (isVariableArray) {

        } else {
          var hasVariableLengthChildren = arrayItemType.size == "variable";
          if (hasVariableLengthChildren) {
            var VLDS = DataType.VARIABLELENGTHDESCRIPTORSIZE;
            while ( binItems != "" ) {

              var variableLength = Converter._variableLength( binItems );
              var binItem = binItems.substr(0, VLDS + variableLength);
              binItems = binItems.substr(VLDS+variableLength);
              //console.log("binItem", binItem, BinaryToNumber(binItem, 16));

              rtn.push( Converter._converters['binary'][ arrayItemType.name ]( binItem) );
            }
          } else {
            while ( binItems != "" ) {
              var binItem = binItems.substr(0, arrayItemType.length);
              binItems = binItems.substr(arrayItemType.length);

              rtn.push( Converter._converters['binary'][ arrayItemType.name ](binItem) );
            }
          }

        }


        return rtn;

      },
      "base64": function ConverterBinaryToBase64(bin) { //TODO PADDING NOT GOOD
        var paddingLength = 0;
        if (bin.length % 6) paddingLength = 6 - (bin.length % 6);
        binPaddingLen = NumberToBinary(paddingLength, 6);
        binPadding = Padding.addLeft("", paddingLength);
        bin = binPaddingLen + binPadding + bin;

        var binLength = bin.length;
        var base64 = "";
        for (var b = 0; b < 10000; b++) {
          if (b*6 >= binLength) break;

          var block = bin.substr(b*6,6);
          base64 += Base64(parseInt(block, 2));
        }

        return base64;
      },
      "base16": function ConverterBinaryToBase16(bin) {
        var paddingLength = 0;
        if (bin.length % 4) paddingLength = 4 - (bin.length % 4);
        binPaddingLen = NumberToBinary(paddingLength, 4);
        binPadding = Padding.addLeft("", paddingLength);
        bin = binPaddingLen + binPadding + bin;

        var binLength = bin.length;
        var hex = "";
        for (var b = 0; b < 10000; b++) {
          if (b*4 >= binLength) break;

          var block = bin.substr(b*4,4);
          hex += parseInt(block, 2).toString(16);
        }
        return hex;
      },
      "double": function ConverterBinaryToDouble(bin, wrap) {
        var typeDef = DataType("double");

        if (wrap !== false)
            bin = Converter._variableUnwrapLength(bin);

        var isMinus = bin.substr(0 ,1) == 1;

        var exponentByte = parseInt("0" + bin.substr(1, 7), 2);
        var baseLong = parseInt( bin.substr(8, bin.length), 2);

        var dbl = parseFloat(baseLong+"E-"+exponentByte, 10);
        if (isMinus) dbl = dbl * -1;

        return dbl;
      },
      "long": function ConverterBinaryToLong(bin) {
        return parseInt(bin.substr(0, 32), 2);
      },
      "short": function ConverterBinaryToShort(bin) {
        return parseInt(bin.substr(0, 16), 2);
      },
      "byte": function ConverterBinaryToByte(bin) {
        return parseInt(bin.substr(0, 8), 2);
      },
      "half": function ConverterBinaryToHalf(bin) {
        return parseInt(bin.substr(0, 4), 2);
      },
      "boolean": function ConverterBinaryToBoolean(bin) {
        return bin.substr(0,1) == "1" ? true: false;
      },
      "number": function ConverterBinaryToNumber(bin) {
        return parseInt(bin, 2);
      }
    }
  };

  window.SCORMSuspendData = {
    serialize: function SCORMSuspendDataSerialize(arr) {
      return Converter ("array", "base64", arr);
    },
    deserialize: function SCORMSuspendDataDeserialize(base64) {
      return Converter("base64", "array", base64);
    },
    Base64: Base64,
    Converter: Converter,
    DataType: DataType
  };


})(_);

define("extensions/adapt-contrib-spoor/js/serializers/scormSuspendDataSerializer", function(){});

define('extensions/adapt-contrib-spoor/js/serializers/questions',[
  'core/js/adapt',
  './scormSuspendDataSerializer'
], function (Adapt) {

  //Captures the completion status and user selections of the question components
  //Returns and parses a base64 style string
  var includes = {
      "_isQuestionType": true,
      "_isResetOnRevisit": false
  };

  var serializer = {
    serialize: function () {
      return this.serializeSaveState();
    },

    serializeSaveState: function() {
      if (Adapt.course.get('_latestTrackingId') === undefined) {
        var message = "This course is missing a latestTrackingID.\n\nPlease run the grunt process prior to deploying this module on LMS.\n\nScorm tracking will not work correctly until this is done.";
        console.error(message);
        return "";
      }

      var rtn = "";
      try {
        var data = this.captureData();
        if (data.length === 0) return "";
        rtn = SCORMSuspendData.serialize(data);
      } catch(e) {
        console.error(e);
      }

      return rtn;
    },

    captureData: function() {
      var data = [];

      var trackingIds = Adapt.blocks.pluck("_trackingId");
      var blocks = {};
      var countInBlock = {};

      for (var i = 0, l = trackingIds.length; i < l; i++) {

        var trackingId = trackingIds[i];
        var blockModel = Adapt.blocks.findWhere({_trackingId: trackingId });
        var componentModels = blockModel.getChildren().where(includes);

        for (var c = 0, cl = componentModels.length; c < cl; c++) {

          var component = componentModels[c].toJSON();
          var blockId = component._parentId;

          if (!blocks[blockId]) {
            blocks[blockId] = blockModel.toJSON();
          }

          var block = blocks[blockId];
          if (countInBlock[blockId] === undefined) countInBlock[blockId] = -1;
          countInBlock[blockId]++;

          var blockLocation = countInBlock[blockId];

          if (component['_isInteractionComplete'] === false || component['_isComplete'] === false) {
            //if component is not currently complete skip it
            continue;
          }

          var hasUserAnswer = (component['_userAnswer'] !== undefined);
          var isUserAnswerArray = (component['_userAnswer'] instanceof Array);

          if (hasUserAnswer && isUserAnswerArray && component['_userAnswer'].length === 0) {
            hasUserAnswer = false;
            isUserAnswerArray = false;
          }

          var numericParameters = [
            blockLocation,
            block['_trackingId'],
            component['_score'] || 0,
            component['_attemptsLeft'] || 0
          ];

          var booleanParameters = [
            hasUserAnswer,
            isUserAnswerArray,
            component['_isInteractionComplete'],
            component['_isSubmitted'],
            component['_isCorrect'] || false
          ];

          var dataItem = [
            numericParameters,
            booleanParameters
          ];


          if (hasUserAnswer) {
            var userAnswer = isUserAnswerArray ? component['_userAnswer'] : [component['_userAnswer']];

            var arrayType = SCORMSuspendData.DataType.getArrayType(userAnswer);

            switch(arrayType.name) {
            case "string": case "variable":
              console.log("Cannot store _userAnswers from component " + component._id + " as array is of variable or string type.");
              continue;
            }

            dataItem.push(userAnswer);
          }

          data.push(dataItem);

        }

      }

      return data;

    },

    deserialize: function (str) {

      try {
        var data = SCORMSuspendData.deserialize(str);
        this.releaseData( data );
      } catch(e) {
        console.error(e);
      }

    },

    releaseData: function (arr) {

      for (var i = 0, l = arr.length; i < l; i++) {
        var dataItem = arr[i];

        var numericParameters = dataItem[0];
        var booleanParameters = dataItem[1];

        var blockLocation = numericParameters[0];
        var trackingId = numericParameters[1];
        var score = numericParameters[2];
        var attemptsLeft = numericParameters[3] || 0;

        var hasUserAnswer = booleanParameters[0];
        var isUserAnswerArray = booleanParameters[1];
        var isInteractionComplete = booleanParameters[2];
        var isSubmitted = booleanParameters[3];
        var isCorrect = booleanParameters[4];

        var block = Adapt.blocks.findWhere({_trackingId: trackingId});
        var components = block.getChildren();
        components = components.where(includes);
        var component = components[blockLocation];

        component.set("_isComplete", true);
        component.set("_isInteractionComplete", isInteractionComplete);
        component.set("_isSubmitted", isSubmitted);
        component.set("_score", score);
        component.set("_isCorrect", isCorrect);
        component.set("_attemptsLeft", attemptsLeft);

        if (hasUserAnswer) {
          var userAnswer = dataItem[2];
          if (!isUserAnswerArray) userAnswer = userAnswer[0];

          component.set("_userAnswer", userAnswer);
        }


      }
    }
  };

  return serializer;

});

define('extensions/adapt-contrib-spoor/js/adapt-stateful-session',[
  'core/js/adapt',
  './serializers/default',
  './serializers/questions',
  'core/js/enums/completionStateEnum'
], function(Adapt, serializer, questions, COMPLETION_STATE) {

  // Implements Adapt session statefulness

  var AdaptStatefulSession = _.extend({

    _config: null,
    _shouldStoreResponses: true,
    _shouldRecordInteractions: true,

    // Session Begin
    initialize: function(callback) {
      this._onWindowUnload = this.onWindowUnload.bind(this);

      this.getConfig();

      this.getLearnerInfo();

      // Restore state asynchronously to prevent IE8 freezes
      this.restoreSessionState(function() {
        // still need to defer call because AdaptModel.check*Status functions are asynchronous
        _.defer(this.setupEventListeners.bind(this));
        callback();
      }.bind(this));
    },

    getConfig: function() {
      this._config = Adapt.config.has('_spoor') ? Adapt.config.get('_spoor') : false;

      this._shouldStoreResponses = (this._config && this._config._tracking && this._config._tracking._shouldStoreResponses);

      // Default should be to record interactions, so only avoid doing that if _shouldRecordInteractions is set to false
      if (this._config && this._config._tracking && this._config._tracking._shouldRecordInteractions === false) {
        this._shouldRecordInteractions = false;
      }
    },

    /**
     * Replace the hard-coded _learnerInfo data in _globals with the actual data from the LMS
     * If the course has been published from the AT, the _learnerInfo object won't exist so we'll need to create it
     */
    getLearnerInfo: function() {
      var globals = Adapt.course.get('_globals');
      if (!globals._learnerInfo) {
        globals._learnerInfo = {};
      }
      _.extend(globals._learnerInfo, Adapt.offlineStorage.get("learnerinfo"));
    },

    saveSessionState: function() {
      var sessionPairs = this.getSessionState();
      Adapt.offlineStorage.set(sessionPairs);
    },

    restoreSessionState: function(callback) {
      var sessionPairs = Adapt.offlineStorage.get();
      var hasNoPairs = _.keys(sessionPairs).length === 0;

      var doSynchronousPart = function() {
        if (sessionPairs.questions && this._shouldStoreResponses) questions.deserialize(sessionPairs.questions);
        if (sessionPairs._isCourseComplete) Adapt.course.set('_isComplete', sessionPairs._isCourseComplete);
        if (sessionPairs._isAssessmentPassed) Adapt.course.set('_isAssessmentPassed', sessionPairs._isAssessmentPassed);
        callback();
      }.bind(this);

      if (hasNoPairs) return callback();

      // Asynchronously restore block completion data because this has been known to be a choke-point resulting in IE8 freezes
      if (sessionPairs.completion) {
        serializer.deserialize(sessionPairs.completion, doSynchronousPart);
      } else {
        doSynchronousPart();
      }
    },

    getSessionState: function() {
      var sessionPairs = {
        "completion": serializer.serialize(),
        "questions": (this._shouldStoreResponses === true ? questions.serialize() : ""),
        "_isCourseComplete": Adapt.course.get("_isComplete") || false,
        "_isAssessmentPassed": Adapt.course.get('_isAssessmentPassed') || false
      };
      return sessionPairs;
    },

    // Session In Progress
    setupEventListeners: function() {
      $(window).on('beforeunload unload', this._onWindowUnload);

      if (this._shouldStoreResponses) {
        this.listenTo(Adapt.components, 'change:_isInteractionComplete', this.onQuestionComponentComplete);
      }

      if (this._shouldRecordInteractions) {
        this.listenTo(Adapt, 'questionView:recordInteraction', this.onQuestionRecordInteraction);
      }

      this.listenTo(Adapt.blocks, 'change:_isComplete', this.onBlockComplete);
      this.listenTo(Adapt, {
        'assessment:complete': this.onAssessmentComplete,
        'app:languageChanged': this.onLanguageChanged,
        'tracking:complete': this.onTrackingComplete
      });
    },

    removeEventListeners: function () {
      $(window).off('beforeunload unload', this._onWindowUnload);
      this.stopListening();
    },

    reattachEventListeners: function() {
      this.removeEventListeners();
      this.setupEventListeners();
    },

    onBlockComplete: function(block) {
      this.saveSessionState();
    },

    onQuestionComponentComplete: function(component) {
      if (!component.get("_isQuestionType")) return;

      this.saveSessionState();
    },

    onTrackingComplete: function(completionData) {
      this.saveSessionState();

      var completionStatus = completionData.status.asLowerCase;

      // The config allows the user to override the completion state.
      switch (completionData.status) {
        case COMPLETION_STATE.COMPLETED:
        case COMPLETION_STATE.PASSED: {
          if (!this._config._reporting._onTrackingCriteriaMet) {
            Adapt.log.warn("No value defined for '_onTrackingCriteriaMet', so defaulting to '" + completionStatus + "'");
          } else {
            completionStatus = this._config._reporting._onTrackingCriteriaMet;
          }

          break;
        }

        case COMPLETION_STATE.FAILED: {
          if (!this._config._reporting._onAssessmentFailure) {
            Adapt.log.warn("No value defined for '_onAssessmentFailure', so defaulting to '" + completionStatus + "'");
          } else {
            completionStatus = this._config._reporting._onAssessmentFailure;
          }
        }
      }

      Adapt.offlineStorage.set("status", completionStatus);
    },

    onAssessmentComplete: function(stateModel) {
      Adapt.course.set('_isAssessmentPassed', stateModel.isPass);

      this.saveSessionState();

      this.submitScore(stateModel);
    },

    onQuestionRecordInteraction:function(questionView) {
      var responseType = questionView.getResponseType();

      // If responseType doesn't contain any data, assume that the question
      // component hasn't been set up for cmi.interaction tracking
      if(_.isEmpty(responseType)) return;

      var id = questionView.model.get('_id');
      var response = questionView.getResponse();
      var result = questionView.isCorrect();
      var latency = questionView.getLatency();

      Adapt.offlineStorage.set("interaction", id, response, result, latency, responseType);
    },

    /**
     * when the user switches language, we need to:
     * - reattach the event listeners as the language change triggers a reload of the json, which will create brand new collections
     * - get and save a fresh copy of the session state. as the json has been reloaded, the blocks completion data will be reset (the user is warned that this will happen by the language picker extension)
     * - check to see if the config requires that the lesson_status be reset to 'incomplete'
     */
    onLanguageChanged: function () {
      this.reattachEventListeners();

      this.saveSessionState();

      if (this._config._reporting && this._config._reporting._resetStatusOnLanguageChange === true) {
        Adapt.offlineStorage.set("status", "incomplete");
      }
    },

    submitScore: function(stateModel) {
      if (this._config && !this._config._tracking._shouldSubmitScore) return;

      if (stateModel.isPercentageBased) {
        Adapt.offlineStorage.set("score", stateModel.scoreAsPercent, 0, 100);
      } else {
        Adapt.offlineStorage.set("score", stateModel.score, 0, stateModel.maxScore);
      }
    },

    // Session End
    onWindowUnload: function() {
      this.removeEventListeners();
    }

  }, Backbone.Events);

  return AdaptStatefulSession;

});

define('extensions/adapt-contrib-spoor/js/adapt-offlineStorage-scorm',[
  'core/js/adapt',
  './scorm',
  'core/js/offlineStorage'
], function(Adapt, scorm) {

  //SCORM handler for Adapt.offlineStorage interface.

  //Stores to help handle posting and offline uniformity
  var temporaryStore = {};
  var suspendDataStore = {};
  var suspendDataRestored = false;

  Adapt.offlineStorage.initialize({

    get: function(name) {
      if (name === undefined) {
        //If not connected return just temporary store.
        if (this.useTemporaryStore()) return temporaryStore;

        //Get all values as a combined object
        suspendDataStore = this.getCustomStates();

        var data = _.extend(_.clone(suspendDataStore), {
          location: scorm.getLessonLocation(),
          score: scorm.getScore(),
          status: scorm.getStatus(),
          student: scorm.getStudentName(),
          learnerInfo: this.getLearnerInfo()
        });

        suspendDataRestored = true;

        return data;
      }

      //If not connected return just temporary store value.
      if (this.useTemporaryStore()) return temporaryStore[name];

      //Get by name
      switch (name.toLowerCase()) {
        case "location":
          return scorm.getLessonLocation();
        case "score":
          return scorm.getScore();
        case "status":
          return scorm.getStatus();
        case "student":// for backwards-compatibility. learnerInfo is preferred now and will give you more information
          return scorm.getStudentName();
        case "learnerinfo":
          return this.getLearnerInfo();
        default:
          return this.getCustomState(name);
      }
    },

    set: function(name, value) {
      //Convert arguments to array and drop the 'name' parameter
      var args = [].slice.call(arguments, 1);
      var isObject = typeof name == "object";

      if (isObject) {
        value = name;
        name = "suspendData";
      }

      if (this.useTemporaryStore()) {
        if (isObject) {
          temporaryStore = _.extend(temporaryStore, value);
        } else {
          temporaryStore[name] = value;
        }

        return true;
      }

      switch (name.toLowerCase()) {
        case "interaction":
          return scorm.recordInteraction.apply(scorm, args);
        case "location":
          return scorm.setLessonLocation.apply(scorm, args);
        case "score":
          return scorm.setScore.apply(scorm, args);
        case "status":
          return scorm.setStatus.apply(scorm, args);
        case "student":
        case "learnerinfo":
          return false;// these properties are read-only
        case "lang":
          scorm.setLanguage(value);
          // fall-through so that lang gets stored in suspend_data as well:
          // because in SCORM 1.2 cmi.student_preference.language is an optional data element
          // so we can't rely on the LMS having support for it.
          // If it does support it we may as well save the user's choice there purely for reporting purposes
        case "suspenddata":
        default:
          if (isObject) {
            suspendDataStore = _.extend(suspendDataStore, value);
          } else {
            suspendDataStore[name] = value;
          }

          var dataAsString = JSON.stringify(suspendDataStore);
          return (suspendDataRestored) ? scorm.setSuspendData(dataAsString) : false;
      }
    },

    getCustomStates: function() {
      var isSuspendDataStoreEmpty = _.isEmpty(suspendDataStore);
      if (!isSuspendDataStoreEmpty && suspendDataRestored) return _.clone(suspendDataStore);

      var dataAsString = scorm.getSuspendData();
      if (dataAsString === "" || dataAsString === " " || dataAsString === undefined) return {};

      var dataAsJSON = JSON.parse(dataAsString);
      if (!isSuspendDataStoreEmpty && !suspendDataRestored) dataAsJSON = _.extend(dataAsJSON, suspendDataStore);
      return dataAsJSON;
    },

    getCustomState: function(name) {
      var dataAsJSON = this.getCustomStates();
      return dataAsJSON[name];
    },

    useTemporaryStore: function() {
      var cfg = Adapt.config.get('_spoor');

      if (!scorm.lmsConnected || (cfg && cfg._isEnabled === false)) return true;
      return false;
    },

    /**
     * Returns an object with the properties:
     * - id (cmi.core.student_id)
     * - name (cmi.core.student_name - which is usually in the format "Lastname, Firstname" - but sometimes doesn't have the space after the comma)
     * - firstname
     * - lastname
     */
    getLearnerInfo: function() {
      var name = scorm.getStudentName();
      var firstname = "", lastname = "";
      if (name && name !== 'undefined' && name.indexOf(",") > -1) {
        //last name first, comma separated
        var nameSplit = name.split(",");
        lastname = $.trim(nameSplit[0]);
        firstname = $.trim(nameSplit[1]);
        name = firstname + " " + lastname;
      } else {
        console.log("SPOOR: LMS learner_name not in 'lastname, firstname' format");
      }
      return {
        name: name,
        lastname: lastname,
        firstname: firstname,
        id: scorm.getStudentId()
      };
    }

  });

});

define('extensions/adapt-contrib-spoor/js/adapt-contrib-spoor',[
  'core/js/adapt',
  './scorm',
  './adapt-stateful-session',
  './adapt-offlineStorage-scorm'
], function(Adapt, scorm, adaptStatefulSession) {

  // SCORM session manager

  var Spoor = _.extend({

    _config: null,

  // Session Begin

    initialize: function() {
      this.listenToOnce(Adapt, {
        'offlineStorage:prepare': this.onPrepareOfflineStorage,
        'app:dataReady': function() {
          Adapt.wait.for(adaptStatefulSession.initialize.bind(adaptStatefulSession));
        }
      });
    },

    onPrepareOfflineStorage: function() {
      if (!this.checkConfig()) {
        Adapt.offlineStorage.setReadyStatus();
        return;
      }

      this.configureAdvancedSettings();

      scorm.initialize();

      /*
      force offlineStorage-scorm to initialise suspendDataStore - this allows us to do things like store the user's
      chosen language before the rest of the course data loads
      */
      Adapt.offlineStorage.get();

      Adapt.offlineStorage.setReadyStatus();

      this.setupEventListeners();
    },

    checkConfig: function() {
      this._config = Adapt.config.get('_spoor') || false;

      if (this._config && this._config._isEnabled !== false) return true;

      return false;
    },

    configureAdvancedSettings: function() {
      if (this._config._advancedSettings) {
        var settings = this._config._advancedSettings;

        if (settings._showDebugWindow) scorm.showDebugWindow();

        scorm.setVersion(settings._scormVersion || "1.2");

        if (settings._suppressErrors) {
          scorm.suppressErrors = settings._suppressErrors;
        }

        if (settings._commitOnStatusChange) {
          scorm.commitOnStatusChange = settings._commitOnStatusChange;
        }

        if (_.isFinite(settings._timedCommitFrequency)) {
          scorm.timedCommitFrequency = settings._timedCommitFrequency;
        }

        if (_.isFinite(settings._maxCommitRetries)) {
          scorm.maxCommitRetries = settings._maxCommitRetries;
        }

        if (_.isFinite(settings._commitRetryDelay)) {
          scorm.commitRetryDelay = settings._commitRetryDelay;
        }

        if ("_exitStateIfIncomplete" in settings) {
          scorm.exitStateIfIncomplete = settings._exitStateIfIncomplete;
        }

        if ("_exitStateIfComplete" in settings) {
          scorm.exitStateIfComplete = settings._exitStateIfComplete;
        }
      } else {
        /**
        * force use of SCORM 1.2 by default - some LMSes (SABA/Kallidus for instance) present both APIs to the SCO and, if given the choice,
        * the pipwerks code will automatically select the SCORM 2004 API - which can lead to unexpected behaviour.
        */
        scorm.setVersion("1.2");
      }

      /**
      * suppress SCORM errors if 'nolmserrors' is found in the querystring
      */
      if(window.location.search.indexOf('nolmserrors') != -1) scorm.suppressErrors = true;
    },

    setupEventListeners: function() {
      var advancedSettings = this._config._advancedSettings;
      var shouldCommitOnVisibilityChange = (!advancedSettings ||
          advancedSettings._commitOnVisibilityChangeHidden !== false) &&
          document.addEventListener;

      this._onWindowUnload = this.onWindowUnload.bind(this);
      $(window).on('beforeunload unload', this._onWindowUnload);

      if (shouldCommitOnVisibilityChange) {
        document.addEventListener("visibilitychange", this.onVisibilityChange);
      }

      require(['libraries/jquery.keycombo'], function() {
        // listen for user holding 'd', 'e', 'v' keys together
        $.onKeyCombo([68, 69, 86], function() {
          scorm.showDebugWindow();
        });
      });
    },

    removeEventListeners: function() {
      $(window).off('beforeunload unload', this._onWindowUnload);

      document.removeEventListener("visibilitychange", this.onVisibilityChange);
    },

    onVisibilityChange: function() {
      if (document.visibilityState === "hidden") scorm.commit();
    },

  // Session End

    onWindowUnload: function() {
      this.removeEventListeners();

      if (!scorm.finishCalled){
        scorm.finish();
      }
    }

  }, Backbone.Events);

  Spoor.initialize();

});

define('extensions/adapt-contrib-tutor/js/adapt-contrib-tutor',[
    'coreJS/adapt'
],function(Adapt) {

    Adapt.on('questionView:showFeedback', function(view) {

        var alertObject = {
            title: view.model.get("feedbackTitle"),
            body: view.model.get("feedbackMessage")
        };

        var attributes = {};
        var classes = [];

        if (view.model.has('_isCorrect')) {
            // Attach specific classes so that feedback can be styled.
            if (view.model.get('_isCorrect')) {
                classes.push('correct');
            } else {
                if (view.model.has('_isAtLeastOneCorrectSelection')) {
                    // Partially correct feedback is an option.
                    if (view.model.get('_isAtLeastOneCorrectSelection')) {
                        classes.push('partially-correct');
                    } else {
                        classes.push('incorrect');
                    }
                } else {
                    classes.push('incorrect');
                }
            }
        }

        // Add the extension/component type which triggered this.
        if (view.model.has('_component')) {
            classes.push('component-' + view.model.get('_component'));
        } else if (view.model.has('_extension')) {
            classes.push('extension-' + view.model.get('_extension'));
        }

        // Add the _id property as attribute.
        attributes['data-adapt-id'] = view.model.get('_id');

        alertObject._classes = classes.join(' ');
        alertObject._attributes = attributes;

        Adapt.once("notify:closed", function() {
            Adapt.trigger("tutor:closed", view, alertObject);
        });

        Adapt.trigger('notify:popup', alertObject);

        Adapt.trigger('tutor:opened', view, alertObject);
    });

});

define('extensions/adapt-hint/js/adapt-hint',['require','coreJS/adapt','backbone'],function(require) {

	var Adapt = require('coreJS/adapt');
	var Backbone = require('backbone');

	var hintExtensionView = Backbone.View.extend({

		events: {
			"click .hint-extension-button": "onSpecButtonClicked"
		},
		
		className: 'hint-extension',

		initialize: function() {
			this.render();
		},

		render: function() {
			var data = this.model.toJSON();
			var template = Handlebars.templates['hint'];

			this.$el.html(template(data)).appendTo($('.' + this.model.get('_id')));
			_.defer(_.bind(this.postRender, this));
		},

		postRender: function() {
			this.setLayout();
			this.listenTo(Adapt, 'remove', this.remove);
			this.listenTo(Adapt, 'hint-extension-widget:open', this.checkIfShouldClose);
		},

		setLayout: function() {
			if (Adapt.config.get('_defaultDirection') == 'rtl' && Adapt.device.screenSize === 'small' ) {
                $('.' + this.model.get('_id') + " .component-title-inner").css({
					paddingLeft: '35px'
				});
            } else {
                $('.' + this.model.get('_id') + " .component-title-inner").css({
					paddingRight: '35px'
				});
            }

			var $specDetail = this.$('.hint-extension-widget');

			$specDetail.velocity({
				scaleX: 0,
				scaleY: 0
			}, {
				duration: 1
			});
		},

		onSpecButtonClicked: function(event) {
			if (event) event.preventDefault();

			var $specDetail = this.$('.hint-extension-widget');

			if (!$specDetail.hasClass('widget-open')) {
				$specDetail.velocity({
					scaleX: 1,
					scaleY: 1
				}, {
					duration: 800,
					display: 'block',
					easing: [500, 35]
				});
				$specDetail.addClass('widget-open');

				this.$('.hint-extension-button').removeClass('icon-question').addClass('icon-cross');

				Adapt.trigger('hint-extension-widget:open', this.model.get('_id'));
			} else {
				$specDetail.velocity({
					scaleX: 0,
					scaleY: 0
				}, {
					duration: 300,
					display: 'none'
				});
				$specDetail.removeClass('widget-open');

				this.$('.hint-extension-button').removeClass('icon-cross').addClass('icon-question');
			}
		},

		checkIfShouldClose: function(id) {
			if (this.model.get('_id') !== id) {
				var $widget = $('.' + this.model.get('_id') + " .hint-extension-widget");
				var $button = $('.' + this.model.get('_id') + " .hint-extension-button");

				$widget.velocity({
					scaleX: 0,
					scaleY: 0
				}, {
					duration: 300,
					display: 'none'
				});

				$widget.removeClass('widget-open');
				$button.removeClass('icon-cross').addClass('icon-question');
			}
		}
	});

	Adapt.on('componentView:postRender', function(view) {
		if (view.model.has('_hint') && view.model.get('_hint').length > 0) {
			new hintExtensionView({
				model: view.model
			});
		}
	});

});

/**
 * adapt-lmw-mobileFixes
 * @type: extension
 */
define('extensions/adapt-lmw-mobileFixes/js/adapt-lmw-mobileFixes',['coreJS/adapt', 'backbone'], function(Adapt, Backbone) {
    var Logic = {
        articles: {
        },
        blocks: {
        },
        components: {
            '*': function(view) {
                $(window).on('scroll.component', function() {
                    if (view.$el.hasClass('adapt-active-component') &&
                        ($(window).scrollTop()+$(window).height()) > ($(document).height()-150)) {
                        switch (view.model.get('_component')) {
                            case 'text':
                            case 'graphic': {
                                view.setCompletionStatus();
                            } break;
                            case 'narrative': {
                                if (view.model.get('_mobileAlternativeMode')) {
                                    view.setCompletionStatus();
                                }
                            }
                        }
                    }
                });
            },
            'graphic-component': function(view) {
            },
            'text-component': function(view) {
            },
            'narrative-component': function(view) {
                var $el = view.$el;
                var resize = function() {
                    if (Adapt.device.screenSize !== 'large') {
                        // hide the full component and show mobile version instead
                        $el.find('.narrative-instruction').hide();
                        $el.find('.narrative-widget').hide();
                        $el.find('.narrative-mobile-widget').show();
                        view.model.set('_mobileAlternativeMode', true);
                    } else {
                        $el.find('.narrative-instruction').show();
                        $el.find('.narrative-widget').show();
                        $el.find('.narrative-mobile-widget').hide();
                        view.model.set('_mobileAlternativeMode', false);
                    }
                };

                // generate mobile version of the narrative for mobiles
                var template = Handlebars.templates['mobileFixes-narrativeMobile'];
                $el.find('.narrative-inner').append($(template(view.model.toJSON())));
                Adapt.on('device:resize', resize);
                resize();            
            }
        },
        process: function(view, logic) {
            if ('*' in logic) {
                logic['*'](view);
            }
            var classes  = view.$el.attr('class').split(' ');
            for (var i = 0; i < classes.length; i++) {
                if (classes[i] in logic) {
                    logic[classes[i]](view);
                    return;
                }
            }
        }
    };

    Adapt.on('articleView:postRender', function(view) {
        Logic.process(view, Logic.articles);
    });
    Adapt.on('blockView:postRender', function(view) {
        Logic.process(view, Logic.blocks);
    });
    Adapt.on('componentView:postRender', function(view) {
        Logic.process(view, Logic.components);
    });

    Adapt.on('trickle:steplock', function(view) {
        $('.component').removeClass('adapt-active-component');
        view.$el.find('.component').addClass('adapt-active-component');
    });
});
/**
 * adapt-lmw-publishing
 * @type: extension
 */
define('extensions/adapt-lmw-publishing/js/adapt-lmw-publishing',['coreJS/adapt', 'backbone'], function(Adapt, Backbone) {
});



/**
 * adapt-lmw-speech
 * AudioProxy
 */
define('extensions/adapt-lmw-speech/js/handlers/audioProxy',['require'],function(require) {
    return function(controller) {
        var self = this;

        var filterCSSClasses = [
            // ignore elements text content with the following classes
            'hide',
            'hidden',
            'captivate-text-hidden',
            'narrative-hidden',
            'narrative-strapline',
            'narrative-slider',
            'narrative-mobile-widget',
            'photostory-item-next-button',
            'accessibility-state',
            'trickle-button-component',
            'hotgraphic-widget',
            'flipcard-widget',
            'activity-container',
            'activity-mobileAlternative',
            'mcq-widget',
            'media-transcript-container'
        ];

        /**
         * reset()
         */
        self.reset = function() {
            controller.reset();
        };

        /**
         * preload()
         */
        self.preload = function(domElement, filters, preloadCallback) {
            filters =  ((typeof filters === 'undefined') ? filterCSSClasses : filters);
            controller.preload(domElement, filters, preloadCallback);
        };

        /**
         * play()
         */
        self.play = function(domElement, filters, exitCallback) {
            filters =  ((typeof filters === 'undefined') ? filterCSSClasses : filters);
            controller.play(domElement, filters, exitCallback);
        };

        /**
         * isAudioEnabled()
         */
        self.isAudioEnabled = function() {
            return controller.isAudioEnabled();
        };

        /**
         * setupBlockAudio()
         */
        self.setupBlockAudio = function($el, autoplay) {
            // define aria label strings
            // @todo: fetch string values from globals
            var ariaStringTrickleContinueButton = 'Select the continue button';
            var ariaStringNextButton            = 'Select the next button to continue';

            /**
             * ariaAppendText()
             * - appends an span aria-label to the specified jQuery element
             */
            var ariaAppendText = function(jqe, text) {
                jqe.append($('<span class="aria-label speech-helper-text prevent-default a11y-ignore" role="region" tabindex="-1" aria-hidden="true">' + text + '</span>'));
            };

            // define logic for supported component types
            var componentLogic = {};
            componentLogic['activity-component'] = function(component, block) {
            }
            componentLogic['narrative-component'] = function(component, block) {
                var index = 0;
                var items = component.find('.narrative-content-item');

                component.find('.narrative-control-left').click(function() {
                    index--;
                    self.play(items[index], []);
                }).addClass('audio-button');
                component.find('.narrative-control-right').click(function() {
                    index++;
                    self.play(items[index], []);
                }).addClass('audio-button');

                // preload audio for each item and add helper text aria labels
                items.each(function(index) {
                    if (index < items.length-1) {
                        ariaAppendText($(this), ariaStringNextButton);
                    } else {
                        ariaAppendText($(this), ariaStringTrickleContinueButton);
                    }
                    self.preload(items[index]);
                });
            };
            componentLogic['photostory-component'] = function(component, block) {
                var index = 0;
                var items = component.find('.photostory-content-item-body');

                component.find('.photostory-item-next-button').click(function() {
                    index++;
                    if (index >= items.length-1) {
                        component.find('.speech-helper-text').remove();
                    }
                    self.play(items[index], []);
                }).addClass('audio-button');

                /// preload audio for each item and add helper text aria labels
                items.each(function(index) {
                    if (index < items.length-1) {
                        ariaAppendText($(this), ariaStringNextButton);
                    } else {
                        ariaAppendText($(this), ariaStringTrickleContinueButton);
                    }
                    self.preload(items[index]);
                });
            };
            componentLogic['mcq-component'] = function(component, block) {
                var items = component.find('.mcq-item');
                items.each(function(index) {
                    self.preload(items[index]);
                    $(this).click(function() {
                        self.play($(this)[0]);
                    });
                }).addClass('audio-button');
            };
            componentLogic['captivate-component'] = function(component, block) {
                // add helper text aria labels
                var items = component.find('.captivate-text');
                ariaAppendText(items.eq(items.length-1), ariaStringTrickleContinueButton);
            };
            componentLogic['assessmentResults-component'] = function(component, block) {
                ariaAppendText(component, ariaStringTrickleContinueButton);
            };
            componentLogic['hotgraphic-component'] = function(component, block) {
                component.find('button.hotgraphic-graphic-pin').click(function() {
                    self.play(component.find('.hotgraphic-item.' + $(this).attr('data-id'))[0]);
                }).addClass('audio-button');
            };
            componentLogic['flipcard-component'] = function(component, block) {
                var items = component.find('.flipcard-item');
                items.each(function(index) {
                    self.preload($(this).find('.flipcard-item-back')[0]);
                    $(this).click(function() {
                        self.play($(this).find('.flipcard-item-back')[0]);
                    });
                }).addClass('audio-button');
            };
            componentLogic['trickle-button-component'] = function(component, block) {
                component.find('.button').click(function() {
                    self.play(block.next()[0]);
                });
            };
            componentLogic['text-component'] = function(component, block) {
                // check if not summary block
                if (!block.hasClass('summary') && !block.hasClass('block-summary')) {
                    ariaAppendText(component, ariaStringTrickleContinueButton);
                }
            };
            
            // setup component audio logic for each component in the current block
            $el.find('.component').each(function(index) {
                var component = $(this);
                var classes   = component.attr('class').split(' ');
                for (var i = 0; i < classes.length; i++) {
                    if (classes[i] in componentLogic) {
                        componentLogic[classes[i]](component, $el);
                        break;
                    }
                }
            });
            // preload audio for current block, also play it if specified
            var blockElement = $el[0];
            self.preload(blockElement, filterCSSClasses, function() {
                if (autoplay) {
                    self.play(blockElement);
                }
            });
            // preload audio without lmw injected elements for certain blocks
            if ($el.hasClass('block-summary')) {
                self.preload(blockElement, filterCSSClasses.concat([
                    'lmw-topic-completion-hook'
                ]));
            }
        };
    };
});


/**
 * adapt-lmw-speech
 * AudioController
 */
define('extensions/adapt-lmw-speech/js/handlers/audioController',['require','libraries/md5.min','libraries/js.cookie'],function(require) {
    var MD5 = require('libraries/md5.min');
    var Cookies = require('libraries/js.cookie');

    return function() {
        var self = this;

        var audioSource = 'onedb';
        var audioPlayer = null;
        var audioElementCache = {};
        var audioPreloadEnabled = true;
        var audioPreloadQueue = [];
        var audioEnabledLastState = false;
        var audioParams = {
            audioFormat: 'mp3'
        };
        
        /**
         * stopAll()
         */
        self.stopAll = function() {
            // attempt to stop all currently playing audio
            try {
                if (audioPlayer) {
                    audioPlayer.pause();
                    audioPlayer.currentTime = 0;
                }
            } catch (e) {
                console.error(e);
            }
        };

        /**
         * reset()
         */
        self.reset = function() {
            self.stopAll();
            audioPlayer = null;
            audioPreloadQueue = []; 
            audioElementCache = {};
        };
        
        /**
         * preprocessElement()
         * @param element
         * @param filterCSSClasses
         */
        self.preprocessElement = function(element, filterCSSClasses) {
            if (typeof filterCSSClasses === 'undefined') {
                filterCSSClasses = [];
            }
            // recursively walk through elements and extract text, skipping elements with filtered css classes
            var elementNode = element.cloneNode(true);
            var elementText = [];
            (function walk(node, parent, depth) {
                switch (node.nodeType) {
                    case Node.TEXT_NODE: {
                        var parentTag   = parent.tagName.toLowerCase();
                        var textContent = node.nodeValue.trim();
                        if (textContent.length > 0) {
                            // add full-stop at end of string if it doesn't have one
                            if (['.', ':'].indexOf(textContent.slice(-1)) < 0) {
                                textContent += '.';
                            }
                            // if text node parent tag is not the following
                            if (['strong', 'b', 'em', 'i'].indexOf(parentTag) < 0) {
                                // prevent duplicates
                                if (elementText.indexOf(textContent) >= 0) {
                                    return;
                                }
                            }
                            elementText.push(textContent);
                        }
                    } break;
                    case Node.ELEMENT_NODE: {
                        // check if element node is visible
                        if ((((node.currentStyle) ?
                               node.currentStyle.display : getComputedStyle(node, null).display) !== 'none')) {
                            var skip = false;
                            var classes = node.className.split(' ');
                            for (var i = 0; i < filterCSSClasses.length; i++) {
                                for (var j = 0; j < classes.length; j++) {
                                    if (filterCSSClasses[i] === classes[j]) {
                                        skip = true;
                                    }
                                }
                            }
                            if (!skip) {
                                for (var i = 0; i < node.childNodes.length; i++) {
                                    walk(node.childNodes[i], node, depth+1);
                                }
                            }
                        }
                    } break;
                }
            })(elementNode, null, 0);
            // return concatenated text and md5 hash
            elementText = elementText.join(' ');
            return {
                text: elementText,
                textHash: MD5(elementText)
            };
        };

        /**
         * preloadQueueNext()
         */
        self.preloadQueueNext = function() {
            if (self.isAudioEnabled() && audioPreloadQueue.length > 0) {
                var elementObj = audioPreloadQueue[0];
                // check if element is already cached
                var fetchAudioFile = function(url) {
                    audioPreloadQueue.shift();
                    if (typeof url !== 'undefined') {
                        audioElementCache[elementObj.textHash] = new Audio(url);
                        if (typeof elementObj.onAudioPreload === 'function') {
                            elementObj.onAudioPreload();
                        }
                    }
                    setTimeout(self.preloadQueueNext, 100);
                };
                if (!(elementObj.textHash in audioElementCache)) {
                    if (audioSource === 'onedb') {
                        // NOTE: this audio source will only work for courses launched within the LMW environment
                        // get request configuration data
                        var conf = window.config || {};
                        conf.ttsVoice = conf.ttsVoice || 'uk';
                        conf.courseName = window.this_course_shortname || 'default';
                        conf.courseTopicID = location.href.split('/').slice(-1)[0];
                        // send request to onedb speech api to retrieve audio object
                        var http = new XMLHttpRequest();
                        var body = {
                            text: elementObj.text,
                            guid: elementObj.textHash,
                            format: 'mp3',
                            voice: conf.ttsVoice,
                            groupBy: [
                                'learnmyway',
                                conf.courseName,
                                conf.courseTopicID
                            ]
                        };
                        http.open('POST', '/services/onedb/api/speech', true);
                        http.setRequestHeader('Content-type', 'application/json');
                        http.responseType = 'blob';
                        http.onreadystatechange = function() {
                            if(http.readyState == 4 && http.status == 200) {
                                fetchAudioFile(window.URL.createObjectURL(http.response));
                            }
                        }
                        http.send(JSON.stringify(body));
                    } else {
                        // try to fetch audio from local filesystem
                        fetchAudioFile('assets/audio/' + MD5(elementObj.textHash) + '.mp3');
                    }
                } else {
                    fetchAudioFile(); // just move the queue along
                }
            }
        };

        /**
         * preload()
         * @param element
         * @param filterCSSClasses
         * @param preloadCallback
         * @param prioratise
         */
        self.preload = function(element, filterCSSClasses, preloadCallback, prioratise) {
            if (typeof element !== 'undefined' && audioPreloadEnabled) {
                preloadCallback = preloadCallback || function() {};
                var elementObj  = self.preprocessElement(element, filterCSSClasses);
                if (!(elementObj.textHash in audioElementCache)) {
                    elementObj.onAudioPreload = preloadCallback;
                    if (audioPreloadQueue.length > 0) {
                        if (prioratise) {
                            audioPreloadQueue.unshift(elementObj);
                        } else {
                            audioPreloadQueue.push(elementObj);
                        }
                        if (self.isAudioEnabled() && !audioEnabledLastState) {
                            audioEnabledLastState = true;
                            self.preloadQueueNext();
                        }
                    } else {
                        audioPreloadQueue.push(elementObj);
                        self.preloadQueueNext();
                    }
                } else {
                    preloadCallback();
                }
            }
        };

        /**
         * play()
         * @param element
         * @param filterCSSClasses
         * @param exitCallback
         */
        self.play = function(element, filterCSSClasses, exitCallback) {
            if (self.isAudioEnabled() && typeof element !== 'undefined') {
                self.stopAll();
                // attempt to find cached audio and play it
                var elementObj = self.preprocessElement(element, filterCSSClasses);
                if (elementObj.textHash in audioElementCache) {
                    audioPlayer = audioElementCache[elementObj.textHash];
                    audioPlayer.onended = function () {
                        if (typeof exitCallback === 'function') {
                            exitCallback(element);
                        }
                    };
                    var promise = audioPlayer.play();
                    if (promise !== undefined) {
                        promise.then(function() {
                            // do nothing
                        }).catch(function(error) {
                            if (typeof exitCallback === 'function') {
                                exitCallback(element);
                            }
                        });
                    }
                } else {
                    // attempt to preload audio before playing
                    // @NOTE: this will not work on mobiles due to security limitations
                    var preloadEnabled = audioPreloadEnabled;
                    audioPreloadEnabled = true;
                    self.preload(element, filterCSSClasses, function() {
                        self.play(element, filterCSSClasses, exitCallback);
                    }, true);
                    audioPreloadEnabled = preloadEnabled;
                }
            } else {
                if (typeof exitCallback === 'function') {
                    exitCallback(element);
                }
            }
        };

        /**
         *  isAudioEnabled()
         */
        self.isAudioEnabled = function() {
            return (parseInt(Cookies.get('audio')) > 0);
        };

        /**
         * setAudioSource()
         * @param source 
         */
        self.setAudioSource = function(source) {
            audioSource = source; // set audio source type
        };
    };
});
/**
 * adapt-lmw-speech
 * @type: extension
 */
define('extensions/adapt-lmw-speech/js/adapt-lmw-speech',['require','backbone','coreJS/adapt','./handlers/audioProxy','./handlers/audioController','libraries/js.cookie'],function(require) {
    var Backbone = require('backbone');
    var Adapt = require('coreJS/adapt');
    var AudioProxy = require('./handlers/audioProxy');
    var AudioController = require('./handlers/audioController');
    var Cookies = require('libraries/js.cookie');

    // keep track of which block we are currently on
    var currentBlock = 0;

    var controller = new AudioController();
    var proxy = new AudioProxy(controller);

    /**
     * speechConfigView
     * -- Backbone view for rendering an audio config control which appears at the top of the course topic
     */
    var speechConfigView = Backbone.View.extend({
        className: 'speech-extension',
        defaultAudioState: 0,

        /**
         * initialize()
         */
        initialize: function() {
            var self = this;
            if (Adapt.config.has('_TTS')) {
                var conf = Adapt.config.get('_TTS');
                if (conf._isEnabled) {
                    if (conf.hasOwnProperty('_audioSource')) {
                        controller.setAudioSource(conf._audioSource);
                    }
                    self.render();
                }
            }
        },

        /**
         * toggleAudioStatus()
         */
        toggleAudioStatus: function() {
            var self = this;
            self.audioStatus((!self.audioStatus()) ? 1 : 0);
        },

        /**
         * audioStatus()
         */
        audioStatus: function(status) {
            var self = this;

            var setToggleButtonText = function(status) {
                if (status) {
                    $('.speech-config-audio-toggle').text(self.model.get('_TTS')._audioSwitchDisableText);
                } else {
                    $('.speech-config-audio-toggle').text(self.model.get('_TTS')._audioSwitchEnableText);
                }
            };
            if (typeof status === 'undefined') {
                if (Cookies.get('audio')) {
                    return parseInt(Cookies.get('audio'));
                }
                setToggleButtonText(self.defaultAudioState);
                return self.defaultAudioState;
            } else {
                Cookies.set('audio', status, { expires: 365, path: '/' });
                // stop audio playing if status is 0
                if (!status) {
                    controller.stopAll();
                }
                // set audio on/off button text
                setToggleButtonText(status);
                // hide/show audio buttons
                if (status) {
                    $('.block-audio-control').show();
                    // play audio for current block when audio is enabled
                    var currentBlockSelector = '.block.nth-child-' + currentBlock;
                    proxy.play($(currentBlockSelector)[0]);
                    Adapt.scrollTo(currentBlockSelector);
                } else {
                    $('.block-audio-control').hide();
                }
            }
        },

        /**
         * render()
         */
        render: function() {
            var self = this;
            // compile button template and append speech button to page/article/block/component element
            var template = Handlebars.templates['speech-config'];
            var element  = $('.article.nth-child-1 .article-title');
            self.$el.html(template(self.model.toJSON())).appendTo(element);
            _.defer(_.bind(self.postRender, self));

            // attach event listeners
            element.find('.speech-config-audio-toggle').click(function(event) {
                self.toggleAudioStatus();
            });
        },

        /**
         * postRender()
         */
        postRender: function() {
            var self = this;
            self.listenTo(Adapt, 'remove', this.remove);
            self.audioStatus(self.audioStatus());
        }
    });

    /**
     * speechButtonView
     * - Backbone view for rendering an audio button control which appears on every block in course topic
     */
    var speechButtonView = Backbone.View.extend({
    	className: 'speech-extension',

    	/**
         * initialize()
         */
    	initialize: function() {
            var self = this;
            if (Adapt.config.has('_TTS')) {
                var conf = Adapt.config.get('_TTS');
                if (conf._isEnabled) {
                    self.model.set('_config', conf);
                    self.model.set('urlEncode', encodeURIComponent(location.href));
                    self.render();
                }
            }
    	},

    	/**
         * render()
         */
    	render: function() {
            var self = this;
    		// compile button template and append speech button to page/article/block/component element
            var template = Handlebars.templates['speech'];
            var element  = $('.' + self.model.get('_id'));
    		self.$el.html(template(self.model.toJSON())).appendTo(element);
    		_.defer(_.bind(self.postRender, self));
            
            // attach event listeners for block audio control
            element.find('.block-audio-button-listen').click(function(event) {
                proxy.play($('.' + self.model.get('_id'))[0]);
            }).addClass('audio-button');
    	},

    	/**
         * postRender()
         */
    	postRender: function() {
            var self = this;
    		self.listenTo(Adapt, 'remove', this.remove);
            // set initial display state
            if (!parseInt(Cookies.get('audio'))) {
                self.$el.find('.block-audio-control').hide();
            }
    	}
    });

    /**
     * Adapt event listeners
     */
    // trigger audio control creation when page has been rendered
    Adapt.on('pageView:postRender',  function(view) {
        proxy.reset();
        if (!view.model.has('_TTS') || (view.model.has('_TTS') && view.model.get('_TTS')._isEnabled)) {
            new speechConfigView({
                model: view.model
            });
        }
    });
    // trigger audio button creation when a block has been rendered
    Adapt.on('blockView:postRender', function(view) {
        //if (!view.model.has('_TTS') || (view.model.has('_TTS') && view.model.get('_TTS')._isEnabled)) {
            new speechButtonView({
                model: view.model
            });
        //}
    });
    // trigger audio when captivate text changes
    Adapt.on('captivate:slideTextChanged', function(view) {
        if (proxy.isAudioEnabled()) {
            view.cpProxy.pause(); // pause captivate to give chance for speech to read current text slide
            proxy.play(view.$('.captivate-text-current')[0], function() {
                if (!view.model.get('_config').autoPause) {
                    view.cpProxy.play();
                }
            });
        }
    });
    // trigger audio when question feedback is shown
    Adapt.on('questionView:showFeedback',  function(view) {
        proxy.play($('.notify-popup-inner')[0]);
    });
    // trigger audio on trickle steplock/continue events
    Adapt.on('trickle:steplock', function(view) {
        if (view.$el.hasClass('block')) {
            // setup component logic and preload audio for current and next block
            // @note: autoplay audio for first block (will not work on mobiles)
            proxy.setupBlockAudio(view.$el, view.$el.hasClass('nth-child-1'));
            proxy.setupBlockAudio(view.$el.next());
            currentBlock++;
        }
    });

    /**
     * Initialisation
     */
    // check if audio cookie is defined. if not set it as disabled by default
    if (!Cookies.get('audio')) {
        Cookies.set('audio', '0', { expires: 365, path: '/' });
    }
});
define('core/js/views/menuView',[
    'core/js/adapt',
    'core/js/views/adaptView'
], function(Adapt, AdaptView) {

    var MenuView = AdaptView.extend({

    	className: function() {
            var visible = "visibility-hidden";
            if (this.model.get('_isVisible')) {
                visible = "";
            }
    		return 'menu ' +
            'menu-' +
            this.model.get('_id') +
            " " + this.model.get('_classes') +
            " " + this.setVisibility() +
            " " + (this.model.get('_isComplete') ? 'completed' : '');
    	},

        preRender: function() {
            this.disableAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;
            this.$el.css('opacity', 0);
            this.listenTo(this.model, 'change:_isReady', this.isReady);
        },

        postRender: function() {
        },

        isReady: function() {
            if (this.model.get('_isReady')) {
                _.defer(function() {
                    $('.loading').hide();
                    $(window).scrollTop(0);
                    Adapt.trigger('menuView:ready', this);
                    var styleOptions = { opacity: 1 };
                    if (this.disableAnimation) {
                        this.$el.css(styleOptions);
                        $.inview();
                    } else {
                        this.$el.velocity(styleOptions, {
                            duration: 'fast',
                            complete: function() {
                                $.inview();
                            }
                        });
                    }
                    $(window).scroll();
                }.bind(this));
            }
        }

    }, {
        type:'menu'
    });

    return MenuView;

});

define('menu/adapt-contrib-boxMenu/js/adapt-contrib-boxmenu',[
    'core/js/adapt',
    'core/js/views/menuView'
], function(Adapt, MenuView) {

    var BoxMenuView = MenuView.extend({

        className: function() {
            return MenuView.prototype.className.apply(this) + " boxmenu-menu";
        },

        attributes: function() {
            return MenuView.prototype.resultExtend('attributes', {
                'role': 'main',
                'aria-labelledby': this.model.get('_id')+'-heading'
            }, this);
        },

        postRender: function() {
            var nthChild = 0;
            this.model.getChildren().each(function(item) {
                if (item.get('_isAvailable') && !item.get('_isHidden')) {
                    item.set('_nthChild', ++nthChild);
                    this.$('.js-children').append(new BoxMenuItemView({model: item}).$el);
                }

                if(item.get('_isHidden')) {
                    item.set('_isReady', true);
                }
            });
        }

    }, {
        template: 'boxmenu'
    });

    var BoxMenuItemView = MenuView.extend({

        events: {
            'click button' : 'onClickMenuItemButton'
        },

        attributes: function() {
            return MenuView.prototype.resultExtend('attributes', {
                'role': 'listitem',
                'aria-labelledby': this.model.get('_id') + '-heading'
            }, this);
        },

        className: function() {
            var nthChild = this.model.get('_nthChild');
            return [
                'menu-item',
                'menu-item-' + this.model.get('_id') ,
                this.model.get('_classes'),
                this.model.get('_isVisited') ? 'visited' : '',
                this.model.get('_isComplete') ? 'completed' : '',
                this.model.get('_isLocked') ? 'locked' : '',
                'nth-child-' + nthChild,
                nthChild % 2 === 0 ? 'nth-child-even' : 'nth-child-odd'
            ].join(' ');
        },

        preRender: function() {
            this.model.checkCompletionStatus();
            this.model.checkInteractionCompletionStatus();
        },

        postRender: function() {
            var graphic = this.model.get('_graphic');
            if (graphic && graphic.src) {
                this.$el.imageready(this.setReadyStatus.bind(this));
                return;
            }

            this.setReadyStatus();
        },

        onClickMenuItemButton: function(event) {
            if(event && event.preventDefault) event.preventDefault();
            if(this.model.get('_isLocked')) return;
            Backbone.history.navigate('#/id/' + this.model.get('_id'), {trigger: true});
        }

    }, {
        template: 'boxmenu-item'
    });

    Adapt.on('router:menu', function(model) {

        $('#wrapper').append(new BoxMenuView({model: model}).$el);

    });

});

define('theme/adapt-contrib-vanilla/js/theme-block',['require','coreJS/adapt','backbone'],function(require) {
	
	var Adapt = require('coreJS/adapt');
	var Backbone = require('backbone');

	var ThemeBlockView = Backbone.View.extend({

		initialize: function() {
			this.setStyles();
			this.listenTo(Adapt, 'device:resize', this.setStyles);
			this.listenTo(Adapt, 'remove', this.remove);
		},

		setStyles: function() {
			this.setBackground();
			this.setMinHeight();
			this.setDividerBlock();
		},

		setBackground: function() {
			var backgroundColor = this.model.get('_themeBlockConfig')._backgroundColor;
			
			if (backgroundColor) {
				this.$el.addClass(backgroundColor);
			}
		},

		setMinHeight: function() {
			var minHeight = 0;
			var minHeights = this.model.get('_themeBlockConfig')._minimumHeights;

			if (minHeights) {

				if(Adapt.device.screenSize == 'large') {
					minHeight = minHeights._large;
				} else if (Adapt.device.screenSize == 'medium') {
					minHeight = minHeights._medium;
				} else {
					minHeight = minHeights._small;
				}
			}

			this.$el.css({
				minHeight: minHeight + "px"
			});
		},

		setDividerBlock: function() {
			var dividerBlock = this.model.get('_themeBlockConfig')._isDividerBlock;

			if (dividerBlock) {
				this.$el.addClass('divider-block');
			}
		}
	});

	return ThemeBlockView;
	
});

define('theme/5c335b25a75aa425946381cc/js/vanilla',['require','coreJS/adapt','backbone','theme/adapt-contrib-vanilla/js/theme-block'],function(require) {
	
	var Adapt = require('coreJS/adapt');
	var Backbone = require('backbone');
	var ThemeBlock = require('theme/adapt-contrib-vanilla/js/theme-block');

	// Block View
	// ==========

	Adapt.on('blockView:postRender', function(view) {
		var theme = view.model.get('_theme');
		
		if (theme) {
			new ThemeBlock({
				model: new Backbone.Model({
					_themeBlockConfig: theme
				}),
				el: view.$el
			});
		}
	});
});

;
define("plugins", ["components/adapt-contrib-assessmentResults/js/adapt-contrib-assessmentResults","components/adapt-contrib-graphic/js/adapt-contrib-graphic","components/adapt-contrib-mcq/js/adapt-contrib-mcq","components/adapt-contrib-narrative/js/adapt-contrib-narrative","components/adapt-contrib-text/js/adapt-contrib-text","components/adapt-lmw-activity/js/adapt-lmw-activity","components/adapt-lmw-photostory/js/adapt-lmw-photostory","extensions/adapt-contrib-assessment/js/adapt-assessmentArticleExtension","extensions/adapt-contrib-blockslider/js/adapt-contrib-blockslider","extensions/adapt-contrib-bookmarking/js/adapt-contrib-bookmarking","extensions/adapt-contrib-resources/js/adapt-contrib-resources","extensions/adapt-contrib-spoor/js/adapt-contrib-spoor","extensions/adapt-contrib-tutor/js/adapt-contrib-tutor","extensions/adapt-hint/js/adapt-hint","extensions/adapt-lmw-mobileFixes/js/adapt-lmw-mobileFixes","extensions/adapt-lmw-publishing/js/adapt-lmw-publishing","extensions/adapt-lmw-speech/js/adapt-lmw-speech","menu/adapt-contrib-boxMenu/js/adapt-contrib-boxmenu","theme/5c335b25a75aa425946381cc/js/vanilla"], function(){});

require([
    'core/js/adapt',
    'core/js/adaptCollection',
    'core/js/startController',
    'core/js/models/buildModel',
    'core/js/models/articleModel',
    'core/js/models/blockModel',
    'core/js/models/configModel',
    'core/js/models/contentObjectModel',
    'core/js/models/componentModel',
    'core/js/models/courseModel',
    'core/js/models/questionModel',
    'core/js/views/navigationView',
    'core/js/accessibility',
    'core/js/offlineStorage',
    'core/js/logging',
    'core/js/tracking',
    'core/js/device',
    'core/js/drawer',
    'core/js/notify',
    'core/js/popupManager',
    'core/js/router',
    'core/js/models/lockingModel',
    'core/js/helpers',
    'core/js/scrolling',
    'core/js/headings',
    'plugins'
], function (Adapt, AdaptCollection, StartController, BuildModel, ArticleModel, BlockModel, ConfigModel, ContentObjectModel, ComponentModel, CourseModel, QuestionModel, NavigationView) {

    // Append loading template and show
    window.Handlebars = _.extend(require("handlebars"), window.Handlebars);

    var template = Handlebars.templates['loading'];
    $('body').append(template());

    Adapt.build = new BuildModel(null, {url: "adapt/js/build.min.js", reset:true});

    // This function is called anytime a course object is loaded
    // Once all course files are loaded trigger events and call Adapt.initialize
    Adapt.checkDataIsLoaded = function(newLanguage) {
        if (Adapt.contentObjects.models.length > 0 &&
            Adapt.articles.models.length > 0 &&
            Adapt.blocks.models.length > 0 &&
            Adapt.components.models.length > 0 &&
            Adapt.course.get('_id')) {

            mapAdaptIdsToObjects();

            Adapt.log.debug('Firing app:dataLoaded');

            try {
                Adapt.trigger('app:dataLoaded');// Triggered to setup model connections in AdaptModel.js
            } catch(e) {
                Adapt.log.error('Error during app:dataLoading trigger', e);
            }

            Adapt.setupMapping();

            Adapt.wait.queue(function() {
                triggerDataReady(newLanguage);
            });

        }
    };

    function triggerDataReady(newLanguage) {
        if (newLanguage) {

            Adapt.trigger('app:languageChanged', newLanguage);

            _.defer(function() {
                var startController = new StartController();
                var hash = '#/';

                if (startController.isEnabled()) {
                    hash = startController.getStartHash(true);
                }

                Backbone.history.navigate(hash, { trigger: true, replace: true });
            });
        }

        Adapt.log.debug('Firing app:dataReady');

        try {
            Adapt.trigger('app:dataReady');
        } catch(e) {
            Adapt.log.error('Error during app:dataReady trigger', e);
        }

        Adapt.wait.queue(triggerInitialize);

    }

    function triggerInitialize() {
        Adapt.log.debug('Calling Adapt.initialize');

        addNavigationBar();

        Adapt.initialize();

        Adapt.off('adaptCollection:dataLoaded courseModel:dataLoaded');
    }

    function addNavigationBar() {

        var adaptConfig = Adapt.course.get("_navigation");

        if (adaptConfig && adaptConfig._isDefaultNavigationDisabled) {
            Adapt.trigger("navigation:initialize");
            return;
        }

        Adapt.navigation = new NavigationView();// This should be triggered after 'app:dataReady' as plugins might want to manipulate the navigation

    }

    function mapAdaptIdsToObjects () {
        Adapt.contentObjects._byAdaptID = Adapt.contentObjects.groupBy("_id");
        Adapt.articles._byAdaptID = Adapt.articles.groupBy("_id");
        Adapt.blocks._byAdaptID = Adapt.blocks.groupBy("_id");
        Adapt.components._byAdaptID = Adapt.components.groupBy("_id");
    }

    // This function is called when the config model triggers 'configModel:loadCourseData'
    // Once the config model is loaded get the course files
    // This enables plugins to tap in before the course files are loaded & also to change the default language
    Adapt.loadCourseData = function(newLanguage) {
        Adapt.on('adaptCollection:dataLoaded courseModel:dataLoaded', function() {
            Adapt.checkDataIsLoaded(newLanguage);
        });

        // All code that needs to run before adapt starts should go here
        var language = Adapt.config.get('_activeLanguage');
        var jsonext = Adapt.build.get("jsonext");
        var courseFolder = "course/" + language +"/";

        $('html').attr("lang", language);

        Adapt.course = new CourseModel(null, {url:courseFolder + "course."+jsonext, reset:true});

        Adapt.contentObjects = new AdaptCollection(null, {
            model: ContentObjectModel,
            url: courseFolder +"contentObjects."+jsonext
        });

        Adapt.articles = new AdaptCollection(null, {
            model: ArticleModel,
            url: courseFolder + "articles."+jsonext
        });

        Adapt.blocks = new AdaptCollection(null, {
            model: BlockModel,
            url: courseFolder + "blocks."+jsonext
        });

        Adapt.components = new AdaptCollection(null, {
            model: function(json) {

                //use view+model object
                var ViewModelObject = Adapt.componentStore[json._component];

                if(!ViewModelObject) {
                    throw new Error('One or more components of type "'+json._component+'" were included in the course - but no component of that type is installed...');
                }

                //if model defined for component use component model
                if (ViewModelObject.model) {
                    return new ViewModelObject.model(json);
                }

                var View = ViewModelObject.view || ViewModelObject;
                //if question type use question model
                if (View._isQuestionType) {
                    return new QuestionModel(json);
                }

                //otherwise use component model
                return new ComponentModel(json);
            },
            url: courseFolder + "components."+jsonext
        });
    };

    function onLanguageChange(model, language) {
        Adapt.offlineStorage.set('lang', language);
        Adapt.loadCourseData(language);
    }

    function onDirectionChange(model, direction) {
        if (direction === 'rtl') {
            $('html').removeClass('dir-ltr').addClass('dir-rtl').attr('dir', 'rtl');
        } else {
            $('html').removeClass('dir-rtl').addClass('dir-ltr').attr('dir', 'ltr');
        }
    }

    /**
    * Before we actually go to load the course data, we first need to check to see if a language has been set
    * If it has we can go ahead and start loading; if it hasn't, apply the defaultLanguage from config.json
    */
    function onLoadCourseData() {
        if (Adapt.config.get('_activeLanguage')) {
            Adapt.loadCourseData();
        } else {
            Adapt.config.set('_activeLanguage', Adapt.config.get('_defaultLanguage'));
        }
    }

    function onBuildDataLoaded() {
        $('html').attr("data-adapt-framework-version", Adapt.build.get('package').version);
        Adapt.config = new ConfigModel(null, {url: "course/config."+Adapt.build.get("jsonext"), reset:true});
        Adapt.config.on({
            'change:_activeLanguage': onLanguageChange,
            'change:_defaultDirection': onDirectionChange
        });

        // Events that are triggered by the main Adapt content collections and models
        Adapt.once('configModel:loadCourseData', onLoadCourseData);

    }

    Adapt.once('buildModel:dataLoaded', onBuildDataLoaded);

});

define("core/js/app", function(){});

